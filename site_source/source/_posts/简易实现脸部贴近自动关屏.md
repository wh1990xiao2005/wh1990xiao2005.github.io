---
title: 简易实现脸部贴近自动关屏
date: 2016-10-16 17:48:47
tags: Android
categories: 编程世界
---

博主最近工作超忙，好久没来更新博客了，真是抱歉。  
今天分享给大家一个简易的Demo，实现的效果是：当手机屏幕贴近脸部时，屏幕自动熄灭。当然，由于是简单的思路，所以这里所谓的“熄灭”并非真的关闭屏幕，而是简单地使用一张黑色背景的图片遮盖住所有显示的内容，看上去像是关闭了屏幕而已。   
整个实现思路较为简单，首先启动监听器，监听距离变化，一旦距离到达一定的接近值的时候，就关掉屏幕；反之则打开屏幕。这里的学问仅在于一个距离传感器返回给我们的距离值，这个距离值会在相应的监听器回调里面获取。   
不多说了，直接上代码：  
需要添加的权限：   

```
<uses-permission Android:name="android.permission.DEVICE_POWER"/>
<uses-permission android:name="android.permission.WAKE_LOCK"/>
```

Java主逻辑：   

```
import android.app.Activity;  
import android.content.Context;  
import android.hardware.Sensor;  
import android.hardware.SensorEvent;  
import android.hardware.SensorEventListener;  
import android.hardware.SensorManager;  
import android.os.Bundle;  
import android.os.PowerManager;  
import android.util.Log;  
import android.view.Menu;  
import android.view.View;  
    
public class SensorTest extends Activity implements SensorEventListener{  
    public static final String TAG = "SensorTest";  
        
    //调用距离传感器，控制屏幕  
    private SensorManager mManager;//传感器管理对象  
    //屏幕开关  
    private PowerManager localPowerManager = null;//电源管理对象  
    private PowerManager.WakeLock localWakeLock = null;//电源锁  
        
    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.sensor);  
            
        mManager = (SensorManager)getSystemService(Context.SENSOR_SERVICE);  
        //获取系统服务POWER_SERVICE，返回一个PowerManager对象  
        localPowerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);  
        //获取PowerManager.WakeLock对象,后面的参数|表示同时传入两个值,最后的是LogCat里用的Tag   
        localWakeLock = this.localPowerManager.newWakeLock(32, "MyPower");//第一个参数为电源锁级别，第二个是日志tag  
    }  
        
    public void onResume(){  
        super.onResume();  
        mManager.registerListener(this, mManager.getDefaultSensor(Sensor.TYPE_PROXIMITY),// 距离感应器  
                SensorManager.SENSOR_DELAY_NORMAL);//注册传感器，第一个参数为距离监听器，第二个是传感器类型，第三个是延迟类型  
    }  
        
    public void onStop(){  
        super.onStop();  
        Log.d(TAG,"on stop");  
    }  
        
    public void onDestroy(){  
        super.onDestroy();  
        Log.d(TAG,"on destroy");  
        if(mManager != null){  
            localWakeLock.release();//释放电源锁，如果不释放finish这个acitivity后仍然会有自动锁屏的效果，不信可以试一试  
            mManager.unregisterListener(this);//注销传感器监听  
        }  
    }  
    
    @Override  
    public void onAccuracyChanged(Sensor sensor, int accuracy) {  
        // TODO Auto-generated method stub  
            
    }  
    
    @Override  
    public void onSensorChanged(SensorEvent event) {  
        // TODO Auto-generated method stub  
        float[] its = event.values;  
        //Log.d(TAG,"its array:"+its+"sensor type :"+event.sensor.getType()+" proximity type:"+Sensor.TYPE_PROXIMITY);  
        if (its != null && event.sensor.getType() == Sensor.TYPE_PROXIMITY) {  
    
            System.out.println("its[0]:" + its[0]);  
    
            //经过测试，当手贴近距离感应器的时候its[0]返回值为0.0，当手离开时返回1.0  
            if (its[0] == 0.0) {// 贴近手机  
    
                System.out.println("hands up");  
                Log.d(TAG,"hands up in calling activity");  
                if (localWakeLock.isHeld()) {  
                    return;  
                } else{  
    
                    localWakeLock.acquire();// 申请设备电源锁  
                }  
            } else {// 远离手机  
    
                System.out.println("hands moved");  
                Log.d(TAG,"hands moved in calling activity");  
                if (localWakeLock.isHeld()) {  
                    return;  
                } else{  
                    localWakeLock.setReferenceCounted(false);  
                    localWakeLock.release(); // 释放设备电源锁  
                }  
            }  
        }  
    }  
    
}  
```

这里特别注意：  
1、在退出的时候务必释放，否则有可能在其他正常使用的情况下仍然会黑屏；  
2、注意非空检查，在某些未配备距离传感器的机型上，会报空。