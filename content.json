{"meta":{"title":"萧爷代码实验室","subtitle":null,"description":null,"author":"Wenhan Xiao","url":"http://www.xiaowenhan.com.cn","root":"/"},"pages":[{"title":"关于","date":"2019-08-01T22:23:03.831Z","updated":"2019-08-01T22:23:03.831Z","comments":false,"path":"about/index.html","permalink":"http://www.xiaowenhan.com.cn/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-08-01T22:23:03.832Z","updated":"2019-08-01T22:23:03.832Z","comments":false,"path":"tags/index.html","permalink":"http://www.xiaowenhan.com.cn/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-08-01T22:23:03.832Z","updated":"2019-08-01T22:23:03.832Z","comments":false,"path":"categories/index.html","permalink":"http://www.xiaowenhan.com.cn/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"决胜Flutter 第一章 熟悉战场","slug":"第一章 熟悉战场","date":"2019-09-09T13:08:45.000Z","updated":"2019-09-09T13:52:41.223Z","comments":true,"path":"2019/09/09/第一章 熟悉战场/","link":"","permalink":"http://www.xiaowenhan.com.cn/2019/09/09/第一章 熟悉战场/","excerpt":"","text":"欢迎参加“决胜Flutter” 实训课程，这里是你此次实训之旅的起点。本章将带您快速了解移动开发的现状，然后向您介绍Flutter的发展历史以及优势特点，最后一起动手，搭建高效的开发环境。由于Flutter 跨平台（同时支持Android、iOS、Web以及PC）的特性，本书将以Mac OS作为操作系统环境，版本号为10.14。如果读者使用的是Windows或者Linux，请结合Flutter官方网站的配置指导进行操作。需要指出的是，Windows和Linux是无法编译生成iOS版本App的。好了，闲话不多说，我们马上进入正题！ 1.1 移动开发的现状今天，我们不得不承认，移动互联网的出现和兴起，给我们的生活和社交带来了前所未有的改变。一部小小的手机不仅是通信的工具，更有着日常生活、移动办公、社交网络等实用工具的属性，已经成为大部分人可信赖的“伙伴”，不断冲击着报纸、广播、电视等传统媒体。事实上，移动互联网发展得如此迅速，操作系统只提供了“平台”，更多得益于其丰富的App生态。也正是因为这样的原因，诞生了一个又一个爆款App。在这些爆款的背后，则是无数的UI/UE设计师、软件工程师、测试工程师等幕后英雄的贡献。同时，随着移动互联网的高速发展，移动App的开发模式也在快速更迭中发展。最初，为了能够在不同系统环境上运行，通常要求开发团队进行多平台并行开发。通常，开发Android和iOS App一共需要两个开发团队，维护两套源代码，分别进行测试。后来，人们逐渐意识到，这样的开发效率并不高，成本却不低。因此诞生了一个接一个的跨平台解决方案。比如React Native、PhoneGap、DCloud等等。但无一例外地，它们都无法摆脱低性能的JavaScript或者原生代码依赖，或多或少地存在不足，某些知名的App技术团队已经宣布弃用它们。亟需一个真正能够打通多平台且高性能的框架来“救场”，Flutter则应运而生。可以说，Flutter的出现有一定的“必然性”。 1.2 初识 Flutter先让我们和Flutter这个新伙伴说声“你好”，然后了解一下这位新伙伴吧！ 1.2.1 Flutter 的历史说到Flutter的诞生，要追溯到2014年。一开始，它被叫做Sky，同年10月在GitHub上开源。一年后，Sky正式更名为Flutter。首次对外公布Flutter是在2017年5月的Google I/O大会上，从此，Flutter正式进入大家的视野，当时的版本号是Alpha 0.0.6。2018年2月，发布了Flutter 1.0测试版，即Beta1。同年6月份发布预览版，即Preview版本。12月发布1.0正式版。2019年2月，在1.2版本中，首次增加了对Web的支持。截至目前，GitHub上的Flutter SDK已经有201个发布版本，超过15000多次代码提交，400多位知名工程师参与其中，其问题的响应速度和处理效率同样非常之迅速……这些都奠定了Flutter终将成为开发者称心如意的开发框架。 1.2.2 Flutter 的特性那么，Flutter 究竟有哪些特性呢？抑或是有哪些优点呢？ 统一的应用开发体验：Flutter拥有丰富的库，帮助开发者快速实现项目需求。同时，大部分的工具和库同时支持Android和iOS； 快速开发：得益于Flutter框架“热重载”的特性，可以帮助开发者更高效地进行开发和测试，更利于修复Bug； 界面生动：Flutter支持跨平台开发，同样支持Material Design（原生Android设计语言）和Cupertino（原生iOS设计语言）风格的控件。开发者可根据设计需要实现不同风格的UI界面； 原生性能：无论在Android还是iOS环境中，Flutter可以提供与原生应用一样的性能，甚至支持120 HZ的高刷新率； 响应式框架：Flutter支持响应式框架，在某些场景下，开发者无需付出任何代价，即可完成不同屏幕的适配，使UI的构建更加轻松； 混合开发：Flutter可以与平台原生代码相结合，支持较新的Kotlin和Swift开发语言。借助该特性，可以轻松访问Android或iOS上的原生系统功能和系统API。到目前为止，Flutter已经广为接受，某些知名厂商已经推出了自己的Flutter App，比如中国的阿里巴巴、腾讯、京东等等。在Flutter官方网站的Showcase页面中，可以找到很多使用Flutter框架开发出的知名产品。 1.2.3 Flutter 的体系结构Flutter框架采用的是“分层结构”。每一层都建立在另一层的基础上，如下图所示： 显而易见地，整个Flutter框架由三层组成，从上到下分别是Framework（框架）层、Engine（引擎）层以及Embedder（嵌入）层。 框架层：框架层由Dart编程语言实现，涵盖了界面组件、动画、手势等等； 引擎层：引擎层由C/C++编程语言实现，涵盖了Skia、Dart和Text： Skia：负责处理图形，它是一个开源的图形库，自身提供了适用于不同软硬件平台的API。Flutter框架直接使用Skia引擎来渲染组件，既摆脱了对传统浏览器的依赖，又摆脱了平台原生控件； Dart：包括Dart运行时环境、垃圾收集、JIT/AOT编译等和Dart相关的支持。经过AOT静态编译的代码能够使用本机指令集运行，从而确保了Flutter App能够和原生App一致的性能； Text：负责文本渲染； 嵌入层：嵌入层可以理解为“兼容层”。正是嵌入层的出现，才确保了Flutter App可以在不同的平台上运行，该层实现了平台无关性。 到此，是不是有点跃跃欲试，想不想亲手开发出一款Flutter App呢？不如马上行动，让Flutter App在设备上跑起来！ 1.3 搭建 Flutter 开发环境动手时间到！第一次，我们先来完成“教学关卡”——配置开发环境。中国有句古话：“工欲善其事，必先利其器。”没有顺手的工具是不行的。通过这一节的学习和实践，相信每位读者都能有一把“开发利器”。让我们开始吧！ 1.3.1 Java 开发环境的安装与配置配置Java开发环境的目的是为了让我们的电脑可以编译Android应用程序。和安装其他软件类似地，在Mac OS上配置Java开发环境非常简单。只需下载对应的安装包文件，然后启动安装即可。Java 开发工具包可以在Oracle官方网站找到，然后下载对应版本即可。这里推荐大家安装JDK 8版本。 下载好后启动安装，片刻等待，进度条满即宣告安装结束。 之后，可以启动终端，在终端窗口中键入 java –version 并回车。能正常输出Java版本信息则表明安装配置无误。 1.3.2 Android 开发环境的安装与配置接下来配置Android开发环境，我们将使用Android Studio作为集成开发环境（也称为IDE）。首先，我们到Android开发者网站下载Android Studio安装包文件。和前文中所述的Java开发工具包类似，下载后安装即可完成配置过程。 当我们点击“DOWNLOAD ANDROID STUDIO”按钮后，网页会自动识别当前系统并下载最合适的版本。 通常，Android Studio的安装会比Java开发工具包的安装更耗时。静候进度条满，我们便可以启动Android Studio了。首次启动会弹出向导，这个向导会指引我们对IDE进行初步配置，并下载缺失的SDK。 需要注意的是，通过首次启动向导下载的SDK，默认只包含了最新版本的内容。如果读者要下载更多的SDK版本，便于日后开发，可以在启动Android Studio后，进入Settings（设置），并查找SDK Manager（SDK管理器）。在这里可以下载到Android SDK所有的内容。接下来，让我们为Android Studio添加编译Flutter App的能力。进入Settings（设置），然后查找Plugin（插件），在上方的搜索框中键入flutter，并回车。如下图所示： 点击INSTALL（安装），会提示安装Dart，点击YES（是）继续。安装完成后，重新启动Android Studio。启动界面上已经可以看到新建Flutter 工程的入口了： 最后，日后方便地使用adb等命令，还需要把Android SDK的路径加入到环境变量中。启动终端窗口，输入 sudo vi ~/.bash_profile 并回车，开始编辑用户级环境变量。在文件的末尾添加如下内容： ANDROID_HOME=/Users/wenhan/Library/Android/sdkexport PATH=$PATH:$ANDROID_HOME/toolsexport PATH=$PATH:$ANDROID_HOME/platform-tools 保存，然后退出vi编辑器。最后，输入： source ~/.bash_profile 然后回车，使环境变量立即生效。测试一下adb命令，正常情况将会出现adb使用说明文档。 1.3.3 iOS 开发环境的安装配置在Mac OS中配置iOS开发环境再简单不过了，只要启动Mac上的App Store，然后搜索Xcode，安装即可。这一步骤可能会耗时很长，在安装时还有可能表现为卡住不动，实际上是安装的内容较多导致的，需要耐心等待。安装好后，启动终端，输入 sudo xcode-select –switch /Application/Xcode.app/Contents/Developer 并回车，配置Xcode命令行工具。最后，输入 sudo xcodebuild –license 并回车，接受许可协议。 1.3.4 其他系统必备组件的安装与配置1.3.4.1 检查系统必备命令行工具除了上述IDE的配置外，Flutter还依赖某些命令行工具，才能成功完成编译。这些工具包括： bash curl git 2.x mkdir rm unzip which 好消息是，Mac OS系统本身已经内置了上述命令，我们仅需确认这些命令能否正常运作即可。 1.3.4.2 设置Flutter Pub镜像站此外，由于Flutter服务器在国内访问可能出现不稳定的现象，我们需要添加两对环境变量，将Flutter包管理网站指向国内的镜像站。该镜像站由GDG China管理和维护，因此无需担心安全性问题。还记得环境变量的配置方法吗？尝试添加如下两对值： PUB_HOSTED_URL=https://pub.flutter-io.cnFLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 如果不慎忘记了配置方法，请参考1.3.2节末尾的内容，如法炮制就好。 1.3.4.3 安装缺失的组件对于编译iOS App，我们还需要安装一些附加工具，这些附加工具被homebrew管理，它堪称Mac OS平台不可或缺的组件管理器。因此，我们需要先安装homebrew软件包管理工具。方法是启动终端，然后输入如下命令后回车： /usr/bin/ruby -e “$(curl -fsSLhttps://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 系统会自动完成安装。之后，依次执行下列几条命令，完成剩余的配置： brew updatebrew install –HEAD usbmuxdbrew link usbmuxdbrew install –HEAD libimobiledevicebrew install ideviceinstaller ios-deploy cocoapodspod setup 1.3.4.4 安装Visual Studio Code在正式进行Flutter App开发前，我们需要学习一种全新的编程语言——Dart。学习Dart编程语言无需Android Studio，也无需任何移动设备。与此相反，一款得心应手的文本编辑器会更加合适，所以更推荐各位读者使用Visual Studio Code。Visual Studio Code同样是跨平台的IDE，因此无论您是使用Mac OS，Windows或者是Linux，都可以使用Visual Studio Code。官方网站下载Visual Studio Code，运行安装程序进行安装，之后不要忘记安装Flutter插件。 1.3.5 Flutter 开发环境的安装与配置1.3.5.1 Flutter SDK的下载和配置接下来，我们需要下载和配置Flutter SDK。下载Flutter SDK的方式有两种选择。第一种是通过Flutter官方网站提供的下载链接；第二种则是通过Git Clone（克隆）的方式下载。由于服务器偶尔会出现连接不稳定的现象，因此，第二种方式最更稳妥的选择。启动终端，定位到要存放Flutter SDK的目录下，输入： git clone -b stable https://github.com/flutter/flutter.git 此处的stable表示要下载稳定版，也可以改为dev来下载最新的开发版。 根据网络连接状况，这个过程通常会持续几分钟，需要耐心等待。下载好后，别忘了配置环境变量，它可以帮助我们在任何位置执行flutter命令。按照前文中提过的方法，这里只需追加PATH变量值即可，如下所示： export PATH=”$PATH:~/Development/flutter/bin” 1.3.5.2 复查所有环境变量的配置到此，关于环境变量的配置就全部完成了，我们回顾一下所有配置的环境变量，如下图所示： 需要特别注意的是，上述环境变量配置的值并非在所有电脑上都一致。请各位读者结合自身电脑的具体情况进行配置，并在配置后执行相应的指令测试，以确保环境配置无误。 1.3.5.3 执行Flutter 自诊断脚本运行终端，输入 flutter doctor 并回车，等待诊断完成。出现下图所示的输出则代表配置准确无误。 诊断进程结束后，会出现类似上图的诊断报告，除了表示正确的对勾外，还可能会遇到感叹号或者叉号。出现感叹号表示它是一条警告，可能不会影响工程的正常编译运行；而叉号则要引起重视了，它表示一种错误。不进行处理的话将会影响工程的编译和运行。如果不幸出现了由叉号的项目，别担心，您可以在1.3.7 疑难排查小节中找到解决它们的办法。 1.3.6 升级 Flutter SDK由于Flutter处在快速发展迭代中，时刻保持最新不但可以体验到新版本带给我们的新功能，而且可以规避老版本中存在的某些问题。当我们按照前文所描述的方法配置好环境变量后，随时可以在终端执行 flutter upgrade 命令检查并更新到最新版本的flutter SDK了。 1.3.7 疑难排查 git clone速度过慢甚至报错：出现该问题，可以尝试访问官网，进入SDK下载页面，直接下载，并在完成后解压。压缩包内存在.git文件夹，不影响日后的版本升级； 出现警告（Android toolchain - develop for Android devices…）：执行 flutter doctor –android-licenses 并同意所有的许可协议； 出现错误（Missing Xcode dependency: Python module “six”）：执行 pip install six 或 sudo easy_install six 或依次执行： brew reinstall python@2pip install six； 升级SDK过程中出错：检查是否配置了正确的环境变量，或者直接重新下载最新版本。 1.4 首个 Flutter App——计数器接下来，我们创建一个计数器应用，用户每点击依次屏幕右下方的按钮，屏幕中间的数值增加1，如下图所示： 计数器App是创建Flutter 工程后的默认App，我们无需修改代码，直接运行即可实现。 1.4.1 创建 Flutter工程有两种方式创建Flutter工程，第一种是通过Android Studio的新建工程向导；另外一种是通过flutter命令行。作者建议使用flutter 命令行创建项目，然后在Android Studio中打开。因为在网络连接不稳定时，新建工程向导可能会导致Android Studio停止响应。使用命令行创建项目的方法非常简单，首先来到要存放工程代码的目录，然后执行： flutter create hello_flutter 稍等片刻，即可完成工程的创建。有关flutter的更多命令行用法，将在1.4.3节中提及。创建好工程后，启动Android Studio，选择“Open an existing Android Studio project”，在弹出的目录选择对话框中，定位到代码所在目录，点击OK，即可打开工程。 怎么样，还算简单吧？ 1.4.2 在设备上运行 Flutter App最后，我们把代码运行在设备上。您可以选择在电脑上启动模拟器，或者连接一台开启了调试权限的手机。作者建议各位使用实体设备，而非模拟器。一方面，实体设备最接近用户最终体验，并且更加流畅；另一方面，某些传感器，如NFC、蓝牙等，是很难通过模拟器实现的。本书也将结合实体设备——一台真正的手机（Android）进行讲解。启动手机，开启开发者选项中的USB调试，然后连接电脑。点击Android Studio右上角的绿色小三角图标，稍等片刻，像图1.15那样，一个简单的flutter App就部署到手机上了。尝试和它互动一下吧！ 1.4.3 Flutter 常用命令在实际开发中，我们有必要掌握一些flutter的常用命令，这将帮助我们更有效率地进行开发。 创建项目： flutter create my_app：以my_app为名创建工程； flutter create -a kotlin my_app：以my_app为名创建工程，并添加对Kotlin语言的支持； flutter create -i swift my_app：以my_app为名创建工程，并添加对Swift语言的支持； 获取工程中引用的库： flutter packages get 更新工程中引用的库： flutter packages upgrade 运行App： flutter run：运行在默认的首选设备上； flutter run -d 5554：运行在ID为5554的设备上。 进入调试模式： flutter attach 打包生成安装文件： flutter build apk：生成Android平台的安装包文件； flutter build ios：生成iOS平台的安装包文件。 1.5 小结请回顾以下几个知识点，确保这些内容都已经了然于心： flutter的特点与优势； flutter框架的体系结构； 开发flutter App的环境搭建； 升级已有的flutter SDK； 创建简单的flutter App； 运行flutter App在设备上； 必知必会的flutter常用命令。 你可能会注意到，上述内容并未涵盖本章的所有方面。这是因为上述的知识点是必须要掌握的，而非仅作了解。请您确认上述内容已经完全掌握后，再进入下一章的学习。在下一章中，我们要进行一场“特训”，目的是让各位读者快速入门并掌握Dart开发语言。我们还将结合计算机领域的某些经典算法进行强化练习，请做好准备，我们即刻出发！","categories":[{"name":"决胜Flutter","slug":"决胜Flutter","permalink":"http://www.xiaowenhan.com.cn/categories/决胜Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://www.xiaowenhan.com.cn/tags/Flutter/"}]},{"title":"做技术，也有“七年之痒”","slug":"做技术，也有“七年之痒”","date":"2019-08-27T13:42:00.000Z","updated":"2019-08-27T13:30:44.396Z","comments":true,"path":"2019/08/27/做技术，也有“七年之痒”/","link":"","permalink":"http://www.xiaowenhan.com.cn/2019/08/27/做技术，也有“七年之痒”/","excerpt":"","text":"掐指一算，距离2013年毕业已经过去六个年头了，如果算上一年的实习期，就有七年了。我不折不扣地成为了一个有将近七年经验职场的“老油条”，一直混迹在Android领域。深陷其中，无法自拔。可能是工作变动的原因，也可能是自己内心还有点“野”，总想摆脱公司对自己的束缚，总想自己搞出点什么名堂。或许用“七年之痒”来形容我现在的工作状态，真的很恰当。但是，回首这几年的工作状态，其实似乎一直是不安分的。2012年开始涉足移动开发领域，转年作为指导老师（那时候自己还没毕业）带团队参加比赛，没想到还拿了奖。2013年毕业后去了第一家公司，结果因为待遇问题和上班路程问题，再加上之前实习的公司同事一直安利我出去创业，就放弃了第一家公司的工作。都说第一份工作非常重要，可是我似乎也没觉得有什么。创业过程并不顺利，仅用了几个月就和合伙人Say bye bye了~时间来到2013年底，我也成功入职了本地的一家国企，拿着不高的工资，做着较为清闲的工作。但也是从这里，开始有了自己的想法。总觉得这样下去不像样，想自己做点什么。2015年底，又有人安利，这次是老同学，而且已经不止一次。我觉得，这也是个机会，就辞职去了。结果项目谈得不是很顺利，辗转到伙伴公司。结果这家创业公司总是让我感觉不踏实，结果还是在我离开之后不久倒掉了。而我则又回到原来的国企，继续之前的工作状态。2017年夏天，工作内容让我越来越反感，领导的管理风格我也不是很对路。于是又开始投简历，10月份入职新公司。2018年底，这家世界500强的企业要关掉位于天津的分公司，当时的就业形势很严峻。不过好事也在此时发生，公司可以安排我去广州的分公司，正好妻子也在广州，于是也没多想，就一个人奔赴广州。2019年可以说是崭露头角的一年，虽然这一年还没结束，但是已经达成的，就是出一本自己的书，而且现在已经交付出版社。接连下来的就是第二本，还有各种在线教育平台的合作邀请。现在的我，再也按捺不住心中的愿望，特别想成立一个属于自己的工作室。甚至连盈利模式都想得差不多了，剩下的就是辞职，然后撸起袖子干了。看上去似乎一直在“飘”，但是总有一条“线”在指导我向前走。这条“线”即为初心，一种对未知充满好奇，对问题追根究底，对结果要求更高，对效率极致追求的态度。2012年出差带队去参加比赛，拿了奖，是完全想不到的。队员都是专科生，平时对学习不怎么在乎，况且连自己都是二把刀。虽然校方很重视，但是整个过程给我的感觉还是很无力。没想到结局还不错，真是意料之外的事情。2013年第一份工作，同时也做出了我的第一个上线APP。这是一个可以从素材图中生成证件照片的APP，当时这种工具类的APP还没有很多款，再加上公司本身是公考教育行业的领头羊，一下子成为了爆款APP。根据当时的移动统计数据，下载量和使用量一度超过公司主营业务APP，我当然欣喜若狂。而且在打造那款APP的时候，真的很投入。现在看上去这实际上是一个很简单的工具类应用，半天时间就可以做出来个Demo。但在当时，对于我来讲，还是蛮有挑战的。有写细节考虑得不是很周全，有些地方也是需要工作经验的积累才能做到更好，这对当时的我而言，是有难度的。不过，也正是由于这一点，让我有了很多次完全投入的体验。那是一种求之不得的工作状态，好像周围的一切和自己都没有关系，是一种完全的投入。旁边的人喊我，我真的听不到。我没有戴耳机，可就是这样被忽略了。同年下半年，和别人一起创业，我负责做技术。特别幸运的是，所做的技术是GIS方面，是和天津测绘院合作的项目。这个项目给了我很多的经验，直到现在，这个项目都是可以放到简历里说一说的。只不过项目保密的原因，我总不能透露太多的内容。只能说，ArcGIS玩得很6。从2014年开始，一方面从事本职工作，另一方面开始注意打造个人品牌。在CSDN上面开了博，持续的输出让我获得了博客专家的荣誉，后来还去认证了CSDN学院的讲师。2015年被安利去的创业公司主打大学生兼职平台，那段时间的进步也是飞快。客服部的同事说：开发部门是很苦的。是的，确实很累。但那也是最锻炼人的。熬夜通宵发版本，各种花式加班打代码都是家常便饭。2016年开始，幸运的事情又来了。这次是做了一套即时消息APP，功能仿照微信，甚至比微信多了传文件的功能（当时的微信不能直接传输文件）。也是吃了点苦，但是没有之前那么苦。更大的收获是思考问题角度的转变：全局观、用户体验优先、APP性能优化等等。这些在之前都很少去思考。2017年国庆后开始，成功从开发工程师转为测试工程师，专做移动性能优化至今。当然，CSDN、博客园、简书、知乎专栏、微信公众号这几个平台一直在维护，再加上独自编写技术类图书，真的越来越累，但成果也是越来越明显。可喜的是，终于可以在技术圈站得住了。在2019年，我几乎彻底放弃了游戏。看过了很多有关自由职业的文章。有同行写的，也有其他行业的朋友分享的。我感觉，现在或许真的是时候了，30岁之前的最后一搏。搏赢了当然是我最希望的，搏输了就老老实实滚去上班好了。趁年轻，浪最后一把！","categories":[{"name":"聊聊人生","slug":"聊聊人生","permalink":"http://www.xiaowenhan.com.cn/categories/聊聊人生/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://www.xiaowenhan.com.cn/tags/其他/"}]},{"title":"我是如何赚到第一笔兼职收入的","slug":"我是如何赚到第一笔兼职收入的","date":"2019-08-19T06:50:49.000Z","updated":"2019-08-28T00:27:38.015Z","comments":true,"path":"2019/08/19/我是如何赚到第一笔兼职收入的/","link":"","permalink":"http://www.xiaowenhan.com.cn/2019/08/19/我是如何赚到第一笔兼职收入的/","excerpt":"","text":"今天我们不聊技术，聊一聊如何增加收入。我知道来读这篇文章的你们都想多挣点零用钱。没问题，这篇文章会系统且有条理地列举可以帮你实现盈利的方式，甚至会超过你的主业收入。听起来很诱人？那就让我们踏上这段旅程吧！ 前言先说说我的职业发展经历，我是2013年毕业的，毕业之后就开始从事移动互联网，做Android App开发。跳槽过几家公司，国企、民企、外商独资都去过，不得不感叹时间过得很快。掰开手指算算，到今天，已经工作了6年了。我这个人有个爱好，就是很喜欢写作。记得还没上大学，那个时候博客很流行，我便经常去博客上发表日志，写下一些值得记录的事情。后来工作了之后，这个习惯依然保留，只不过记录的内容变为了编程经验。多年的写作经验，促使我最终选择试水GitChat，在GitChat上发表图文教程，赚取收入。当然这只是我个人的成长经历，对于更多的朋友，最佳的选择不一定是写作。下面我们就来看看作为程序员，都可以有哪些兼职收入。 兼职赚钱的几种方式 开发：没错，作为程序员，可以接私单，做项目。要知道，一个上线可商用的项目，如果只有你自己来做，那么你的收入直接等于项目金额。你和需求方之间是“透明”的。就好像某二手车平台说的那样：“没有中间商赚差价”，利益可以最大化。但是，这种方式要求你除了掌握过硬的软件开发的本事之外，可能还需要有谈判的本领，项目管理的本领……那我只会开发难道这条路就走不通了吗？当然可以！现在有很多众包平台，在这些平台上，开发者只负责开发，其他的事情基本上平台都会帮你处理好。为了避免广告之嫌，这里就不点名平台名字了，感兴趣的朋友直接读者圈里提问就行了； 讲师：如果你的口才比较好，表达能力很强，应变能力也不错，那兼职当个讲师也是个不错的选择！注意，这里所说的讲师，是广义上的讲师。包含去培训机构或者大学做现场培训，也包括坐在电脑前录制视频课程。大家千万不要小看在线课程，有的人可以靠它实现完全的自由职业！只要你的课程内容够优秀，那么只要你将它传到在线课堂的网站上，静静地等它增值就可以了。比如下面这个： 动动脑，算一算，150元单价，不到10000人购买。嗯，确实是一笔不菲的收入（这里还要算上平台分成、VIP可能会另算价格）； 技术顾问/咨询：这个就比较难了，它对于一个人的技术能力和经验都有很高的要求。尤其是个人品牌没有打响，没有背书的时候，基本不会有什么客户上门； 写作：这种方式是今天我们所说的重点，也是我个人从事兼职的起步方式。现在的写作平台已经有很多，也有盈利的，非盈利的。比如写博客，就是非盈利的，单纯为了分享或者引流；盈利的，比如今天要说的GitChat、微信公众号等等。而且，写作可能还会带给你意想不到的惊喜。以我自己为例，刚开始没想通过写作赚钱，就一直在博客上分享，而且写得要么是搜索引擎搜不到的，要么是前沿的技术。拿到过CSDN的博客专家，申请CSDN学院讲师（这个就是视频课程平台）也很容易通过。后来慢慢扩张，简书、博客园、知乎专栏、公众号，同步发布。真是应了那句话：“辛勤耕耘就会有收获。”今年初，应出版社的编辑的邀请（其实有两个不同的编辑邀请，一开始觉得自己能力还不够），写了一本Flutter入门的图书，目前已交全稿。此外，近期还收到了腾讯NEXT学院的讲师邀请。写作这条路，刚开始可能很困难，很少有人知道你是谁，你会什么。但是时间久了，有内容持续输出，有干货，有人受益，就会得到认可。而且，当你输出的内容越多，话题越广泛，你的内容被搜索到的概率也就越大，被点击浏览的次数也就越多，知道你的人也就越多。慢慢地，你就会从无名小卒成为技术大咖，个人品牌就这样创建起来了。 话说回来，既然本文是教你怎么赚到钱，那自然会选择盈利的平台。这里我特别推荐GitChat，主要原因只有一个——GitChat基本无门槛。只要你有内容，就可以发起一次Chat。完整的一次Chat后，就可以获得收益。下面我们来看看怎样玩“赚”GitChat。 在GitChat平台实现盈利的几条途径总共有3中方式能够实现在GitChat平台盈利。 分享转卖：这种方式无需任何内容输出，只需要打开某个Chat课程或达人课，点击分享卡片，分享出去即可。只要有人通过你分享出去的二维码购买了这个课程，你就可以从中获利。记得要分享付费课程哦！ 上图是本课的二维码分享图示，注意到下面灰色的小字了吗？定价的25%将作为回报。也就是说，本课程定价2.99，如果有人通过你的分享链接购买本课，你将获得不到0.75的收益。由于GitChat平台对于单场Chat定价最高就是9.99，因此你最多获得奖励是不到2.5元的回报。尽量挑一些定价贵且有多人购买的课程哦~ 举行Chat：只要你的肚子里有货，就可以拿来分享！对于单个知识点、小技巧等篇幅较短的题材，可以考虑直接发布Chat。Chat分为免费和收费两种，这里以收费的方式为例。打开GitChat主页，登录后点击右上角的开始创作按钮，随后选择发布收费Chat。 接下来就到了填写Chat简介的页面了，除了要起一个非常吸睛的标题外，内容简介也要尽量详细，但不要过于冗余。写明读者能从本场Chat中获得哪些知识即可。 填写好信息进入下一步，平台开始审核，通过后开放购买。GitChat平台的单场Chat是以购买（即众筹）人数作为第一个达标标准的。如果预定人数过少，本场Chat自动取消。因此，要考虑内容和定价，可以多从消费者的角度思考。如果定价过于离谱，会有客服人员介入，帮助修改价格。等待时间是7天，7天过后且预订人数达标，你就可以开始写文章了。写文章的时间同样有7天。当然，达标与否将通过微信通知，文章出炉后，也会有微信通知。和读者交流可以通过读者圈和微信群。如果是微信群的话，不要忘记在预定的时间登场，读者圈的话就随时提问随时答复就可以啦！~ 如果你要写的东西比较系统，内容较多，可以考虑申请达人课。申请达人课和举行单场Chat不同，达人课可以简单地认为是多场Chat的集合，且每场Chat互相关联，可以作为一本手册使用。申请达人课的入口在主页右侧，点击“成为课程作者”进入，下图就是发布达人课的界面： 申请达人课要求作者必须对自己的课程胸有成竹，有明确的组织安排，而且内容要足够多（要9篇以上数量的文章）。同时，达人课的审核机制也更为复杂和严格。发布的达人课可以在平台的课程频道找到。 GitChat平台的结算方式根据GitChat官方的常见问题，对于一场Chat的收益是这样分配的： 看起来似乎有点云里雾里的，还是以我个人为例吧，第一场Chat的收益截图： 你可能会遇到哪些问题，以及如何应对它们在GitChat发布课程，整体的体验还是很愉悦的，但是对于新手而言，可能面临的问题是——快到预定截止时间了，购买人数不够怎么办？我的建议是，一旦审核通过开放购买，立刻想办法做推广，比如朋友圈、微博等等，尤其是新手。实在不行，呼朋唤友来购买也行…… 在GitChat发布课程，会有什么额外收益 无论是GitChat平台上发布的Chat还是达人课，它们的收益都不是一次性的买卖。如果Chat结束后，还有人购买，则还会有收益； 这种技能的分享过程，对读者而言是学习到了新知识，对于作者而言，则是巩固已有的知识，从这个角度讲，是双赢的； 通过在GitChat平台上发表文章，可以促进树立个人品牌，尤其是达人课。如果成为训练营或者专题里面的内容就更好了。 好了，内容到此就结束了，希望各位能从中获益，我们回头见！","categories":[{"name":"自媒体运营","slug":"自媒体运营","permalink":"http://www.xiaowenhan.com.cn/categories/自媒体运营/"}],"tags":[{"name":"兼职","slug":"兼职","permalink":"http://www.xiaowenhan.com.cn/tags/兼职/"}]},{"title":"让我对豆瓣感兴趣的人，我和她结婚了","slug":"让我对豆瓣感兴趣的人，我和她结婚了","date":"2019-08-16T04:17:49.000Z","updated":"2019-08-28T00:27:38.021Z","comments":true,"path":"2019/08/16/让我对豆瓣感兴趣的人，我和她结婚了/","link":"","permalink":"http://www.xiaowenhan.com.cn/2019/08/16/让我对豆瓣感兴趣的人，我和她结婚了/","excerpt":"","text":"引子2011年8月15日，我注册了豆瓣账号，成为了豆瓣网的注册用户。那一年，我们在同一所大学，读着同样的专业，在同一个班。2019年8月15日，我习惯性地打开豆瓣App，看到启动闪屏。不由感叹，时间好快，一转眼8年过去了。而那个让我对豆瓣网感兴趣的姑娘，我们也终于结发为夫妻了。 一2019年8月15日，我习惯性地打开豆瓣App，闪屏也出现注册8年的动图，不由想起了8年前来到豆瓣的缘由。8年前，我们还都在天津读大学，她是一个来自广州的南方姑娘。看上去温柔又可爱，让我对她产生了莫名的好感，于是很是关注她的QQ空间动态。某一天，看到她发表状态，大概意思就是以后不再沉迷于豆瓣之类。我心里好奇怪，豆瓣到底有多么大的吸引力，能够让她沉迷其中呢？怀着好奇的心情我打开了豆瓣，觉得内容还不错，找书找电影找音乐都很方便，别人的评论也值得参考，于是便在那时注册了一个豆瓣账号，从此开始了我的豆瓣生涯。8年过去了，本来想给她一个惊喜，告诉她整个事情。然而当她启动豆瓣App时，显示的闪屏动图却首先惊喜到了我。 原来，我们是在同月同日注册的，只是她比我早到一年。这般巧合让我们不由感叹，冥冥之中自有天意。 二2009年高中毕业，我们一同被天津师范大学录取，成为同班同学。在做自我介绍的时候，我留意到她。那个时候的她，讲着略带广东腔的普通话，说话时略显羞涩。记忆最深的就是那句：“如果有人想学粤语可以找我。”话罢，同学们还发出惊呼。就在那时，我便记住她了。 和那些比较狗血的程序员故事一样，学生时代的我们唯一的交集就是我帮忙给她修电脑。据我现在的回忆，总共修电脑至少3次，在线解答问题不确定多少次。甚至到了毕业多年之后，我们的交集仍然是和电脑相关的话题。为此，我还特意做了一份手账，可能略显粗糙。 这篇手账名为重逢之前。是的，从2013年毕业后，我们就住在不同的城市。从天津到广州，2000多公里。地理上的距离似乎也拉远了我们之间本来就不近的距离，那个让我有好感的姑娘，更是随着时间的流逝，渐渐地越走越远了。 三网上很多文章，讲述了很多毕业就分手的例子，毕业季=分手季。然而这对我们而言，丝毫没有影响，因为我们并没有开始。2013年，隐约记得也是夏季。那个时候我刚毕业，和豆瓣的交集就是在读书学习的时候打开豆瓣FM，在买书之前看看书评，在买CD之前看看碟评。某一日晚上下班，和同事坐地铁。突然电话铃响，手机上赫然显示着她的名字，我接了电话。要事说罢，开始短暂的闲聊。我问她，毕业之后打算留在天津吗？不料，得到了否定的答案。不过，即便如此，我还是回应，如果有困难，不管是生活上的还是经济上的，我都可以帮助你。然而，当时的我，可能连自己都还照顾不好。说这话其实是没有十足的底气的，还好她只表达了谢意。实际上，我的潜台词是：留下来吧，让我照顾你。多年之后，再次聊到这里时，坦率地说出了各自的感受： 妻：我想起来毕业的时候你跟我说经济困难的话可以支持我一下，我那时候只是觉得你人挺好的，也没想过其他，好像最近才明白你的意思。我：那个时候说实话，我的经济挺拮据的。不过那会儿确实是不太想见不到你，毕竟可能从此再也见不到面了。我觉得如果能和你在一起，会是我的荣幸。 嗯，没错，当时我被送了好人卡，很像现在很多网文描述的那样，这一波操作给满分。 四从13年毕业到18年，都是我的单身时光。刚开始和父母一起住，16年开始自己住。值得高兴的是，赶在房价大涨之前买了房，还是纯公积金贷款，相对压力小很多。感觉像是躺着赚钱。这一段时间，豆瓣网对我而言，也像躺着赚钱一样逐步丰满。除了看各种书、碟评论外，我还喜欢上了标记。标记自己读过的书、想读的书和在读的书，对于CD唱片也是这样。虽然希望遇到志同道合的朋友，但是又不想草率，总觉得豆瓣算是互联网上的一块净土了。 到今天，我仍然仅关注了9个成员，被4个成员关注。 五2018年，由于我所在的公司派我去广州，进行为期一周的差旅。我便抽时间和多年未见的她见面聊天。没想到，这一次见面，似乎拉开了我们婚姻的序幕。她让我深深地感受到，除了还是充满广东腔的普通话，除了还是那个外表可爱的女孩外，还让我感受到她的耐心、体贴和舒服。和她说话，总是让人觉得莫名的舒服，而且具有同理心。我们一起去了广州塔，在珠江边散步。她让我看到了她的勇气和毅力，这足以给身边的人树立一个榜样，在思想和行动上已经算是一个巨人了。虽然她说行动上还要再观察，但我相信她不会让我失望的。这次见面不再是简单的好感，而是欣赏和佩服。有些话，我想不到会从她的嘴里说出来。连她自己也感觉到，在我的认识里，她只是简单做一份稳定的工作，然后找个靠谱的男人嫁了就好了的那种。而现在，我感觉到，她已经不再是小女孩，虽然看上去不怎么起眼。她拥有着一刻赤子之心，有自己的坚持。虽然年龄在增长，但是灵魂还是年轻的。这是最让我感到震惊与震撼的地方。我们没有经历谈恋爱，似乎也没有过多的甜蜜，一切事情都是平淡无奇，顺理成章的进行。18年年底，我们终于领证了，成为了受法律保护的夫妻。 六感谢豆瓣，多年来的陪伴。我们的故事未完待续……","categories":[{"name":"闲情记趣","slug":"闲情记趣","permalink":"http://www.xiaowenhan.com.cn/categories/闲情记趣/"}],"tags":[{"name":"闲情记趣","slug":"闲情记趣","permalink":"http://www.xiaowenhan.com.cn/tags/闲情记趣/"}]},{"title":"津城随手拍合集","slug":"津城随手拍合集","date":"2019-08-01T06:11:27.000Z","updated":"2019-08-28T00:27:38.019Z","comments":true,"path":"2019/08/01/津城随手拍合集/","link":"","permalink":"http://www.xiaowenhan.com.cn/2019/08/01/津城随手拍合集/","excerpt":"","text":"","categories":[{"name":"摄影作品","slug":"摄影作品","permalink":"http://www.xiaowenhan.com.cn/categories/摄影作品/"}],"tags":[{"name":"随手拍","slug":"随手拍","permalink":"http://www.xiaowenhan.com.cn/tags/随手拍/"}]},{"title":"身为程序员，你焦虑吗","slug":"身为程序员，你焦虑吗","date":"2019-07-02T10:56:15.000Z","updated":"2019-08-01T22:23:03.830Z","comments":true,"path":"2019/07/02/身为程序员，你焦虑吗/","link":"","permalink":"http://www.xiaowenhan.com.cn/2019/07/02/身为程序员，你焦虑吗/","excerpt":"","text":"2019年已经过了大半，如果要用一个词来形容今年的互联网就业形势，那会是什么呢？没错，是“寒冬”！去知乎上面搜索“互联网 寒冬”，看看这些搜索结果吧： 再来搜搜“互联网 裁员”： 从2018年开始，很多互联网公司纷纷传出裁员的消息，其中不乏一些大公司，比如Oracle、京东、滴滴等等。还有我任职的天津三星研究院，也在2018年底关停了。看看百度搜出来的结果，光看标题就足够让人触目惊心： 著名的企业家、美团网的创始人王兴说：“2018年是过去十年最差的一年，也是未来十年最好的一年”。如果这些内容，让你看过之后更加焦虑，真的很抱歉，但这都是客观事实……老实讲，在我得知我所在的公司要关停的消息时，也很想不到。总觉得这些裁员之类的事情不会发生在自己身上，但是它确确实实地发生了。难道我不曾焦虑过吗？并不是！我也曾陷入过深深的焦虑之中，那种感觉，真的很痛苦。但是焦虑有用吗？并没有！各位想一想，一味的焦虑，会让我们发生怎样的变化呢？可能会抱怨这个社会不公平？抱怨自己的命不好？和自己同病相怜的同事一起吐槽？疯狂地投简历，唯恐经济“断粮”？……这些只能让你陷入更糟糕的境地，让你体会不到事业带给你的快乐。前几天我在樊登读书会里面听到一本书，里面有这样一个故事，讲的是一对父母，平时要求孩子成绩要好，要做全校第一名，要去争取各种荣誉……但是有一天，孩子突然得了重病，这个时候的父母唯一的希望是：“孩子，你只要健健康康、快快乐乐地就好。”“只要健健康康、快快乐乐地就好”，那些成绩呢？排名呢？荣誉呢？……真正能让孩子变得健康快乐的，是成绩吗？是排名吗？是各种荣誉吗？那些外在的东西已经变得不重要了，最核心、最重要的东西显现了出来。这其实对于我们每个成年人也是一样的，我们整天奔波于家庭和公司，忙碌于挣钱养家，却往往忽视了一个更为重要的信念：那就是什么才是真正的幸福，怎样才能得到真正的满足？哈佛大学著名的幸福课讲师：泰勒•本-沙哈尔写过一本书，书名为《幸福的方法》。 作者在16岁的时候夺得了以色列壁球冠军。为了得到这个冠军，他经历了五年的艰苦训练。在最终夺冠后，他突然觉得很空虚，感到迷茫和恐惧。显然，冠军并没有带给他想象中的幸福感。这是不是和上面所说的父母的做法如出一辙？是不是和今天的一些不妥当的教育方式如出一辙？“等你考上大学，你就成功了”、“等你考上大学，我就放心了”……好像学习、升学，从来都是为了满足他人的期待……请问：有多少家长、老师还在给下一代灌输这样的思想；再请问：有多少参加高考的学生，是真真正正体会到学习的乐趣，明白学习的意义；再请问：有多少大学生，在大学期间是不迷茫的？ 你看，一样地放手一搜，照样一大把关于大学迷茫的搜索结果，而且居然还有人将这个话题写成了书，评分居然还是10…… 看看目录，是不是感到全书都在透露着迷茫和焦虑……想要平稳地度过“寒冬期”，首先要做的就是不迷茫，不焦虑！好难啊，我被裁员、经济断粮，怎么养家，你让我不焦虑，怎么可能？ 我们来看看苹果教父乔布斯的经历：受禅宗与瑜伽思想的影响，乔布斯不断地练习冥想，将他的心灵和专注力不断洗涤，抵达一种空镜，从而训练自己的思考和洞察力，并日益敏锐。乔布斯在做重要抉择前，譬如产品的取舍。决策前，他会先闭目静坐，然后叫属下将相关产品的设计一并放到禅垫的周围，他来决定选择哪个放弃哪个。这样做抉择时，乔布斯用的是“直觉”。透过这些常人看起来匪夷所思的事情，乔布斯保持了高度敏锐的头脑。任何东西，他一看，就知道问题所在。那种一针见血的能力，来自于高度发达的智能。而这种智能，并不是分析性逻辑性的演算，而是极度清晰明澈的头脑中，大量信息瞬间聚合运算的结果，我们称之为“直觉”。正是这种由冥想带来的直觉，帮助乔布斯获取大量的灵感。没错！当我们在处理难题、克服阻碍、面对困境时，也可以尝试这种叫做“冥想”的方法来帮我们跨过重重艰难。实际上，不仅是乔布斯，还有比尔盖茨、科比……他们都是冥想的忠实粉丝。为什么他们都如此钟爱“冥想”呢？美国冥想协会定义冥想为：一种能够充分感受自己内心平静、祥和的简易形式。真正的冥想可以帮助你建立良好的注意力，并把注意力集中在当下此刻，从一个更高的角度观察自己的想法和感觉，从而平静地接受现实。大家都看过功夫熊猫吧？第一部里面，从一开始，师傅就不认可蠢笨的熊猫能够打败太郎，一直为即将被太郎血洗的村子的安危担忧和焦虑。此时，乌龟大师告诉他： Yesterday is history.Tomorrow is a mystery.But today is a gift.That is why it’s called the present (the gift). 意思是：过去的,已经过去了，未来的,还未可知。现在,却是上苍的礼赠，那就是为什么称今天是“Present(现在/礼物)”。 Your mind is like this water. When it is agitated, it becomes difficult to see, but if you allow it to settle, the answer becomes clear. 意思是：心如此水，乱则不明。但若心如止水，答案便尽现眼前。 如何才能在焦虑面前做到专注当下、心如止水呢？答案是——冥想。冥想让心静下来，倾听内在灵魂的声音。哈佛研究指出，每天进行冥想将大大有助于您内心的平静，缓解工作生活中的压力和焦虑，改善抑郁和失眠，减轻慢性疾病所带来的疼痛。 如何科学地进行冥想呢？先选择一个舒服的地方坐下来，你可以坐在家里的沙发上，或是办公室的椅子上。接下来，慢慢地闭上眼睛，把注意力尝试放在自己的呼吸上。就这样，安静地坐3分钟。三分钟过后，感觉怎么样？是不是脑袋里总有想法冒出来？工作报告怎么写，今天晚饭吃什么，车子又要加油了。哦，对了，昨天部门里的赵老弟还让我帮他处理点事情……是不是觉得自己比总统还忙……我们经常被这些东西挡住视线，以至于忽略了比它们更重要的东西。前文中的考生家长如此，失业时的焦虑亦会如此。在收拾行囊上路前，我们首先要做的，就是拨开这些“迷雾”，不要被一片树叶挡住眼睛，而忽视了后面的高山。有些时候，当我们陷入思维的迷宫，很难自己走出来。就好像陷入沼泽地的猛兽，虽然力气很大，但最终无法自救（想想著名的软件管理类书籍《人月神话》中的“焦油坑”，如果盲目地增加人手，对软件项目而言，反而起到负面的作用）。这个时候，就要求我们做一个“静观者”，以一个旁观者的心态去看我们正在经历的事情。正所谓“当局者迷，旁观者清”，说的是一样的道理。当我们进入冥想的状态，即真正的无思虑的状态时，慢慢地，一切都会变得清澈可见，答案也会慢慢地浮出水面。苏格拉底说：要认识你自己。但事实上，很少有人真正的了解自己。冥想可以让我们专注，从纷乱的世界中抽离出来，从而更多地关注自己，听见并看见自己的内心，重新发现自己人生的方向。进而帮我们想清楚一些平时完全没有头绪的事情，做出在日后觉得，这是正确的事的决定。要做到这一点并不难，每天清晨和临睡前各冥想10分钟，就可以有效地改善自己的注意力，缓解压力，舒缓心情。坚持冥想一段时间后，你还会发现更多的有利变化，比如：在工作时，更专注，更有效率；睡眠质量改善，每天精神倍增；坏情绪、负面力量几乎无法再来伤害你……当然，正如前文所说，在一开始的时候，脑子里会有各种想法冒出来。要知道，我们最终要达到的效果是：“完全放空”，只有这样，称得上是真正的冥想；只有这样，冥想才能真正帮到我们。 怎样达到这样的效果呢？要牢记的一点是：不要强迫你的想法离开，更不要用另一个念头来压制这个念头。当想法来的时候，我们只需静观它，不要对它起反应。当我们能站在更高的位置去审视它的时候，会发现这些想法是多么渺小，多么不值一提。慢慢地，它自己就会从我们的脑子里消失了。 怎么样？要不要去试试？欢迎留言，写下你的冥想感受，前三位留言的朋友还会获得下一场GitChat的免费入场券。赶快行动吧！","categories":[{"name":"聊聊人生","slug":"聊聊人生","permalink":"http://www.xiaowenhan.com.cn/categories/聊聊人生/"}],"tags":[{"name":"人生杂谈","slug":"人生杂谈","permalink":"http://www.xiaowenhan.com.cn/tags/人生杂谈/"}]},{"title":"无题","slug":"无题","date":"2019-05-10T11:10:49.000Z","updated":"2019-08-28T00:27:38.016Z","comments":true,"path":"2019/05/10/无题/","link":"","permalink":"http://www.xiaowenhan.com.cn/2019/05/10/无题/","excerpt":"","text":"","categories":[{"name":"摄影作品","slug":"摄影作品","permalink":"http://www.xiaowenhan.com.cn/categories/摄影作品/"}],"tags":[{"name":"随手拍","slug":"随手拍","permalink":"http://www.xiaowenhan.com.cn/tags/随手拍/"}]},{"title":"高中的教室","slug":"高中的教室","date":"2019-04-27T02:36:00.000Z","updated":"2019-08-28T00:27:38.022Z","comments":true,"path":"2019/04/27/高中的教室/","link":"","permalink":"http://www.xiaowenhan.com.cn/2019/04/27/高中的教室/","excerpt":"","text":"","categories":[{"name":"摄影作品","slug":"摄影作品","permalink":"http://www.xiaowenhan.com.cn/categories/摄影作品/"}],"tags":[{"name":"观世界","slug":"观世界","permalink":"http://www.xiaowenhan.com.cn/tags/观世界/"}]},{"title":"Android Jetpack之AppCompat - Actionbar篇","slug":"Android Jetpack之AppCompat - Actionbar篇","date":"2019-03-11T14:05:21.000Z","updated":"2019-08-28T00:27:38.010Z","comments":true,"path":"2019/03/11/Android Jetpack之AppCompat - Actionbar篇/","link":"","permalink":"http://www.xiaowenhan.com.cn/2019/03/11/Android Jetpack之AppCompat - Actionbar篇/","excerpt":"","text":"今天我们来聊一聊有关AppCompat，作为Android Jetpack系列文章的开篇。说到Android Jetpack，我们先看一下这张图： 从图中我们可以看到，整个Android Jetpack分为了四大部分，而我们今天要讲述的就是Foundation中的AppCompat小节，官方将该部分翻译为“基础”。Google官方网站：https://developer.android.com/jetpack按照Google官方的描述，AppCompat就是指v7 appcompat库。 “This library adds support for the Action Bar user interface design pattern. This library includes support for material design user interface implementations.” 意思是：此库添加了对操作栏用户界面设计模式的支持。这个库包括对Material Design用户界面实现的支持。也就是说，我们可以借助该库，对Material Design有更便捷和兼容性更好的实现。进入AppCompat章节后，我们发现它又被分为了4个部分，这4个部分被称为“key class”，也就是重点类，它们分别是： ActionBar：提供Actionbar用户界面模式的实现； AppCompatActivity：添加可用作使用支持库操作栏实现的Activity的基类； AppCompatDialog：添加一个可用作AppCompat主题的Dialog的基类; ShareActionProvider：添加对可包含在ActionBar中的标准化共享操作（如电子邮件或发布到社交应用程序）的支持。 想要使用这些类，我们需要添加v7支持库。到现在为止，支持库的最新版本是28，添加的库名称和版本如下： 1com.android.support:appcompat-v7:28.0.0 今天我们就先来聊一聊ActionBar，也是这里面最为复杂的一个部分。依稀记得，伴随着Google I/O 2014的召开，早在Android 5.0的时代，Google 官方推出了ToolBar组件，在那之后，ToolBar就登上了历史舞台，扮演着重要的角色。之前我在CSDN上面也发表过相关主题的文章，因为发布的时机刚好是ToolBar登场之际，所以获得了很多的阅读量。快5年过去了，回头再看那几篇连载，感觉文笔很是稚嫩。今天借着讲述Jetpack，再次聊聊ToolBar那些事，相信你我都会有新的收获。 首先解决疑问： 问：既然有了ActionBar，为何还要用ToolBar？ 答：使用AppCompat Toolbar能兼容更广泛的设备（ActionBar要求最低Android 3.0，ToolBar要求最低Android 2.1，但只有Android 5.0及以上才能在不使用AppCompat兼容包的前提下支持Material Design），以及各式各样的自定义需求。 问：ToolBar上面都应该包含哪些内容？ 答：根据Google的指导，应用栏区域应具备以下要素：1）一个专用区域，可以标识您的应用并指示用户在应用中的位置；2）以可预测的方式访问搜索等重要操作；3）支持导航和视图切换（通过标签页或下拉列表）。 一、添加ToolBar想要添加一个ToolBar，总共3步走：1. 更改application主题样式，操作对象：styles.xml。对于新建的Android项目，AndroidManifest.xml中已经定义了所使用的theme，即： 1android:theme=&quot;@style/AppTheme&quot; 此时，我们修改styles.xml文件即可，将默认的继承值改掉，如下所示： 1&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; 2. 在Activity布局中添加ToolBar，操作对象：layout布局文件 12345678&lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/activity_main_tb&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:background=&quot;?attr/colorPrimary&quot; android:elevation=&quot;4dp&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.ActionBar&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&gt; 对高度掌握不好火候的同学，直接如上使用ActionBar的高度就可以了。android:evevation指“仰角”，这部分知识请参考：https://developer.android.com/training/material/shadows-clipping这里就不再赘述了。如果你的项目已经迁移到Android X，你的布局文件代码片应该是： 12345678&lt;androidx.appcompat.widget.Toolbar android:id=&quot;@+id/activity_main_tb&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:background=&quot;?attr/colorPrimary&quot; android:elevation=&quot;4dp&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.ActionBar&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&gt; 3. 在Activity类中找到ToolBar，并应用它，操作对象：Activity类这一步并不复杂，参考普通的Android控件。类似地，我们通过findViewById()找到ToolBar，并做执行一些设定，即可完成该步骤，示例如下： 123private Toolbar topTb;topTb = findViewById(R.id.activity_main_tb); setSupportActionBar(topTb); 一旦我们setSupportActionBar()后，日后我们就可以通过getSupportActionBar()方法来获取ToolBar实例，也可以使用兼容包提供的ActionBar的各种API方法了。到此，我们就完成了ToolBar的添加，还算简单吧？ 二、ToolBar外观的自定义不出意外的话，我们运行的结果将会和下图类似： 大绿底，大黑字，实在不怎么好看。那么，如果我们想要自定义配色方案，该如何做呢？参考下图： 这些值我们都可以在color.xml中定义，并在styles.xml中引用。下图是一个重新定义配色方案后的截图： 相关的代码片： color.xml 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;color name=&quot;colorPrimary&quot;&gt;#002FA7&lt;/color&gt; &lt;color name=&quot;colorPrimaryDark&quot;&gt;#001F67&lt;/color&gt; &lt;color name=&quot;colorAccent&quot;&gt;#003FB7&lt;/color&gt; &lt;color name=&quot;textColorPrimary&quot;&gt;#FFFFFF&lt;/color&gt;&lt;/resources&gt; styles.xml 123456&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;item name=&quot;android:textColorPrimary&quot;&gt;@color/textColorPrimary&lt;/item&gt;&lt;/style&gt; 细心的读者会发现，后面的截图中，右上角多了菜单项，这又是如何实现的呢？我们继续往后看。 三、给ToolBar增加动作首先我们来看看如何给ToolBar增加菜单，我们依然分为3步完成。1. 编写菜单xml文件，操作对象：menu文件夹下的菜单xml文件这里我添加了两个菜单，如上图所示，一个隐藏在“更多”里，另一个是搜索。如下代码片所示： 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;item android:id=&quot;@+id/menu_main_info&quot; android:title=&quot;@string/menu_main_activity_info&quot; app:showAsAction=&quot;never&quot; /&gt; &lt;item android:id=&quot;@+id/menu_main_search&quot; android:title=&quot;@string/menu_main_activity_search&quot; app:actionViewClass=&quot;android.support.v7.widget.SearchView&quot; app:showAsAction=&quot;always&quot; /&gt;&lt;/menu&gt; 如上，我们可以看到有两个item，分别对应Info和搜索，我们使用”app:showAsAction”的值来控制这个菜单是否显示，常见的值有always，ifRoom，never。从字面上也很好理解，这里就不多解释了。 2. 接下来是Java代码片段： 123456789private SearchView tbSearchSv;@Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.main_activity_menu, menu); MenuItem searchItem = menu.findItem(R.id.menu_main_search); tbSearchSv = (SearchView) searchItem.getActionView(); return super.onCreateOptionsMenu(menu);&#125; 细心的朋友会发现有这一行： 1app:actionViewClass=&quot;android.support.v7.widget.SearchView&quot; 它是做什么的呢？ 对了！它就是搜索栏，是原生的搜索栏。所以某些情况下，这个搜索栏是不用自己去实现的，系统已经给我们提供了SearchView！典型的APP：网易云音乐、知乎上方的搜索都是这样的。 3. 为菜单设置监听器，我们先来看最普通的Info按钮，我们只需在Java代码中Override指定的方法就可以了，如下所示： 123456789@Overridepublic boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.menu_main_info: Toast.makeText(MainActivity.this, R.string.menu_main_activity_info, Toast.LENGTH_LONG).show(); break; &#125; return super.onOptionsItemSelected(item);&#125; 对于搜索栏，首先我们想到的是，如何获取用户输入的内容呢？其实很简单，玄机在于SearchView，只需对SearchView添加监听器就可以了。 12345678910111213tbSearchSv.setOnQueryTextListener(new SearchView.OnQueryTextListener() &#123; @Override public boolean onQueryTextSubmit(String s) &#123; return false; &#125; @Override public boolean onQueryTextChange(String s) &#123; return false; &#125;&#125;); 这里要注意，设置监听器前，要确保SearchView（这里的tbSearchSv）已经被实例化，否则，会出现空指针异常崩溃。关于SearchView，还有一写额外的设置，比如： 12// 设置提交按钮是否可见（默认不可见）tbSearchSv.setSubmitButtonEnabled(true); 12// 设置左侧是否显示搜索图标（默认不可见）tbSearchSv.setIconifiedByDefault(false); 更多可使用的API请参考官方文档：https://developer.android.google.cn/reference/android/widget/SearchView 不过，我们这里还需要做最后一点善后。如果你是一路下来照着本篇文章敲代码的话，在搜索框打开的情况下按一下返回键，你期待的是什么？是不是取消搜索操作，停留在当前界面？然而实际上是……退出了APP。所以我们这里要对返回键的默认动作做一个“拦截”，具体可参考如下代码片： 123456789101112@Overridepublic boolean onKeyUp(int keyCode, KeyEvent event) &#123; switch (keyCode) &#123; case KeyEvent.KEYCODE_BACK: if (!tbSearchSv.isIconified()) &#123; tbSearchSv.setIconified(true); return true; &#125; break; &#125; return super.onKeyUp(keyCode, event);&#125; 这里SearchView的isIconfied()方法可以返回当前的SearchView展开状态。 四、返回上一层 ToolBar还有一个比较常见的功能就是左上角的返回按钮，提供返回上一层操作，很多的APP开发者都习惯于自定义一个ImageButton或类似的空间，然后使用美工提供的图像素材，设置监听器，写Selector……一套下来，费时费力。其实Google已经为开发者提供了现成的非常易用的返回逻辑处理。要实现这些处理，两步就搞定了。 1. 在ToolBar对象上启用返回钮 1getSupportActionBar().setDisplayHomeAsUpEnabled(true); 这里注意，虽然之前将ToolBar通过setSupportActionBar()方式当做参数被set了一次，但是ToolBar类本身并不提供setDisplayHomeAsUpEnabled()方法，因此，我们还需要getSupportActionBar()，先获取ActionBar对象，然后使用该对象，而不是直接使用ToolBar对象。 2. 在AndroidManifest.xml中定义要跳转的Activity如题，我们在AndroidManifest.xml中，对子Activity做处理，这里不要忘记兼容低版本的系统。 12345678&lt;activity android:name=&quot;.MainActivity&quot; android:parentActivityName=&quot;.SecondActivity&quot;&gt; &lt;!-- 兼容 Android4.0 及以下版本--&gt; &lt;meta-data android:name=&quot;android.support.PARENT_ACTIVITY&quot; android:value=&quot;.SecondActivity&quot; /&gt;&lt;/activity&gt; 将SecondActivity改为入口Activity，然后重新运行程序，将实现如下效果： 到此，关于ToolBar常见用法的梳理告一段落。源码请自取：https://github.com/wh1990xiao2005/JetpackDemo 我会在接下来的文章中，和大家分享关于ToolBar的剩余内容，以及AppCompat兼容包中的其他知识，希望对你我都有帮助。共勉！","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.xiaowenhan.com.cn/tags/Android/"}]},{"title":"抓出卡顿元凶，从分析掉帧开始","slug":"抓出卡顿元凶，从分析掉帧开始","date":"2019-02-25T02:23:48.000Z","updated":"2019-08-01T22:23:03.822Z","comments":true,"path":"2019/02/25/抓出卡顿元凶，从分析掉帧开始/","link":"","permalink":"http://www.xiaowenhan.com.cn/2019/02/25/抓出卡顿元凶，从分析掉帧开始/","excerpt":"","text":"这次我们依旧来谈谈有关性能优化的话题，这次我们会用到Google给我们提供的分析工具——Systrace。如果你还不了解这个工具，最好先了解一下。Google 官方文档：https://developer.android.com/studio/command-line/systrace我们还会用到一个Demo，用来对比卡顿和不卡顿的状况。 问题重现Demo运行起来会是这样的：流畅运行 模拟卡顿 这里解释一下，GIF动画表现得不是很完善，流畅运行的效果其实是每秒60帧，实际运行效果非常顺畅。模拟卡顿的效果在每秒60帧的基础上加了随机时长的线程sleep时间。具体实验代码片如下所示： 流畅运行的代码片 1234567891011121314151617181920212223threadRun = true;pbCurrent = 0;demoPb.setProgress(pbCurrent);new Thread(new Runnable() &#123; @Override public void run() &#123; while (threadRun) &#123; try &#123; Thread.sleep(1000 / 60); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (pbCurrent &gt; PB_MAX) &#123; pbCurrent = 0; &#125; else &#123; pbCurrent++; &#125; Message msg = new Message(); msg.what = UPDATE_HANDLER_KEY; mUiHandler.sendMessage(msg); &#125; &#125;&#125;).start(); 模拟卡顿的代码片 123456789101112131415161718192021222324thread2Run = true;pbCurrent = 0;demoPb.setProgress(pbCurrent);new Thread(new Runnable() &#123; @Override public void run() &#123; while (thread2Run) &#123; try &#123; Thread.sleep(1000 / 60); Thread.sleep(new Random().nextInt(200)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (pbCurrent &gt; PB_MAX) &#123; pbCurrent = 0; &#125; else &#123; pbCurrent++; &#125; Message msg = new Message(); msg.what = UPDATE_HANDLER_KEY; mUiHandler.sendMessage(msg); &#125; &#125;&#125;).start(); 更新UI部分代码片 123456789@Overridepublic void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what) &#123; case UPDATE_HANDLER_KEY: demoPb.setProgress(pbCurrent); break; &#125;&#125; 两个按钮分别对应上述两个线程的使能，另外请注意：我们只是模拟卡顿，并非真的发生了卡顿。因此，在Systrace的图表中，没有出现红色或橙色的告警。分别对上述两种情况取Systrace图表，得到如下结果： 流畅运行的图表模拟卡顿运行的图表通过对比，我们可以看到上面二者之间的差别。流畅运行的图表中，每一帧的绘制很均匀。差不多16.6ms一帧，也就是1000毫秒除以60帧，得到的16.6ms一帧。而模拟卡顿的图表中，每一帧的绘制则不均匀，有的长达将近200ms。但由于是我们自身模拟的结果，并非实际卡顿，所以图表中均为绿色的显示。下面我们来看一个真实的案例： 真实案例上图中，一帧本来应该是16ms完成的，然而却花费了近60ms，用1000ms/60ms，我们得到近似16帧。而16帧的帧率已经是肉眼可见的卡顿了。 揪出凶手我们聚焦到上面真实的案例，放大看发生卡顿的位置：我们发现，Record View 的draw()方法花费了一些时间。此外，还有一堆琐碎的小片段，我们进一步放大观察，会发现：这里居然还加载了一堆贴图。至此，我们就抓到了导致掉帧的“元凶”，下一步就是结合源代码进行优化了。 一些疑问和技巧为什么16ms一帧？16ms是1000ms/60帧得到的结果，60帧对于人眼而言已经是很流畅的体验了。而最低的限度是33ms一帧，也就是1000ms/30帧得到的结果。如果时间再长一点的话，就有可能发生人眼可见的卡顿了。延伸一点，也就是说，如果严格要求60帧，但是中间掉了1帧，就相当于33ms画一帧，此时，虽然掉帧，但是人眼还是可接受的。 如何快速定位卡顿位置首先是确保发生了卡顿。一般而言，没有发生卡顿的图表，网页的图表会是绿色的，发生卡顿的则是红色的。然后我们使用键盘+鼠标的组合来找位置，键盘的快捷键对应W、S、A、D。AD相当于拖拽时间滑块，WS相当于缩放。最后我们用鼠标来选取相应的时间范围即可。 今天的分享到此，希望对你有帮助。","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.xiaowenhan.com.cn/tags/Android/"}]},{"title":"粮草先行——Android折叠屏开发技术点（二）","slug":"粮草先行——Android折叠屏开发技术点（二）","date":"2019-02-20T09:56:10.000Z","updated":"2019-08-01T22:23:03.827Z","comments":true,"path":"2019/02/20/粮草先行——Android折叠屏开发技术点（二）/","link":"","permalink":"http://www.xiaowenhan.com.cn/2019/02/20/粮草先行——Android折叠屏开发技术点（二）/","excerpt":"","text":"继该系列的第一篇和番外篇之后，今天我们来聊一聊多窗口开发的注意事项。实际上，与其说“多窗口开发”，不如说让我们的APP适应多窗口模式。可能有朋友会问，为什么要提到多窗口模式呢？这是因为： 折叠屏在展开后的屏幕会变大，而变大带来的变化就是多窗口运行； 多窗口模式在很早之前就已经被Google官方支持，提供了相应的API，现在也到了该了解一下的时候了； 避免我们辛辛苦苦开发好的APP，翻车在多窗口的沟里； 虽然在Android Q中，多窗口模式很可能将成为默认行为，但要兼容之前的版本，我们仍然需要做一些事情。 首先我们来看一下如果我们什么都不做，切换多窗口时，会发生什么呢？仍然从生命周期的角度来解读： 失去焦点（未做兼容处理） D/MainActivity: onPause 重新获得焦点（未做兼容处理） D/MainActivity: onResume 注意，在默认情况下，一旦失去焦点，会回调onPause()方法。而此时Activity仍然可以被用户看到，因此，如果我们在onPause()里面做了一些不合适的操作，比如来了一个手势解锁，或者特殊情况下直接关闭程序，就明显不合适了。为了避免这种情况出现，我们希望在失去焦点的时候不回调onPause()。那么，我们只需在AndroidManifest.xml的application节点下添加如下代码，即可规避该问题： 123&lt;meta-data android:name=&quot;android.allow_multiple_resumed_activities&quot; android:value=&quot;true&quot;/&gt; 再次测试时，我们发现onPause()已经不会被回调了。到这里，我们有这样一个疑问：我们失去onPause()作为得到/失去焦点的判定依据，我们用什么来得知状态呢？很简单——借助onWindowFocusChanged()回调，即可及时获取焦点状态了。使用如下代码片进行测试： 12345@Overridepublic void onWindowFocusChanged(boolean hasFocus) &#123; super.onWindowFocusChanged(hasFocus); Log.d(TAG, &quot;onWindowFocusChanged - &quot; + hasFocus);&#125; 使APP反复得到/失去焦点，观察Logcat输出，得到如下结果： D/MainActivity: onWindowFocusChanged - falseD/MainActivity: onWindowFocusChanged - trueD/MainActivity: onWindowFocusChanged - falseD/MainActivity: onWindowFocusChanged - true…… 至此，问题解决。然而，你可能还会问：如果小窗口的尺寸发生变化如何处理？这并不困难，通过调整APP窗口大小，再次观察Logcat输出，发现onConfigurationChanged()方法被回调了。还记得我们之前提过的改变窗口大小吗？这就是一个实际的例子。该如何处理，大家心中应该有数了吧。今天的分享就到这里，希望上面的内容能够对你有帮助。","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.xiaowenhan.com.cn/tags/Android/"}]},{"title":"粮草先行——Android折叠屏开发技术点番外篇之运行时变更处理原则","slug":"粮草先行——Android折叠屏开发技术点番外篇之运行时变更处理原则","date":"2019-02-14T03:33:28.000Z","updated":"2019-08-01T22:23:03.827Z","comments":true,"path":"2019/02/14/粮草先行——Android折叠屏开发技术点番外篇之运行时变更处理原则/","link":"","permalink":"http://www.xiaowenhan.com.cn/2019/02/14/粮草先行——Android折叠屏开发技术点番外篇之运行时变更处理原则/","excerpt":"","text":"上一篇文章中，我们有提到Activity在屏幕尺寸发生变更时的处理方式，总共有两种： 重启APP以适应屏幕改变； 手动处理数据，避免APP重启。 同样，这两种方式也同时适用于改变屏幕方向、更改系统语言、甚至输入法等等。因此，本文也同样适用于改变屏幕方向等情况的处理。或许你会有疑问：我们该如何选择合适的处理方式呢？我给你的答案是：选择最合适的。这么说好像跟没说一样，别急，给大家举个例子就明白了：比如更改屏幕方向，由竖屏转换为横屏，如果我们只有一套布局，符合按比例缩放仍然显示正常的话，我们大可以选择第2种处理方案。但是如果我们的横竖屏布局是不同的，比如系统中的“设置”应用，那么我们选择第2种处理方案就是不合适的。下图：这是一个典型的横竖屏分别采用不同布局的例子。我们确定要采取那种解决方案后，接下来很可能要面对另一个问题，就是性能瓶颈。根据前一篇文章的实验结果，在发生横竖屏切换的时候，Activity的生命周期通常会按照如下顺序依次执行： D/MainActivity: onPauseD/MainActivity: onSaveInstanceStateD/MainActivity: onStopD/MainActivity: onDestroyD/MainActivity: onCreateD/MainActivity: onStartD/MainActivity: onRestoreInstanceStateD/MainActivity: onResume 如果我们在生命周期中做了一些繁重的工作，那么整个Activity在重启的过程中就会很慢。要解决这个问题，首先我们要找Fragment帮忙，因为Bundle并不是用来传递大型对象的，而且这个对象还需要序列化和反序列化，如此执行起来就更慢了。当然，如果你只是保存一些整型或者字符串的话，单纯使用Bundle而不借助Fragment也是可以的，但是这样的场景在实际开发中并不常见。要借助Fragment来中转对象，我们采用下面三步走的方式： 在Fragment类中调用 setRetainInstance(true)； 在Activity销毁时向Fragment类存入数据； 在Activity重建后根据Tag检索Fragment，并取出之前存入的数据。 下面用具体的代码片来演示：首先来看Fragment类： 123456789101112131415161718public class TestFragment extends Fragment &#123; private MyData data; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setRetainInstance(true); &#125; public void setData(MyData data) &#123; this.data = data; &#125; public MyData getData() &#123; return data; &#125;&#125; 我们再来看Activity类： 123456789101112131415161718192021222324public class MyActivity extends Activity &#123; private TestFragment mTestFragment ; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); FragmentManager fm = getFragmentManager(); mTestFragment = (TestFragment)fm.findFragmentByTag(“test”); if (retainedFragment == null) &#123; mTestFragment = new TestFragment (); fm.beginTransaction().add(mTestFragment, “test”).commit(); mTestFragment.setData(restoreData()); &#125; &#125; @Override public void onDestroy() &#123; super.onDestroy(); mTestFragment.setData(saveData()); &#125;&#125; 这里还要特别注意一点：在中转对象数据时，不要传入与Activity紧密相关的对象，比如View，否则会造成内存泄漏。至此，就完成了对重启Activity方案的性能优化。","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.xiaowenhan.com.cn/tags/Android/"}]},{"title":"粮草先行——Android折叠屏开发技术点（一）","slug":"粮草先行——Android折叠屏开发技术点（一）","date":"2019-01-30T06:58:37.000Z","updated":"2019-08-01T22:23:03.827Z","comments":true,"path":"2019/01/30/粮草先行——Android折叠屏开发技术点（一）/","link":"","permalink":"http://www.xiaowenhan.com.cn/2019/01/30/粮草先行——Android折叠屏开发技术点（一）/","excerpt":"","text":"最近有关折叠屏产品的新闻层出不穷，各家手机厂商也分别慢慢地亮出了自家的产品。然而市场上的一些APP仍然没有很好地适配这样的设备，显示不正常和应用重启的状况时有发生。因此，我会用接下来的几篇文章来点出有关折叠屏开发中的一些需要注意的地方。今天我们先来说一下生命周期，这是广大开发者特别需要注意的一点。首先我们来看一下测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class MainActivity extends AppCompatActivity &#123; private final String TAG = &quot;MainActivity&quot;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.d(TAG, &quot;onCreate&quot;); &#125; @Override protected void onStart() &#123; super.onStart(); Log.d(TAG, &quot;onStart&quot;); &#125; @Override protected void onResume() &#123; super.onResume(); Log.d(TAG, &quot;onResume&quot;); &#125; @Override protected void onPause() &#123; super.onPause(); Log.d(TAG, &quot;onPause&quot;); &#125; @Override protected void onStop() &#123; super.onStop(); Log.d(TAG, &quot;onStop&quot;); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); Log.d(TAG, &quot;onDestroy&quot;); &#125; @Override protected void onRestart() &#123; super.onRestart(); Log.d(TAG, &quot;onRestart&quot;); &#125; @Override protected void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); Log.d(TAG, &quot;onSaveInstanceState&quot;); &#125; @Override protected void onRestoreInstanceState(Bundle savedInstanceState) &#123; super.onRestoreInstanceState(savedInstanceState); Log.d(TAG, &quot;onRestoreInstanceState&quot;); &#125; @Override public void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig); Log.d(TAG, &quot;onConfigurationChanged&quot;); &#125;&#125; 我在每一个生命周期和恢复现场的回调方法中都加了Logcat输出，我们来看一下切换屏幕时APP的具体表现。 2019-01-30 11:19:00.216 30205-30205/com.example.helloworld D/MainActivity: onPause2019-01-30 11:19:00.221 30205-30205/com.example.helloworld D/MainActivity: onSaveInstanceState2019-01-30 11:19:00.227 30205-30205/com.example.helloworld D/MainActivity: onStop2019-01-30 11:19:00.228 30205-30205/com.example.helloworld D/MainActivity: onDestroy2019-01-30 11:19:00.325 30205-30205/com.example.helloworld D/MainActivity: onCreate2019-01-30 11:19:00.326 30205-30205/com.example.helloworld D/MainActivity: hashcode is 896429802019-01-30 11:19:00.327 30205-30205/com.example.helloworld D/MainActivity: onStart2019-01-30 11:19:00.328 30205-30205/com.example.helloworld D/MainActivity: onRestoreInstanceState2019-01-30 11:19:00.331 30205-30205/com.example.helloworld D/MainActivity: onResume 我们可以看到，默认情形下，Activity在屏幕尺寸发生改变的时候也随之重启了。 和改变屏幕Orientation的行为有几分相像。此时我们面临两个选择： 重启APP以适应屏幕改变； 手动处理数据，避免APP重启。 对于第一种情况，我们一般在回调onSaveInstanceState()方法中保存数据，并在onCreate()或onRestoreInstanceState()回调方法中取回保存的数据用于恢复现场。然而，并非在所有情况下都需要完整地重启APP来适应屏幕改变，和改变屏幕方向一样，我们只需要在Androidmanifest.xml中相应的Activity声明中加入相应的属性值即可。此处，需要添加： 1android:configChanges=&quot;screenSize|smallestScreenSize|screenLayout&quot; 添加好之后再次运行APP并反复改变屏幕大小，此时的生命周期回调顺序变为： 2019-01-30 11:13:02.217 29276-29276/com.example.helloworld D/MainActivity: onCreate2019-01-30 11:13:02.219 29276-29276/com.example.helloworld D/MainActivity: onStart2019-01-30 11:13:02.223 29276-29276/com.example.helloworld D/MainActivity: onResume2019-01-30 11:13:05.289 29276-29276/com.example.helloworld D/MainActivity: onConfigurationChanged 可见，此时Activity并没有销毁重建，而是只回调了onConfigurationChanged()方法。在某些情况下，可用此办法避免APP重启。那么，上述三个属性值各代表什么意思呢，详见下表： 属性值 含义 screenSize 当前可用屏幕尺寸发生了变化。它表示当前可用尺寸相对于当前纵横比的变化，因此会在用户在横向与纵向之间切换时发生变化。 不过，如果您的应用面向 API 级别 12 或更低级别，则 Activity 始终会自行处理此配置变更（即便是在 Android 3.2 或更高版本的设备上运行，此配置变更也不会重新启动 Activity）。 smallestScreenSize 物理屏幕尺寸发生了变化。它表示与方向无关的尺寸变化，因此只有在实际物理屏幕尺寸发生变化（如切换到外部显示器）时才会变化。 对此配置的变更对应于smallestWidth 配置的变化。 不过，如果您的应用面向 API 级别 12 或更低级别，则 Activity 始终会自行处理此配置变更（即便是在 Android 3.2 或更高版本的设备上运行，此配置变更也不会重新启动 Activity）。 screenLayout 屏幕布局发生了变化 — 这可能是由激活了其他显示方式所致。 注：上表摘自 https://developer.android.com/guide/topics/manifest/activity-element 如此，我们便处理完了对于折叠屏切换屏幕的优化。","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.xiaowenhan.com.cn/tags/Android/"}]},{"title":"博客园 开博寄语","slug":"博客园 开博寄语","date":"2019-01-29T13:42:00.000Z","updated":"2019-08-27T13:30:56.408Z","comments":true,"path":"2019/01/29/博客园 开博寄语/","link":"","permalink":"http://www.xiaowenhan.com.cn/2019/01/29/博客园 开博寄语/","excerpt":"","text":"感谢我的父亲、母亲、妻子、同事和朋友们，是你们让我能够有精力全情投入到工作和学习中，感谢你们为我做过的一切事！依稀记得不到5年前在CSDN写下上面这第一篇文字时的场景和感受，那个时候的我在软件开发领域还是一个懵懵懂懂的新人。其实在浩瀚的知识和未来面前，我们始终都是“新人”。这5年期间，我经历了从软件开发工程师到测试工程师的转变。如果说这5年给我留下了什么，或是说让我学到了什么。从博客的内容上看，回顾了这5年来发表过的文章，真正放到今天仍旧有帮助的只有5篇。剩下的要么就是因为技术过时而失去作用，要么就是有更好的解决方案，又或者就是有错误。为什么今天再次转移战场呢，是觉得博客园是个更加纯粹的地方，和CSDN相比，它更少广告，界面也更朴素，甚至有一点怀旧的感觉。但是也正因为如此，它也能给我一种更加专注的体验，让我更加专注于技术本身，而不是那些花里胡哨的界面风格。在博客园写文章，对我而言是一个既新又旧的事情。“新”是因为全新的平台、全新的内容，“旧”是因为写作风格不会变、坚持的东西不会变。之前在CSDN和简书上发文章，基本都会发那些网上搜不到的，或者是新出的技术，国内还没有翻译更新出来的内容。通过这些内容，成功获得了CSDN认证讲师和博客专家的成就。然而，在获得了这些之后，写作的动力就下降了，或者有时候觉得没什么可写的。有几次想把自己遇到的问题总结归纳一下分享出来，结果网上一搜，已经有人写过了，又由于我自己的那份坚持——坚决不重复别人的成果，最终也导致了没什么文章产出。2018年对我而言是事业生活双丰收的一年，2017年10月换了工作，成功地从开发工程师转向测试岗位，成为三星通信研究院大家庭中的一员。在这一年的工作中，从未离开过代码。从过去的实现功能到如今的优化性能，在我眼里是一种提升。我始终抱有一个目标，就是利用技术的进步驱动生活的有利改变，同时，将其中公开化。除了这些，对于那些刚刚入门的“初学者”，总觉得自己有种使命感，就是要帮助他们快速提升技术水平。我想，这和我自幼的理想是分不开的。我曾经在独处的时光里写过这样一段话： “在编程这条不归路上，即使面对的是没有生命的机器，即使它能任由编程人员指挥做事情。但到头来，还是会让开发人员面临很多挑战。意想不到的崩溃和各种稀奇古怪的异常，会让开发人员忙得焦头烂额，甚至到最后仍然深陷泥潭。但正因为如此，编程可以锻炼人的耐性，培养人的耐心和细心的习惯。也正因为这样，才能让人踏实下来写一些东西。更是因为这样，我才能胜任这项工作。说到“世俗”的一面，我的理想就是提高自己的知名度，让自己在这个世界上留下些许存在过的印记。它或许是一篇文章，或许是一段代码片，或许是一张照片，甚至只存在于某个人或某几个人的记忆中。这和我少年时期想要当一名老师的理想并不冲突。经过成长的洗礼，最初的梦想经过升华变作了某种执念和精神，又化作了条条通往理想之门的大路。我逐渐意识到，自己少年时期的梦想只是一种具象化的结果。在每一次静静的思索之后，在每一次深深的解剖自己之后，慢慢地，知道了自己真正想要的东西；逐渐地，找到了实现它们的途径。能够意识到这些并将其转化为行动，对我而言，已经是莫大的欣喜。” 在三星通信研究院工作，对我而言是一件幸福的事情。在这里工作强度不是一直都很大，有时间自我学习。我始终认为，在人生的现阶段，投资自己是最重要的，而不是每个月到底能挣几个钱，因为发财没办法靠打工。即使年薪30万，50万又能如何呢？不吃不喝，一年下来，也不能在一线城市买下一套房，也不能买下自己心爱的座驾。更何况，即使买的下来这些，也不能保证自己不去要更多的东西，那样的人生不是我想要的。或许那样真的可以让自己这一生过得很舒服，但是舒服过后依旧会归于尘土。但如果我们真的可以在人间留下来点什么，留在了某些人的记忆中，这意味着这些人将带着我们的精神，带着我们的经验活下去，甚至传承下去。在某种意义上讲，这将是一种永生。写博客对我而言就是实现理想的一种方式，我希望通过文字和图片记录下我在编程路上踩过的各种“坑”和探过的各种路。这对于尚未遇到“坑”和打算走新路的朋友来说，多少都会有一些帮助。虽然到今天，我仍然没有当上老师，没能站上讲台，但只要能够起到帮助和引导的作用，做事情的形式还显得那么重要吗？这里我要感谢我的父母，感谢他们多年来的栽培，正因为有他们才有了今天的我。也感谢他们能够放手让我独立地生活，去距离他们2000公里以外的城市生活。还要感谢我的妻子，生活上她照顾得无微不至，把家里打理得井井有条，让我心无旁骛地追寻理想。最后要感谢陪我走过这5年的同事们，在工作中我们互相合作，互相学习，让我学到了很多东西。另外，还要感谢耐心阅读完本文的你。","categories":[{"name":"聊聊人生","slug":"聊聊人生","permalink":"http://www.xiaowenhan.com.cn/categories/聊聊人生/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://www.xiaowenhan.com.cn/tags/其他/"}]},{"title":"巧用Handler获取View控件信息","slug":"巧用Handler获取View控件信息","date":"2019-01-14T15:12:09.000Z","updated":"2019-08-01T22:23:03.818Z","comments":true,"path":"2019/01/14/巧用Handler获取View控件信息/","link":"","permalink":"http://www.xiaowenhan.com.cn/2019/01/14/巧用Handler获取View控件信息/","excerpt":"","text":"众所周知，在Android实际开发中，对于某些复杂多变的情况，控件的位置摆放、大小控制并非是xml类型的layout文件完全可以搞定的。此时，我们通常会使用Java代码来通过动态计算，将指定的控件摆放在相应的位置，并限定其大小。同样地，也需要获取某个控件的大小。对于获取控件宽、高的方法，大家可以自行谷歌或者百度，大抵无非一下三种方法： 给相应的View控件添加ViewTreeObserver回调； Override onWindowFocusChange方法； 在需要测量时（而不是onCreate或onResume中），使用MeasureSpec内部类获取宽高。 对于上述第三种情况，我们暂且不论。对于前二者而言，有没有更简单的实现呢？ 为何获取宽高要如此？对于初学者，可能会有这样的疑问：为什么我们不能在onCreate()或者onResume()中直接使用上述第三种方案获取宽高呢？结论是：那样的话，获取来的值很可能皆为0，即使实际的宽高不是0。那么这是为何呢？这其实是由Android的UI绘制流程决定的。大家不妨试着做一下实验，即使是在onResume()方法后，它的意义也仅仅是指Activity进入了可见的状态，这并不意味着界面绘制的结束。我们可以用一个简单的带有宽高值得View来做实验，观察Activity中各回调方法的调用顺序，得到的结果将是这样的： Activity.oncreate() → Activity.onResume() → View.onMeasure() → View.onLayout() → onGlobalLayoutListener() → Activity.onWidnowFocusChanged() → … → View.onDraw() -&gt; … 因此，如果我们在onResume()中尝试获取View宽高的话，很大概率是会失败的。 巧用Handler获取View控件信息这里我们开门见山地先放上代码片： 123456789101112private int[] measureView(final View view) &#123; final int[] returnData = new int[2]; view.post(new Runnable() &#123; @Override public void run() &#123; returnData[0] = view.getWidth(); returnData[1] = view.getHeight(); Log.i(TAG, &quot;Width: &quot; + returnData[0] + &quot;, height: &quot; + returnData[1]); &#125; &#125;); return returnData;&#125; 上述代码作为通用的方法将获取任意View的宽高做了封装，其妙处就在‘view.post’处。将其置于onCreate()、onResume()方法中调用，均可获取到正确的宽高。 123456789101112131415@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.i(TAG, &quot;onCreate start!&quot;); setContentView(R.layout.activity_main); testTv = (TextView) findViewById(R.id.testTv); measureView(testTv);&#125;@Overrideprotected void onResume() &#123; super.onResume(); Log.i(TAG, &quot;onResume start!&quot;); measureView(testTv);&#125; Logcat中的运行结果： 2019-01-14 22:33:13.874 18355-18355/com.example.wenhan.helloandroid I/MainActivity: Width: 225, height: 572019-01-14 22:33:13.874 18355-18355/com.example.wenhan.helloandroid I/MainActivity: Width: 225, height: 57 为何如此就可获取到正确的值了呢？其中的玄机在于，我们在View.post()中所写的语句并没有立即执行，而在其真正执行的时候，View的宽高已经被测量完成了，那时我们再去获取宽高时，就会很容易地获取到正确的值了。通过断点Debug，可以轻松地发现，在Activity启动过程的调用栈中，存在ActivityThread类被执行了，具体按照： main() -&gt; handleResumeActivity() -&gt; addView() -&gt; setView() -&gt; requestLayout() -&gt; scheduleTraversals() -&gt; 执行mTraversalRunnable异步线程 -&gt; doTraversal() -&gt; performTraversals() -&gt; … -&gt; performMeasure() -&gt; … 的执行顺序。在我们获取宽高的语句执行前，主线程的Handler正在执行TraversalRunnable（见上述方法具体实现），而performMeasure也被包含其中。又因为我们获取宽高的语句要排队，处于等待状态，直到主线程Handler轮到执行我们的语句，而此时View的宽高的测量已经结束。 完整示例代码：https://github.com/wh1990xiao2005/FetchViewSizeDemo","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.xiaowenhan.com.cn/tags/Android/"}]},{"title":"优化Activity启动速度的另类解法","slug":"优化Activity启动速度的另类解法","date":"2018-07-29T04:48:45.000Z","updated":"2019-08-01T22:23:03.816Z","comments":true,"path":"2018/07/29/优化Activity启动速度的另类解法/","link":"","permalink":"http://www.xiaowenhan.com.cn/2018/07/29/优化Activity启动速度的另类解法/","excerpt":"","text":"今天来给大家分享一个性能优化的经验，主要在Activity启动方面。众所周知，给用户即时的响应是增强移动设备用户体验的重要一环，而Activity在启动过程中，又会经历至少onCreate(), onStart(), onResume()这三个回调过程。而在这三个过程中，又会经历绘制界面、载入数据、恢复现场等等实际操作。这对于一个Activity的启动多少都是会产生影响的。通常意义上讲，我们去优化Activity的启动速度都是在上述三个回调中下工夫，觉得只要上述操作优化得足够好，就可以有一个良好的体验。包括我们在百度上面去搜索提升Activity启动速度也是如此。 完整代码请见 完整代码 接下来我们来看这个问题的另一个方面。下面先看一个动画： 我们可以注意到，在点击了”Launch SecondActivity”后，界面卡住了几秒，才发生跳转。而SecondActivity本身什么都没有做，如下所示： 1234567891011121314151617181920212223public class SecondActivity extends Activity &#123; private final String TAG = getClass().getSimpleName(); @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); Log.d(TAG, &quot;onCreate end&quot;); &#125; @Override protected void onStart() &#123; super.onStart(); Log.d(TAG, &quot;onStart end&quot;); &#125; @Override protected void onResume() &#123; super.onResume(); Log.d(TAG, &quot;onResume end&quot;); &#125;&#125; 这是一个很极端的情况，在启动过程中的各个生命周期，都只做了输出Log的操作，但仍然发生了卡顿的情况。我们看在启动它的Activity中，我们做了什么： 12345678910111213141516@Overrideprotected void onPause() &#123; super.onPause(); sleep();&#125;// Sleep 5000 ms in main thread.private void sleep() &#123; if (needSleep) &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 在onPause()方法中，我们做了一个5000ms的主线程延迟，用来模拟大量的主线程操作，我们发现，一旦在onPause中工作量太大，也会导致接下来启动的Activity启动延迟。这也解释了为什么我们反复优化即将启动的Activity，却收效不大的原因。而一旦onPause()方法中，不进行操作时，或者实际项目中操作不多时，接下来的Activity会启动得很快，参考下面的演示： 希望通过上面的描述，能给各位读者提供另一个性能优化的方案。Demo APK 和源码下载：https://github.com/wh1990xiao2005/pfmStartActivity/releases/tag/1.0","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.xiaowenhan.com.cn/tags/Android/"}]},{"title":"再见厦门","slug":"再见厦门","date":"2018-04-29T06:41:00.000Z","updated":"2019-08-28T00:27:38.013Z","comments":true,"path":"2018/04/29/再见厦门/","link":"","permalink":"http://www.xiaowenhan.com.cn/2018/04/29/再见厦门/","excerpt":"","text":"","categories":[{"name":"摄影作品","slug":"摄影作品","permalink":"http://www.xiaowenhan.com.cn/categories/摄影作品/"}],"tags":[{"name":"观世界","slug":"观世界","permalink":"http://www.xiaowenhan.com.cn/tags/观世界/"}]},{"title":"永定土楼","slug":"永定土楼","date":"2018-04-28T06:22:00.000Z","updated":"2019-08-28T00:27:38.018Z","comments":true,"path":"2018/04/28/永定土楼/","link":"","permalink":"http://www.xiaowenhan.com.cn/2018/04/28/永定土楼/","excerpt":"","text":"","categories":[{"name":"摄影作品","slug":"摄影作品","permalink":"http://www.xiaowenhan.com.cn/categories/摄影作品/"}],"tags":[{"name":"观世界","slug":"观世界","permalink":"http://www.xiaowenhan.com.cn/tags/观世界/"}]},{"title":"厦大和南普陀寺","slug":"厦大和南普陀寺","date":"2018-04-27T02:00:00.000Z","updated":"2019-08-28T00:27:38.013Z","comments":true,"path":"2018/04/27/厦大和南普陀寺/","link":"","permalink":"http://www.xiaowenhan.com.cn/2018/04/27/厦大和南普陀寺/","excerpt":"","text":"","categories":[{"name":"摄影作品","slug":"摄影作品","permalink":"http://www.xiaowenhan.com.cn/categories/摄影作品/"}],"tags":[{"name":"观世界","slug":"观世界","permalink":"http://www.xiaowenhan.com.cn/tags/观世界/"}]},{"title":"厦门鼓浪屿","slug":"厦门鼓浪屿","date":"2018-04-26T01:09:00.000Z","updated":"2019-08-28T00:27:38.014Z","comments":true,"path":"2018/04/26/厦门鼓浪屿/","link":"","permalink":"http://www.xiaowenhan.com.cn/2018/04/26/厦门鼓浪屿/","excerpt":"","text":"","categories":[{"name":"摄影作品","slug":"摄影作品","permalink":"http://www.xiaowenhan.com.cn/categories/摄影作品/"}],"tags":[{"name":"观世界","slug":"观世界","permalink":"http://www.xiaowenhan.com.cn/tags/观世界/"}]},{"title":"厦门街拍","slug":"厦门街拍","date":"2018-04-25T08:31:00.000Z","updated":"2019-08-28T00:27:38.014Z","comments":true,"path":"2018/04/25/厦门街拍/","link":"","permalink":"http://www.xiaowenhan.com.cn/2018/04/25/厦门街拍/","excerpt":"","text":"","categories":[{"name":"摄影作品","slug":"摄影作品","permalink":"http://www.xiaowenhan.com.cn/categories/摄影作品/"}],"tags":[{"name":"观世界","slug":"观世界","permalink":"http://www.xiaowenhan.com.cn/tags/观世界/"}]},{"title":"春天的气息","slug":"春天的气息","date":"2018-03-25T06:54:00.000Z","updated":"2019-08-28T00:27:38.017Z","comments":true,"path":"2018/03/25/春天的气息/","link":"","permalink":"http://www.xiaowenhan.com.cn/2018/03/25/春天的气息/","excerpt":"","text":"","categories":[{"name":"摄影作品","slug":"摄影作品","permalink":"http://www.xiaowenhan.com.cn/categories/摄影作品/"}],"tags":[{"name":"随手拍","slug":"随手拍","permalink":"http://www.xiaowenhan.com.cn/tags/随手拍/"}]},{"title":"夜游广州","slug":"夜游广州","date":"2018-02-26T12:37:00.000Z","updated":"2019-08-28T00:27:38.015Z","comments":true,"path":"2018/02/26/夜游广州/","link":"","permalink":"http://www.xiaowenhan.com.cn/2018/02/26/夜游广州/","excerpt":"","text":"","categories":[{"name":"摄影作品","slug":"摄影作品","permalink":"http://www.xiaowenhan.com.cn/categories/摄影作品/"}],"tags":[{"name":"随手拍","slug":"随手拍","permalink":"http://www.xiaowenhan.com.cn/tags/随手拍/"}]},{"title":"乌木纹理","slug":"乌木纹理","date":"2017-10-06T04:33:00.000Z","updated":"2019-08-28T00:27:38.011Z","comments":true,"path":"2017/10/06/乌木纹理/","link":"","permalink":"http://www.xiaowenhan.com.cn/2017/10/06/乌木纹理/","excerpt":"","text":"","categories":[{"name":"摄影作品","slug":"摄影作品","permalink":"http://www.xiaowenhan.com.cn/categories/摄影作品/"}],"tags":[{"name":"观世界","slug":"观世界","permalink":"http://www.xiaowenhan.com.cn/tags/观世界/"}]},{"title":"青城山 登顶","slug":"青城山 登顶","date":"2017-10-05T07:12:00.000Z","updated":"2019-08-28T00:27:38.022Z","comments":true,"path":"2017/10/05/青城山 登顶/","link":"","permalink":"http://www.xiaowenhan.com.cn/2017/10/05/青城山 登顶/","excerpt":"","text":"","categories":[{"name":"摄影作品","slug":"摄影作品","permalink":"http://www.xiaowenhan.com.cn/categories/摄影作品/"}],"tags":[{"name":"随手拍","slug":"随手拍","permalink":"http://www.xiaowenhan.com.cn/tags/随手拍/"}]},{"title":"都江堰","slug":"都江堰","date":"2017-10-05T00:33:00.000Z","updated":"2019-08-28T00:27:38.021Z","comments":true,"path":"2017/10/05/都江堰/","link":"","permalink":"http://www.xiaowenhan.com.cn/2017/10/05/都江堰/","excerpt":"","text":"","categories":[{"name":"摄影作品","slug":"摄影作品","permalink":"http://www.xiaowenhan.com.cn/categories/摄影作品/"}],"tags":[{"name":"随手拍","slug":"随手拍","permalink":"http://www.xiaowenhan.com.cn/tags/随手拍/"}]},{"title":"成都街拍","slug":"成都街拍","date":"2017-10-03T11:54:00.000Z","updated":"2019-08-28T00:27:38.015Z","comments":true,"path":"2017/10/03/成都街拍/","link":"","permalink":"http://www.xiaowenhan.com.cn/2017/10/03/成都街拍/","excerpt":"","text":"","categories":[{"name":"摄影作品","slug":"摄影作品","permalink":"http://www.xiaowenhan.com.cn/categories/摄影作品/"}],"tags":[{"name":"随手拍","slug":"随手拍","permalink":"http://www.xiaowenhan.com.cn/tags/随手拍/"}]},{"title":"新天大•南大","slug":"新天大•南大","date":"2017-07-29T11:16:00.000Z","updated":"2019-08-28T00:27:38.016Z","comments":true,"path":"2017/07/29/新天大•南大/","link":"","permalink":"http://www.xiaowenhan.com.cn/2017/07/29/新天大•南大/","excerpt":"","text":"","categories":[{"name":"摄影作品","slug":"摄影作品","permalink":"http://www.xiaowenhan.com.cn/categories/摄影作品/"}],"tags":[{"name":"观世界","slug":"观世界","permalink":"http://www.xiaowenhan.com.cn/tags/观世界/"}]},{"title":"绿博园","slug":"绿博园","date":"2017-04-30T03:13:00.000Z","updated":"2019-08-28T00:27:38.020Z","comments":true,"path":"2017/04/30/绿博园/","link":"","permalink":"http://www.xiaowenhan.com.cn/2017/04/30/绿博园/","excerpt":"","text":"","categories":[{"name":"摄影作品","slug":"摄影作品","permalink":"http://www.xiaowenhan.com.cn/categories/摄影作品/"}],"tags":[{"name":"观世界","slug":"观世界","permalink":"http://www.xiaowenhan.com.cn/tags/观世界/"}]},{"title":"Android平台下使用ormLite的一个小Tip","slug":"Android平台下使用ormLite的一个小Tip","date":"2017-04-06T02:19:10.000Z","updated":"2019-08-01T22:23:03.813Z","comments":true,"path":"2017/04/06/Android平台下使用ormLite的一个小Tip/","link":"","permalink":"http://www.xiaowenhan.com.cn/2017/04/06/Android平台下使用ormLite的一个小Tip/","excerpt":"","text":"相信不少人在实际开发中使用一些框架，在数据库这方面，有一些成熟的框架。比如greenDao，ormLite之类。最近我在实际开发中，使用了ormLite。使用方法就不在赘述了，这个诸位去谷歌、百度一下就可发现，或者去官网也可。这里给大家一个小提醒，在使用ormLite进行数据库存取访问时，dao类尽量使用单例。我之前的写法如下： 12345678910public AvatarStoreDao(Context context) &#123; this.context = context; try &#123; dbHelper = DatabaseHelper .getHelper(context, number, true); avatarStoresDao = dbHelper.getDao(AvatarStore.class); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 这种写法会在每次使用前都new一个新的AvatarStoreDao对象，因此上面的构造方法也会跟着跑一次。当数据访问过于频繁的时候，某些机器容易被卡黑屏。解决方法如下： 12345678910111213141516public AvatarStoreDao(Context context, String number) &#123; this.context = context; try &#123; dbHelper = DatabaseHelper.getHelper(context, number, true); avatarStoresDao = dbHelper.getDao(AvatarStore.class); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;public static AvatarStoreDao getInstance(Context context, String number) &#123; if (instance == null) &#123; instance = new AvatarStoreDao(context, number); &#125; return instance;&#125; 这样在使用前，需要调用getInstance方法，这样一来，仅当instance为null的时候才会走构造方法，可以提升一下使用的流畅性。","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.xiaowenhan.com.cn/tags/Android/"}]},{"title":"解决TextView引起的莫名崩溃","slug":"解决TextView引起的莫名崩溃","date":"2017-04-06T01:50:35.000Z","updated":"2019-08-01T22:23:03.829Z","comments":true,"path":"2017/04/06/解决TextView引起的莫名崩溃/","link":"","permalink":"http://www.xiaowenhan.com.cn/2017/04/06/解决TextView引起的莫名崩溃/","excerpt":"","text":"进了2017年之后到现在，我一直都在忙着做一款IM应用，功能和微信、QQ类似。在开发和测试的过程中，发现了几个可以总结记录的东西，今天和大家来分享其中之一。首先来看一个异常： java.lang.ArrayIndexOutOfBoundsException: length=125; index=-1 at android.text.StaticLayout.calculateEllipsis(StaticLayout.java:830) at android.text.StaticLayout.out(StaticLayout.java:749) at android.text.StaticLayout.generate(StaticLayout.java:453) at android.text.StaticLayout.&lt;init&gt;(StaticLayout.java:145) at android.widget.TextView.makeSingleLayout(TextView.java:6298) at android.widget.TextView.makeNewLayout(TextView.java:6144)乍看上去，倒是和我这边没什么关系，都是Android内部实现的问题。但是每到这个地方，都会崩溃，100%复现。这对于实际用户使用而言不是什么好事。于是Google，百度了一圈，发现了Android系统在某个版本中的“坑”。具体解决办法：之前xml布局中，对于TextView： 123456&lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:ellipsize=&quot;middle&quot; android:lines=&quot;1&quot; android:text=&quot;&quot;/&gt; 看上去没有问题，如果要解决上述崩溃问题，改为： 123456&lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:ellipsize=&quot;middle&quot; android:singleLine=&quot;true&quot; android:text=&quot;&quot;/&gt; 即可。这里参考了：Google Code 上述问题在Android 4.4版本上有所体现，其他的版本暂不确定。","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.xiaowenhan.com.cn/tags/Android/"}]},{"title":"又是一年春","slug":"又是一年春","date":"2017-04-01T04:23:00.000Z","updated":"2019-08-28T00:27:38.014Z","comments":true,"path":"2017/04/01/又是一年春/","link":"","permalink":"http://www.xiaowenhan.com.cn/2017/04/01/又是一年春/","excerpt":"","text":"","categories":[{"name":"摄影作品","slug":"摄影作品","permalink":"http://www.xiaowenhan.com.cn/categories/摄影作品/"}],"tags":[{"name":"随手拍","slug":"随手拍","permalink":"http://www.xiaowenhan.com.cn/tags/随手拍/"}]},{"title":"Mapbox 地图SDK极速集成指导","slug":"Mapbox 地图SDK极速集成指导","date":"2016-12-22T03:42:14.000Z","updated":"2019-08-01T22:23:03.814Z","comments":true,"path":"2016/12/22/Mapbox 地图SDK极速集成指导/","link":"","permalink":"http://www.xiaowenhan.com.cn/2016/12/22/Mapbox 地图SDK极速集成指导/","excerpt":"","text":"这次跟各位分享一个地图的SDK。先说说为什么拿Mapbox来用吧。首先就是——国际化。当需求要显示国外的地理位置信息的时候，通常使用的是Google Map。但是Google Map目前需要手机带有完整的Google Play套件才行，但是基本上所有的国内上市的手机都把Google Play套件阉割了。然后就是偏移量，从目前来看，Mapbox的路网和卫星照片是重合的，而Google Map则是有一定的偏移，尤其是在中国。最后呢，Mapbox的集成方式实在是太简单了。不过呢，说了这么多优点，再说一个缺点。就是Mapbox的卫星照片略慢，尤其是中国，某些地方还停留在几年前的样子，这个以年为单位，一点都不夸张。如果你需要做海外的地图定位，个人认为，Mapbox可作为首选。下面说一下具体的集成方法。首先，需要去官网注册一个账号，这里附上官网地址链接：https://www.mapbox.com/注册完成后，进入网页Studio界面，我们会轻松找到Access Token。我们后面会用到。然后新建一个Android项目，这里推荐targetAPI&lt;23，但是必须大于15。在app目录下的build.gradle文件中添加下面的内容，用来导入依赖库。 1234repositories&#123;mavenCentral()&#125;compile(&apos;com.mapbox.mapboxsdk:mapbox-android-sdk:4.2.0@aar&apos;) &#123; transitive = true&#125; 这里注意版本，虽然复制粘贴过去没有问题，但是依赖库的版本还在不断更新，也许下一秒就发布4.2.1或者其他什么版本，所以这个还是有必要直接去官网上看一下。网址在此：https://www.mapbox.com/android-sdk/下一步我们在布局文件中添加地图控件，很简单，最简易的写法可以像下面这样： 1234&lt;com.mapbox.mapboxsdk.maps.MapView android:id=&quot;@+id/mapview&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; /&gt; 当然，我们需要显示一个自己比较熟悉的位置，而且还要能够看得足够清晰，可以写成像下面这样： 12345678&lt;com.mapbox.mapboxsdk.maps.MapView android:id=&quot;@+id/mapview&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; mapbox:center_latitude=&quot;39.069&quot; mapbox:center_longitude=&quot;117.221&quot; mapbox:style_url=&quot;@string/style_satellite_streets&quot; mapbox:zoom=&quot;15&quot; /&gt; 这里提醒一下，在xml最上方加上命名空间，否则会报错： 1xmlns:mapbox=&quot;http://schemas.android.com/apk/res-auto&quot; 这样做，可以同时显示路网和卫星照片，虽然卫星照片可能比较过时，但是确实很清楚。而且可以稍微移动一下，看看国外的风景，情况就大不一样了。下一步需要在Activity中完成初始化等操作，在onCreate()方法中添加如下代码： 12345678910setContentView(R.layout.activity_main);MapboxAccountManager.start(this, getString(R.string.access_token));mv = (MapView) findViewById(R.id.mapview);mv.onCreate(savedInstanceState);mv.getMapAsync(new OnMapReadyCallback() &#123; @Override public void onMapReady(MapboxMap mapboxMap) &#123; &#125;&#125;); 当然，这只是个例子。这里要注意的就是必须在Activity中的各个生命周期中添加相应的方法，比如onResume()中，需要加上： 1mv.onResume(); 其他生命周期回调类似。最后在AndroidManifest.xml中做好相关权限声明： 1234&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; 还有一个Service： 1&lt;service android:name=&quot;com.mapbox.mapboxsdk.telemetry.TelemetryService&quot; /&gt; 该Service在Application节点内。好了，运行一下吧，一切顺利的话就可以看到地图的显示了。 下面附上完整的项目源码：https://github.com/XiaoWenHan/MapboxAndroidDemo","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.xiaowenhan.com.cn/tags/Android/"}]},{"title":"Android 6.0 运行时权限简明处理","slug":"Android 6.0 运行时权限简明处理","date":"2016-12-19T09:15:00.000Z","updated":"2019-08-01T22:23:03.812Z","comments":true,"path":"2016/12/19/Android 6.0 运行时权限简明处理/","link":"","permalink":"http://www.xiaowenhan.com.cn/2016/12/19/Android 6.0 运行时权限简明处理/","excerpt":"","text":"今天来跟大家聊这样一个话题——权限。正如各位所知，传统意义上的权限是在用户安装APP时被许可的。尽管在使用过程中，某些第三方Rom或者安全软件会再次提示权限，但从系统本身来说，就是被放行了。在Google推出6.0之后，引入了新的权限机制，叫做运行时权限（Runtime Permission）。该机制限制某些敏感的权限，比如读写外置存储，访问隐私数据等等。对用户的数据保护提供良好的保障，但同时也为开发者提供了一些绊脚石。那么作为一名开发者，应该如何做呢？首先就是端正心态，这样做确实是对用户有好处的。然后就是学习了，也就是本篇文章的正题。我们按照Android studio的新建项目向导建立新的空项目后，按照原先的方法在Androidmanifest.xml做权限声明，如下： 12&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt; 然后在Activity中尝试新建一个文件，如下： 1234567891011File newFile = new File(Environment.getExternalStorageDirectory() + File.separator + &quot;test.txt&quot;);if (newFile.exists() &amp;&amp; newFile.isFile()) &#123; newFile.delete();&#125;try &#123; newFile.createNewFile(); Toast.makeText(this, &quot;文件创建成功&quot;, Toast.LENGTH_SHORT).show();&#125; catch (IOException e) &#123; e.printStackTrace(); Toast.makeText(this, &quot;文件创建失败&quot;, Toast.LENGTH_SHORT).show();&#125; 然后运行，如果你的手机是基于Android 6.0，你就会发现，文件根本没有办法被创建。会报Permission denied 错误，意思就是权限禁止。解决的方法也很简单，分两步走，第一步先授权，第二步就是在授权响应的回调接口中获取到授权是否成功的值。授权的方法可参考如下代码片： 123456private void checkStoragePermission() &#123; if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; //未授权，请求授权 ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, REQ_PERMISSION_STORAGE); &#125;&#125; 此处有检查，如果未经授权，则去授权。授权响应回调中的处理可参考如下代码片： if (requestCode == REQ_PERMISSION_STORAGE) { if (grantResults[0] == PackageManager.PERMISSION_GRANTED) { Toast.makeText(this, &quot;得到授权&quot;, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(this, &quot;授权取消&quot;, Toast.LENGTH_SHORT).show(); } }各位可在Toast处按照项目需求做出具体的适合自己项目的处理。上述完整的代码已经放到Github上面，有兴趣的朋友可以下载查看，网址：https://github.com/XiaoWenHan/AndroidRunTimePermissionDemo/下面附上需要做类似处理的权限列表： 身体传感器 日历 摄像头 通讯录 地理位置 麦克风 电话 短信 存储空间 给大家提个醒，如果你项目中的targetSdk&lt;23，是无需做上述处理的。目前，针对运行时授权处理的框架已经有一些了，感兴趣的朋友可以去看看。下面放上几个： PermissionsDispatcher使用标注的方式，动态生成类处理运行时权限，目前还不支持嵌套Fragment。 RxPermissions基于RxJava的运行时权限检测框架 Grant简化运行时权限的处理，比较灵活 android-RuntimePermissionsGoogle官方的例子 最后，放上一个无需权限处理即可使用的权限： android.permission.ACCESS_LOCATION_EXTRA_COMMANDSandroid.permission.ACCESS_NETWORK_STATEandroid.permission.ACCESS_NOTIFICATION_POLICYandroid.permission.ACCESS_WIFI_STATEandroid.permission.ACCESS_WIMAX_STATEandroid.permission.BLUETOOTHandroid.permission.BLUETOOTH_ADMINandroid.permission.BROADCAST_STICKYandroid.permission.CHANGE_NETWORK_STATEandroid.permission.CHANGE_WIFI_MULTICAST_STATEandroid.permission.CHANGE_WIFI_STATEandroid.permission.CHANGE_WIMAX_STATEandroid.permission.DISABLE_KEYGUARDandroid.permission.EXPAND_STATUS_BARandroid.permission.FLASHLIGHTandroid.permission.GET_ACCOUNTSandroid.permission.GET_PACKAGE_SIZEandroid.permission.INTERNETandroid.permission.KILL_BACKGROUND_PROCESSESandroid.permission.MODIFY_AUDIO_SETTINGSandroid.permission.NFCandroid.permission.READ_SYNC_SETTINGSandroid.permission.READ_SYNC_STATSandroid.permission.RECEIVE_BOOT_COMPLETEDandroid.permission.REORDER_TASKSandroid.permission.REQUEST_INSTALL_PACKAGESandroid.permission.SET_TIME_ZONEandroid.permission.SET_WALLPAPERandroid.permission.SET_WALLPAPER_HINTSandroid.permission.SUBSCRIBED_FEEDS_READandroid.permission.TRANSMIT_IRandroid.permission.USE_FINGERPRINTandroid.permission.VIBRATEandroid.permission.WAKE_LOCKandroid.permission.WRITE_SYNC_SETTINGScom.android.alarm.permission.SET_ALARMcom.android.launcher.permission.INSTALL_SHORTCUTcom.android.launcher.permission.UNINSTALL_SHORTCUT","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.xiaowenhan.com.cn/tags/Android/"}]},{"title":"童年时光","slug":"童年时光","date":"2016-11-22T03:13:00.000Z","updated":"2019-08-28T00:27:38.020Z","comments":true,"path":"2016/11/22/童年时光/","link":"","permalink":"http://www.xiaowenhan.com.cn/2016/11/22/童年时光/","excerpt":"","text":"","categories":[{"name":"摄影作品","slug":"摄影作品","permalink":"http://www.xiaowenhan.com.cn/categories/摄影作品/"}],"tags":[{"name":"旧时光","slug":"旧时光","permalink":"http://www.xiaowenhan.com.cn/tags/旧时光/"}]},{"title":"搭建React Native环境的几个Tips","slug":"搭建React Native环境的几个Tips","date":"2016-11-08T00:09:47.000Z","updated":"2019-08-01T22:23:03.823Z","comments":true,"path":"2016/11/08/搭建React Native环境的几个Tips/","link":"","permalink":"http://www.xiaowenhan.com.cn/2016/11/08/搭建React Native环境的几个Tips/","excerpt":"","text":"博主最近在研究跨平台开发，打算好好研究一下React Native这个比较被大家熟知的玩意。昨天进行了环境搭建和初步的学习，感觉上手还算快。在这里，把一些已经发现的坑，提前告诉给各位，希望能让读者们少走一些弯路。首先说一下无论是Mac，Windows，还是Linux，如果有能力，请直接去英文官网查看文档，不要看中文官网，真的有坑，稍候细说。我的环境，Mac，Windows都有，先说Windows。Windows环境暂且肯定是不支持开发iOS应用的哈，这个大家应该知道。然后大家按照官网文档中的步骤来就行。这里放一个链接：https://facebook.github.io/react-native/docs/getting-started.html这个给大家提个醒，最好全程备梯子翻墙。说下Chocolatey，比较简单的方法就是cmd里面执行语句，很快就行了，这个是前提，没有Chocolatey，就没有后面的步骤，所以不要被它卡住。这里放下cmd命令： 1powershell -NoProfile -ExecutionPolicy Bypass -Command &quot;iex((new-object net.webclient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))&quot; &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin 网络畅通的话几秒钟就安装好了。接下来就是Node和Python，这个按照官网的指令来就可以了。还是那句话，网络畅通的话也是很快就好了。这里可能Python慢一点，多等一下就会好。再下来就是准备Android开发环境，什么SDK啊，IDE（Android Studio）啊都备好。SDK的话我建议大家，下全，如果硬盘空间足够，就做个全下载吧。再下来安装React Native Cli，这一步，关掉cmd窗口，再开个新的，才能使用新的环境变量，也就是npm正常工作。重新打开cmd窗口后，还是按照官网的指引，安装React Native Cli。这一步会有命令行版的进度指示，虽然不太美观，至少还算直观。再下来配置Android SDK环境变量，这一步必须配，否则再下来会报错。配置的方法依然按照官方文档走。设置完环境变量之后，就可以运行了，首先cmd进入一个文件夹，这个文件夹将作为项目代码文件夹，可以新建，这个就随意了。运行react-native init AwesomeProject后，会出现install若干包的提示，这个是正常的，而且仅当新建项目的时候会有这个步骤，日后重新运行就没有了，而且不可省略，因此这里多等待一下吧。若干分钟后，进入新项目目录下执行react-native run-android，代码就运行起来了，和在Android Studio里面按Shift+F10（默认的Windows环境下的“运行”快捷键）的效果是一样的。这一步在首次运行时也需要下载一堆东西，日后也是无需的。部署到手机上之后，按手机的菜单键，或adb shell input keyevent 82唤出菜单键效果，在Dev Settings项里面把PC端IP和端口设置好。具体方法参见：https://facebook.github.io/react-native/docs/running-on-device-android.html文档里有详细的说明，当然，中文文档在部署运行上给出的向导一样贴心。再来说下Mac平台。到Mac平台就简单多了，还是按照官网的指示就行，没什么好特别强调的。不过这里还是要给大家提个醒，如果你看的是React Native的中文官网，那么，在安装node之后，在推荐安装里你会发现推荐安装Watchman。这个必须装，不是选装组件，是必须的，否则电脑端JS Server会报错，手机也会红屏报错，切记！","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"http://www.xiaowenhan.com.cn/tags/React-Native/"}]},{"title":"简易实现脸部贴近自动关屏","slug":"简易实现脸部贴近自动关屏","date":"2016-10-16T09:48:47.000Z","updated":"2019-08-01T22:23:03.826Z","comments":true,"path":"2016/10/16/简易实现脸部贴近自动关屏/","link":"","permalink":"http://www.xiaowenhan.com.cn/2016/10/16/简易实现脸部贴近自动关屏/","excerpt":"","text":"博主最近工作超忙，好久没来更新博客了，真是抱歉。今天分享给大家一个简易的Demo，实现的效果是：当手机屏幕贴近脸部时，屏幕自动熄灭。当然，由于是简单的思路，所以这里所谓的“熄灭”并非真的关闭屏幕，而是简单地使用一张黑色背景的图片遮盖住所有显示的内容，看上去像是关闭了屏幕而已。整个实现思路较为简单，首先启动监听器，监听距离变化，一旦距离到达一定的接近值的时候，就关掉屏幕；反之则打开屏幕。这里的学问仅在于一个距离传感器返回给我们的距离值，这个距离值会在相应的监听器回调里面获取。不多说了，直接上代码：需要添加的权限： 12&lt;uses-permission Android:name=&quot;android.permission.DEVICE_POWER&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot;/&gt; Java主逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import android.app.Activity; import android.content.Context; import android.hardware.Sensor; import android.hardware.SensorEvent; import android.hardware.SensorEventListener; import android.hardware.SensorManager; import android.os.Bundle; import android.os.PowerManager; import android.util.Log; import android.view.Menu; import android.view.View; public class SensorTest extends Activity implements SensorEventListener&#123; public static final String TAG = &quot;SensorTest&quot;; //调用距离传感器，控制屏幕 private SensorManager mManager;//传感器管理对象 //屏幕开关 private PowerManager localPowerManager = null;//电源管理对象 private PowerManager.WakeLock localWakeLock = null;//电源锁 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.sensor); mManager = (SensorManager)getSystemService(Context.SENSOR_SERVICE); //获取系统服务POWER_SERVICE，返回一个PowerManager对象 localPowerManager = (PowerManager) getSystemService(Context.POWER_SERVICE); //获取PowerManager.WakeLock对象,后面的参数|表示同时传入两个值,最后的是LogCat里用的Tag localWakeLock = this.localPowerManager.newWakeLock(32, &quot;MyPower&quot;);//第一个参数为电源锁级别，第二个是日志tag &#125; public void onResume()&#123; super.onResume(); mManager.registerListener(this, mManager.getDefaultSensor(Sensor.TYPE_PROXIMITY),// 距离感应器 SensorManager.SENSOR_DELAY_NORMAL);//注册传感器，第一个参数为距离监听器，第二个是传感器类型，第三个是延迟类型 &#125; public void onStop()&#123; super.onStop(); Log.d(TAG,&quot;on stop&quot;); &#125; public void onDestroy()&#123; super.onDestroy(); Log.d(TAG,&quot;on destroy&quot;); if(mManager != null)&#123; localWakeLock.release();//释放电源锁，如果不释放finish这个acitivity后仍然会有自动锁屏的效果，不信可以试一试 mManager.unregisterListener(this);//注销传感器监听 &#125; &#125; @Override public void onAccuracyChanged(Sensor sensor, int accuracy) &#123; // TODO Auto-generated method stub &#125; @Override public void onSensorChanged(SensorEvent event) &#123; // TODO Auto-generated method stub float[] its = event.values; //Log.d(TAG,&quot;its array:&quot;+its+&quot;sensor type :&quot;+event.sensor.getType()+&quot; proximity type:&quot;+Sensor.TYPE_PROXIMITY); if (its != null &amp;&amp; event.sensor.getType() == Sensor.TYPE_PROXIMITY) &#123; System.out.println(&quot;its[0]:&quot; + its[0]); //经过测试，当手贴近距离感应器的时候its[0]返回值为0.0，当手离开时返回1.0 if (its[0] == 0.0) &#123;// 贴近手机 System.out.println(&quot;hands up&quot;); Log.d(TAG,&quot;hands up in calling activity&quot;); if (localWakeLock.isHeld()) &#123; return; &#125; else&#123; localWakeLock.acquire();// 申请设备电源锁 &#125; &#125; else &#123;// 远离手机 System.out.println(&quot;hands moved&quot;); Log.d(TAG,&quot;hands moved in calling activity&quot;); if (localWakeLock.isHeld()) &#123; return; &#125; else&#123; localWakeLock.setReferenceCounted(false); localWakeLock.release(); // 释放设备电源锁 &#125; &#125; &#125; &#125; &#125; 这里特别注意：1、在退出的时候务必释放，否则有可能在其他正常使用的情况下仍然会黑屏；2、注意非空检查，在某些未配备距离传感器的机型上，会报空。","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.xiaowenhan.com.cn/tags/Android/"}]},{"title":"取之有道——巧用Root权限 启动其他APP中的Activity","slug":"取之有道——巧用Root权限 启动其他APP中的Activity","date":"2016-06-16T06:05:41.000Z","updated":"2019-08-01T22:23:03.818Z","comments":true,"path":"2016/06/16/取之有道——巧用Root权限 启动其他APP中的Activity/","link":"","permalink":"http://www.xiaowenhan.com.cn/2016/06/16/取之有道——巧用Root权限 启动其他APP中的Activity/","excerpt":"","text":"这次博主来分享一个很巧妙的办法来启动其他APP中Activity的方法。首先说一下这样做的目的：最近博主在攻克一个技术难点，就是搞定某些三方系统中，对于应用权限的限制。为此给出用户指导，引导用户启动系统中的权限设置来设置信任。到此，问题就来了：我们不知道权限设定的包名，也不知道权限设置的Activity的名字，如何启动到指定的界面呢？今天我们就来解决这个问题。首先，我们需要一台已经获取Root权限了的手机。当然，模拟器之流也是可以考虑的。还有RE（Root Explorer）文件浏览器，用来浏览AndroidManifest.xml。这里注意的是，不要试图复制到电脑上查看，会是乱码的。然后，我们开始通过包名来查找有可能的程序。由于博主手里用的测试机是华为的机器，因此以华为为例。其他厂商的手机请各位自行查找，方法应该是一致的。使用RE文件浏览器，获取读写权限，依次打开/system/app。在这里，你将会看到好多APK。由于RE文件浏览器能够预览APK的图标，所以我们可以很轻松地通过软件图标，找到权限管理所属的APK文件。以华为最新的EMUI为例，权限管理所属的软件是手机管家，APK的文件名为：“HwSystemManager.apk”。使用RE文件浏览器打开APK，选择查看，即可看到解压后的文件。也就可以直接找到AndroidManifest.xml。继续使用RE文件浏览器打开这个xml文件，其中的Activity的名字便一览无遗了。最后，找到正确的Activity，启动它即可。这样，就能够在用户指导的权限设置页给出正确的启动入口了。当然，此方法也适用于启动任何一个APP中的Activity，只要配置文件中的exported值不为false即可启动。小小技巧，班门弄斧。不足之处，望路过大神多多指教。","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.xiaowenhan.com.cn/tags/Android/"}]},{"title":"梦想座驾","slug":"梦想座驾","date":"2016-05-10T07:32:00.000Z","updated":"2019-08-28T00:27:38.017Z","comments":true,"path":"2016/05/10/梦想座驾/","link":"","permalink":"http://www.xiaowenhan.com.cn/2016/05/10/梦想座驾/","excerpt":"","text":"","categories":[{"name":"摄影作品","slug":"摄影作品","permalink":"http://www.xiaowenhan.com.cn/categories/摄影作品/"}],"tags":[{"name":"随手拍","slug":"随手拍","permalink":"http://www.xiaowenhan.com.cn/tags/随手拍/"}]},{"title":"清明赏花","slug":"清明赏花","date":"2016-04-04T07:48:00.000Z","updated":"2019-08-28T00:27:38.019Z","comments":true,"path":"2016/04/04/清明赏花/","link":"","permalink":"http://www.xiaowenhan.com.cn/2016/04/04/清明赏花/","excerpt":"","text":"","categories":[{"name":"摄影作品","slug":"摄影作品","permalink":"http://www.xiaowenhan.com.cn/categories/摄影作品/"}],"tags":[{"name":"随手拍","slug":"随手拍","permalink":"http://www.xiaowenhan.com.cn/tags/随手拍/"}]},{"title":"为了安全——应用锁屏开发实战","slug":"为了安全——应用锁屏开发实战","date":"2016-03-16T07:49:45.000Z","updated":"2019-08-01T22:23:03.815Z","comments":true,"path":"2016/03/16/为了安全——应用锁屏开发实战/","link":"","permalink":"http://www.xiaowenhan.com.cn/2016/03/16/为了安全——应用锁屏开发实战/","excerpt":"","text":"今天我们来谈一个问题：应用锁屏。说老实话，这种设定目前已经被广泛使用了，多见于支付宝、京东金融、QQ等对安全性和隐私性要求较高的程序使用。关于该功能的实现，有不止一条解决办法。这里就不一一列举了，只对其中一种做详细解释和示例程序的代码分享。这里我声明一下，好像自从写博客到现在，我一直都在用Android Studio为IDE来开发，强烈建议还在使用Eclipse的小伙伴尽快使用它。尽管一上来可能有些许不便，但是上手之后效率会有所提高，不信就去试试！本文介绍的方法解决思路如下： 监听屏幕变化，即关闭和打开屏幕； 设置需要出现锁屏的标志变量，默认值为false。当接收到屏幕被关闭的广播后，将其置为true。 在Activity生命周期onResume中，检测上述变量值，若为true，则启动安全校验机制，反之无操作。 Demo代码中包含的锁屏机制提供了多种选项，可自由组合实现不同的应用解锁效果。 步骤1 设置监听器首先我们写一个类，集成BroadcastReceiver，用来接收系统Screen off的Action。这里我才用了Java代码中动态注册监听器的方法，而非xml配置文件，因为这样可以更方便的让我们对监听使能进行控制。由于监听器需要在代码中进行实例化，因此我们可以在监听器相关类中定义布尔变量，来标识是否有了关闭屏幕的操作。代码片段如下所示： 1234567891011121314151617181920public class LockScreenReceiver extends BroadcastReceiver &#123; private boolean isNeedCheck; @Override public void onReceive(Context context, Intent intent) &#123; if (intent.getAction().equals(Intent.ACTION_SCREEN_OFF)) &#123; //关闭屏幕 isNeedCheck = true; &#125; &#125; public void unRegist() &#123; isNeedCheck = false; &#125; public boolean isNeedCheck() &#123; return isNeedCheck; &#125;&#125; 步骤2 动态注册监听器这一步骤要求我们对监听器进行动态注册，所谓动态注册就是绑定到指定的控件上，由用户自由选择，进行注册和取消注册。具体代码见Demo。下面放上Github地址：https://github.com/XiaoWenHan/Demo_SafeScreen","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.xiaowenhan.com.cn/tags/Android/"}]},{"title":"自定义ImageView系列 － 区域截图（下）","slug":"自定义ImageView系列 － 区域截图（下）","date":"2015-11-06T02:42:26.000Z","updated":"2019-08-01T22:23:03.828Z","comments":true,"path":"2015/11/06/自定义ImageView系列 － 区域截图（下）/","link":"","permalink":"http://www.xiaowenhan.com.cn/2015/11/06/自定义ImageView系列 － 区域截图（下）/","excerpt":"","text":"功能要点： 根据控件自身大小计算合适的透明正方形预览区； 截取预览区图像并按照指定的尺寸缩放，生成Bitmap对象。 本文着重介绍上述第2个要点，涉及两个问题： 屏幕指定区域截图； 图片缩放。 由于在前文中，我们知道了指定区域的方位，那么解决起来就轻松很多了。只要先截取整个屏幕，然后利用Matrix将图片进行裁剪即可。截取到指定部分的图像后，再利用Matrix的postScale()方法即可进行缩放。下面放上代码片段： 123456789public Bitmap getAdjustedBitmap(Activity activity) &#123; View view = activity.getWindow().getDecorView(); view.setDrawingCacheEnabled(true); view.buildDrawingCache(); bitmap = view.getDrawingCache(); matrix = new Matrix(); matrix.postScale((CommonSettings.AVATOR\\_SIZE * 1.0f) / (previewEdge[1] - previewEdge[0]), (CommonSettings.AVATOR\\_SIZE * 1.0f) / (previewEdge[1] - previewEdge[0])); return Bitmap.createBitmap(bitmap, previewEdge[0] - 2, previewEdge[2] + myLocationStart[1] - 2, previewEdge[1] - previewEdge[0], previewEdge[1] - previewEdge[0], matrix, false);&#125; 如上所示，即可完成截图和缩放操作。接下来放上整个重写的ImageView类的代码，这里面还包含了双指缩放和单指移动操作功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203import android.app.Activity;import android.content.Context;import android.graphics.Bitmap;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Matrix;import android.graphics.Paint;import android.util.AttributeSet;import android.view.MotionEvent;import android.view.View;import android.widget.ImageView;public class PhotoChooseForAvatorImageView extends ImageView &#123; private Bitmap bitmap; private Matrix matrix; private float point1\\_old\\_x, point1\\_old\\_y, point1\\_new_x, point1\\_new\\_y, point2\\_old\\_x, point2\\_old\\_y, point2\\_new\\_x, point2\\_new\\_y, distance\\_old, distance\\_new; private float point\\_old\\_x, point\\_old\\_y, point\\_new\\_x, point\\_new\\_y; private boolean isMultiTouch = false; private int[] myLocationStart; private int[] myLocationEnd; private int[] myLocationMid; private int[] previewEdge; private int bitmapLocXStart, bitmapLocXEnd, bitmapLocYStart, bitmapLocYEnd; private Paint rectPaint; private Paint rectBgPaint; public PhotoChooseForAvatorImageView(Context context) &#123; super(context); if (matrix == null) &#123; matrix = new Matrix(); &#125; &#125; public PhotoChooseForAvatorImageView(Context context, AttributeSet attrs) &#123; super(context, attrs); if (matrix == null) &#123; matrix = new Matrix(); &#125; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.save(); if (bitmap != null) &#123; canvas.drawBitmap(bitmap, matrix, null); &#125; if (previewEdge != null) &#123; //上 canvas.drawLine(previewEdge[0], previewEdge[2], previewEdge[1], previewEdge[2], rectPaint); //左 canvas.drawLine(previewEdge[0], previewEdge[2], previewEdge[0], previewEdge[3], rectPaint); //下 canvas.drawLine(previewEdge[0], previewEdge[3], previewEdge[1], previewEdge[3], rectPaint); //右 canvas.drawLine(previewEdge[1], previewEdge[2], previewEdge[1], previewEdge[3], rectPaint); //灰色部分 canvas.drawRect(0, 0, previewEdge[0], myLocationEnd[1], rectBgPaint); canvas.drawRect(previewEdge[0], 0, previewEdge[1], previewEdge[2], rectBgPaint); canvas.drawRect(previewEdge[1], 0, myLocationEnd[0], myLocationEnd[1], rectBgPaint); canvas.drawRect(previewEdge[0], previewEdge[3], previewEdge[1], myLocationEnd[1], rectBgPaint); &#125; canvas.restore(); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction() &amp; MotionEvent.ACTION\\_MASK) &#123; case MotionEvent.ACTION\\_DOWN: // 单点移动 按下 if (event.getPointerCount() == 1) &#123; isMultiTouch = false; point\\_old\\_x = event.getX(); point\\_old\\_y = event.getY(); &#125; break; case MotionEvent.ACTION\\_UP: // 单点移动 抬起 if (event.getPointerCount() == 1) &#123; isMultiTouch = false; point\\_old\\_x = point\\_new\\_x; point\\_old\\_y = point\\_new\\_y; &#125; break; case MotionEvent.ACTION\\_POINTER\\_UP: // 双点操作 抬起 if (event.getPointerCount() == 2) &#123; isMultiTouch = true; point1\\_old\\_x = point1\\_new\\_x; point1\\_old\\_y = point1\\_new\\_y; point2\\_old\\_x = point2\\_new\\_x; point2\\_old\\_y = point2\\_new\\_y; &#125; break; case MotionEvent.ACTION\\_POINTER\\_DOWN: // 双点操作 按下 if (event.getPointerCount() == 2) &#123; isMultiTouch = true; point1\\_old\\_x = event.getX(0); point1\\_old\\_y = event.getY(0); point2\\_old\\_x = event.getX(1); point2\\_old\\_y = event.getY(1); distance_old = (float) Math .sqrt(((point1\\_old\\_x - point2\\_old\\_x) * (point1\\_old\\_x - point2\\_old\\_x) + (point1\\_old\\_y - point2\\_old\\_y) * (point1\\_old\\_y - point2\\_old\\_y))); &#125; break; case MotionEvent.ACTION_MOVE: // 双点操作 移动 if (event.getPointerCount() == 2) &#123; isMultiTouch = true; point1\\_new\\_x = event.getX(0); point1\\_new\\_y = event.getY(0); point2\\_new\\_x = event.getX(1); point2\\_new\\_y = event.getY(1); pinch(); &#125; else &#123; // 单点移动 移动 if (event.getPointerCount() == 1) &#123; if (!isMultiTouch) &#123; point_\\new\\_x = event.getX(); point\\_new\\_y = event.getY(); matrix.postTranslate((point\\_new_x - point\\_old\\_x), (point\\_new\\_y - point\\_old\\_y)); point\\_old\\_x = point\\_new\\_x; point\\_old\\_y = point\\_new\\_y; invalidate(); &#125; &#125; &#125; break; &#125; return true; &#125; // 缩放图片方法 private void pinch() &#123; distance_new = (float) Math.sqrt(((point1_new_x - point2_new_x) * (point1_new_x - point2_new_x) + (point1_new_y - point2_new_y) * (point1_new_y - point2_new_y))); matrix.postScale((distance_new / distance_old), (distance_new / distance_old), this.getWidth() / 2, this.getTop() / 2); invalidate(); distance_old = distance_new; &#125; /** * 设置Bitmap * * @param bitmap */ public void setImage(Bitmap bitmap) &#123; this.bitmap = bitmap; //获取控件自身起始点 myLocationStart = new int[2]; getLocationOnScreen(myLocationStart); //获取控件自身终止点 myLocationEnd = new int[2]; myLocationEnd[0] = getWidth() + myLocationStart[0]; myLocationEnd[1] = getHeight() + myLocationStart[1]; //计算控件自身中点 myLocationMid = new int[2]; myLocationMid[0] = (myLocationStart[0] + myLocationEnd[0]) / 2; myLocationMid[1] = (myLocationStart[1] + myLocationEnd[1]) / 2 - myLocationStart[1]; //设置中间预览框边框色 rectPaint = new Paint(); rectPaint.setColor(Color.WHITE); rectPaint.setStrokeWidth(2); rectBgPaint = new Paint(); rectBgPaint.setColor(getResources().getColor(R.color.photo_adjust_for_avator_bg)); //计算中间预览边框位置 previewEdge = new int[4]; previewEdge[0] = (myLocationMid[0] - myLocationStart[0]) / 8; previewEdge[1] = myLocationEnd[0] - previewEdge[0]; previewEdge[2] = myLocationMid[1] - ((previewEdge[1] - previewEdge[0]) / 2); previewEdge[3] = myLocationMid[1] + ((previewEdge[1] - previewEdge[0]) / 2); //计算Bitmap起点 bitmapLocXStart = myLocationMid[0] - bitmap.getWidth() / 2; bitmapLocYStart = myLocationMid[1] - bitmap.getHeight() / 2; bitmapLocXEnd = bitmapLocXStart + bitmap.getWidth(); bitmapLocYEnd = bitmapLocYStart - bitmap.getHeight(); //调整Bitmap位置 matrix.postTranslate(bitmapLocXStart, bitmapLocYStart); PhotoChooseForAvatorImageView.this.invalidate(); &#125; /** * 截图并返回Bitmap对象 */ public Bitmap getAdjustedBitmap(Activity activity) &#123; View view = activity.getWindow().getDecorView(); view.setDrawingCacheEnabled(true); view.buildDrawingCache(); bitmap = view.getDrawingCache(); matrix = new Matrix(); matrix.postScale((CommonSettings.AVATOR_SIZE * 1.0f) / (previewEdge[1] - previewEdge[0]), (CommonSettings.AVATOR_SIZE * 1.0f) / (previewEdge[1] - previewEdge[0])); return Bitmap.createBitmap(bitmap, previewEdge[0] - 2, previewEdge[2] + myLocationStart[1] - 2, previewEdge[1] - previewEdge[0], previewEdge[1] - previewEdge[0], matrix, false); &#125; /** * 重置Bitmap（回收内存） */ public void resetBitmap() &#123; bitmap.recycle(); bitmap = null; &#125;&#125;","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.xiaowenhan.com.cn/tags/Android/"}]},{"title":"自定义ImageView系列 － 区域截图（上）","slug":"自定义ImageView系列 － 区域截图（上）","date":"2015-11-04T15:52:48.000Z","updated":"2019-08-01T22:23:03.828Z","comments":true,"path":"2015/11/04/自定义ImageView系列 － 区域截图（上）/","link":"","permalink":"http://www.xiaowenhan.com.cn/2015/11/04/自定义ImageView系列 － 区域截图（上）/","excerpt":"","text":"功能要点： 根据控件自身大小计算合适的透明正方形预览区； 截取预览区图像并按照指定的尺寸缩放，生成Bitmap对象。本文着重介绍上述第1个要点。 博主又来更新文章啦！关于ImageView呢，其实我之前接触过一些继承它来实现一些功能。比如双指缩放，单指移动之类。而最近工作中又要用到继承它来实现某些功能。借此机会好好整理一下，也分享给更多需要的朋友们！使用本系列文章完成的自定义多功能ImageView可以实现微信中的头像选择的照片调整功能。而且，微信的图片调整界面会有不流畅的情况出现。而用本文中的办法是不会出现卡顿现象的。当然，这可能是机器的原因，不同的机器可能表现不同。我使用的测试机是三星的S6。废话不多说，我们来讲一下如何绘制中间的透明框。思路是这样的：为了更好的可移植性，首先通过获取ImageView的尺寸，获得ImageView的尺寸；然后通过该尺寸计算出控件中点和合适的正方形边长，一般是由宽和高其中最短的一者决定的；最后，将该正方形外的所有部分给一个半透明的黑色，再画出正方形的边缘即可。获取控件的高度不是难事，继承了ImageView后，调用getWidth()和getHeight()方法即可完成宽高的获取。获取控件的中点的方法是首先获取控件所在位置的起始点，也就是左上角的x和y的绝对像素坐标点。然后与宽度和高度分别相加，就可得到控件的终止点，也就是控件右下角的x和y的绝对像素坐标点。有了这两个值，控件的中点就可以确定下来了。下面再定义预览框的边长。由于这里我们要采用绝对像素值，因此需要根据控件的大小动态计算出预览框的大小。这里我要提醒各位的就是：一个正方形，只要有两个完整的x和y轴的组合坐标，就可以确定该正方形的位置了，即对角坐标。我们这里计算左上和右下的位置。左上角x坐标我是采用了中点x坐标减控件起点x位置再除以8确定的。换言之，就是该值是整个预览框距离左边的距离，而又由于这是一个正方形，因此右上角的坐标也就同时确定了（中点坐标x减去左上角x坐标再乘以2）。y轴坐标也很容易了，只需用中点y坐标减去上述两个x轴坐标之差的二分之一就可以了。由此，y轴终点的坐标也可以计算出来了，即用起点y轴坐标加上两个x轴之差坐标即可。 特别注意 － 这里有坑后面我会把这部分的代码贴上，个人私心想，肯定会有人直接复制粘贴，所以……必须提醒一下各位：犹豫项目需求问题，我这里只考虑了控件高度大于控件宽度的情况，所以，诸位在复制粘贴后，务必判断一下宽高的情况，然后分情况讨论。上述问题分别出现在中点和预览区边距的计算上。如果这个坑的问题没看懂，没事，试一次就知道了。方法是：不要限制屏幕旋转，然后整个屏幕放这样一个ImageView，然后倒转屏幕，看看正方形会发生什么变化。祝君好运！最后，我们画正方形的边缘，再在其余的部分给定半透明黑色即可。这里就直接放代码片段了：画正方形边缘： 12345678910if (previewEdge != null) &#123; //上 canvas.drawLine(previewEdge[0], previewEdge[2], previewEdge[1], previewEdge[2], rectPaint); //左 canvas.drawLine(previewEdge[0], previewEdge[2], previewEdge[0], previewEdge[3], rectPaint); //下 canvas.drawLine(previewEdge[0], previewEdge[3], previewEdge[1], previewEdge[3], rectPaint); //右 canvas.drawLine(previewEdge[1], previewEdge[2], previewEdge[1], previewEdge[3], rectPaint);｝ 解释一下：该部分代码放在重写的onDraw()中。previewEdge是一个有4个int值的数组，分别代表左上和右下的x和y坐标值。稍后贴出计算部分代码。填充半透明黑色： 12345//灰色部分canvas.drawRect(0, 0, previewEdge[0], myLocationEnd[1], rectBgPaint);canvas.drawRect(previewEdge[0], 0, previewEdge[1], previewEdge[2], rectBgPaint);canvas.drawRect(previewEdge[1], 0, myLocationEnd[0], myLocationEnd[1], rectBgPaint);canvas.drawRect(previewEdge[0], previewEdge[3], previewEdge[1], myLocationEnd[1], rectBgPaint); 各种计算的代码片： 1234567891011121314151617181920212223//获取控件自身起始点myLocationStart = new int[2];getLocationOnScreen(myLocationStart);//获取控件自身终止点myLocationEnd = new int[2];myLocationEnd[0] = getWidth() + myLocationStart[0];myLocationEnd[1] = getHeight() + myLocationStart[1];//计算控件自身中点myLocationMid = new int[2];myLocationMid[0] = (myLocationStart[0] + myLocationEnd[0]) / 2;myLocationMid[1] = (myLocationStart[1] + myLocationEnd[1]) / 2 - myLocationStart[1];//设置中间预览框边框色rectPaint = new Paint();rectPaint.setColor(Color.WHITE);rectPaint.setStrokeWidth(2);rectBgPaint = new Paint();rectBgPaint.setColor(getResources().getColor(R.color.photo\\_adjust\\_for\\_avator\\_bg));//计算中间预览边框位置previewEdge = new int[4];previewEdge[0] = (myLocationMid[0] - myLocationStart[0]) / 8;previewEdge[1] = myLocationEnd[0] - previewEdge[0];previewEdge[2] = myLocationMid[1] - ((previewEdge[1] - previewEdge[0]) / 2);previewEdge[3] = myLocationMid[1] + ((previewEdge[1] - previewEdge[0]) / 2); 变量的名字都很容易看懂吧，我这里就不详述了。最后说一句，这个最好自己练习一下计算，印象深一些。完整的ImageView类代码将在整个系列文章的最后一篇中贴出。希望大家多多支持，谢谢！！！","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.xiaowenhan.com.cn/tags/Android/"}]},{"title":"Activity与DialogFragment交互的方法","slug":"Activity与DialogFragment交互的方法","date":"2015-10-27T12:23:49.000Z","updated":"2019-08-01T22:23:03.810Z","comments":true,"path":"2015/10/27/Activity与DialogFragment交互的方法/","link":"","permalink":"http://www.xiaowenhan.com.cn/2015/10/27/Activity与DialogFragment交互的方法/","excerpt":"","text":"好久没有更新博客了，今天我们来讨论一下如何在Activity与DialogFragment交互的方法，这里包括了DialogFragment的启动以及Activity方法的调用。DialogFragment与Dialog相比类似，是官方现在更建议使用的Dialog。DialogFragment的定义新建一个DialogFragment，该类继承DialogFragment。复写onCreateView()方法，在该方法中设置Dialog的布局。这个Dialog的布局可以完全自定义，可以包括任何常见的河自定义的控件。下面是一个实例： 1234@Overridepublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; getDialog().requestWindowFeature(Window.FEATURE_NO_TITLE); View layoutView = inflater.inflate(R.layout.fragment_dialog_login_tip, container, false); 如上代码块所示，fragment_dialog_login_tip.xml里面我只定义了一个TextView显示一些信息。如果读者想要添加按钮或其他控件，可在这个复写的方法中通过layoutView.findViewById()来初始化并设置监听器。DialogFragment的启动要启动一个DialogFragment，要在Activity中new出该类的实例，然后通过.show()方法启动。下面是一个实例： 1234FragmentManager fragmentManager = getSupportFragmentManager();loginTipDialogFragment = new LoginTipDialogFragment();loginTipDialogFragment.setCancelable(false);loginTipDialogFragment.show(fragmentManager, &quot;login_tip_dialog&quot;); 如上所示，这个DialogFragment就可以显示出来了。从DialogFragment调用Activity中的方法要从DialogFragment调用Activity中的方法，首先满足下列两点要求： 1. 该Activity是启动该DialogFragment的； 2. 要被调用的方法是public的。比如，在上面那个启动DialogFragment的Activity中有一个exit()方法，用来退出应用程序，Activity的名字叫做TestActivity。DialogFragment中要实现退出程序可以按照如下方法发起调用： 1((TestActivity)getActivity()).exit(); 从Activity 调用DialogFragment中的方法这种方式的调用就简单多了。由于有对象实例，直接 .方法名 就可以了。","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.xiaowenhan.com.cn/tags/Android/"}]},{"title":"九龙潭","slug":"九龙潭","date":"2015-10-25T04:07:00.000Z","updated":"2019-08-28T00:27:38.012Z","comments":true,"path":"2015/10/25/九龙潭/","link":"","permalink":"http://www.xiaowenhan.com.cn/2015/10/25/九龙潭/","excerpt":"","text":"","categories":[{"name":"摄影作品","slug":"摄影作品","permalink":"http://www.xiaowenhan.com.cn/categories/摄影作品/"}],"tags":[{"name":"观世界","slug":"观世界","permalink":"http://www.xiaowenhan.com.cn/tags/观世界/"}]},{"title":"Android GridView 点击效果（可能是最快捷的实现，另有福利）","slug":"Android GridView 点击效果（可能是最快捷的实现，另有福利）","date":"2015-08-12T00:50:04.000Z","updated":"2019-08-01T22:23:03.812Z","comments":true,"path":"2015/08/12/Android GridView 点击效果（可能是最快捷的实现，另有福利）/","link":"","permalink":"http://www.xiaowenhan.com.cn/2015/08/12/Android GridView 点击效果（可能是最快捷的实现，另有福利）/","excerpt":"","text":"好久没有发过文章了，今天给朋友们分享的是：给GirdView添加点击效果， 点击时改变背景 。这其实也是我在项目开发中遇到的问题，习惯性的百度了一圈，又Google了一圈。解决方案大致可归为两类： 代码实现，逻辑处理，监听点击时间，改变相应控件的BackGround； Selector实现，用XML定义，Layout中赋予相应属性。 首先第1个解决办法，怎么说呢，虽然逻辑不是很复杂，但也无形中增加了Bug出现的可能。第二个我试了好久，都达不到理想效果。于是我做了一件自认为聪明的做法，没想到居然管用。很简单，首先还是 写一个Selector ，预先定义按下去是用什么素材，普通状态时什么素材；然后 GridView本身没有进行任何selector的赋值 ，只是有一个Background和horizontalSpacing，用来显示分割线（哈，不小心又透露了一招）。然后在每个item的布局的根节点， 把Selector作为Background赋值 ，就可以了。","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.xiaowenhan.com.cn/tags/Android/"}]},{"title":"Android平台录音音量计的实现","slug":"Android平台录音音量计的实现","date":"2015-07-08T05:31:50.000Z","updated":"2019-08-01T22:23:03.813Z","comments":true,"path":"2015/07/08/Android平台录音音量计的实现/","link":"","permalink":"http://www.xiaowenhan.com.cn/2015/07/08/Android平台录音音量计的实现/","excerpt":"","text":"今天博主要给大家分享的是如何在Android平台上实现录音时的音量指示计。开门见山，先来看一张Demo的效果图：如上图所示，两个按钮分别是开始录音和停止录音，中间的两个数字前后分别代表音量档位（目前是8档）和原始音量值（0-32767），下方是音量计，由ProgressBar负责显示。完整的源码可以在下面的网址找到：https://github.com/XiaoWenHan/AndroidMircrophoneVolumeDemo欢迎各位读者批评指正，谢谢！","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.xiaowenhan.com.cn/tags/Android/"}]},{"title":"调用系统相机导致照片旋转问题的修复","slug":"调用系统相机导致照片旋转问题的修复","date":"2015-07-02T06:29:56.000Z","updated":"2019-08-01T22:23:03.830Z","comments":true,"path":"2015/07/02/调用系统相机导致照片旋转问题的修复/","link":"","permalink":"http://www.xiaowenhan.com.cn/2015/07/02/调用系统相机导致照片旋转问题的修复/","excerpt":"","text":"如题，相信很多开发者在调用系统照相机接收拍好的照片时，发现照片被无故旋转了90度。这一问题反映在大部分的三星手机上，当然其他的机器还没试完全，总之是有问题。于是乎想到如下的解决办法： 识别机型，获取手机型号，然后判断是否需要旋转； 通过获取照片宽度和高度判断是否需要旋转； 自己动手写一个照相机Activity，自己来获取摄像头数据，保存照片； 分析发生旋转的照片数据，动态判断是否需要旋转，以及旋转正确的角度。 前三种方法均不是理想的解决方案。首先说1：这种类似于穷举的办法，总会有那些被遗忘的“角落”，维护这些机型会很繁琐；然后说2：如果这样的话，如果刚好用户要横屏照照片，还是会发生旋转；最后说3：这种方法岂是我等“懒”程序员所能做到的？（PS：其实是需求所限啦，自己写照相APP，耗时+费精力+容易出bug。好处就在于用户会感觉自己始终处于同一APP中，而不是发生了跳转。）那么第四种方案是如何做到的呢？首先通过分析，通常一张照片包含许多EXIF信息。这些信息包含了拍照的设备，曝光度，是否使用了闪光灯种种内容。这其中包括了角度，也就是旋转问题的症结所在。手机自身的照片查看器（某些机型）在显示照片的时候，会分析这些信息，当分析的角度的信息时，会自动旋转照片到合适的角度。比较常见的角度是90、180、270。大部分的三星手机在竖屏拍照的时候会拍出角度为90度的照片，横屏为0度。因此，解决的思路就是按照EXIF中的角度信息进行旋转即可。主要用到安卓API中的Matrix。关键代码可参考下面的代码片： 1234567891011121314ExifInterface exifInterface = new ExifInterface(APPCFG.IMAGE_FILE);int orientationDegree = exifInterface.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);Matrix matrix = new Matrix();matrix.reset();if (orientationDegree == ExifInterface.ORIENTATION_ROTATE_90) &#123; matrix.postRotate(90);&#125;if (orientationDegree == ExifInterface.ORIENTATION_ROTATE_180) &#123; matrix.postRotate(180);&#125;if (orientationDegree == ExifInterface.ORIENTATION_ROTATE_270) &#123; matrix.postRotate(270);&#125;bitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(),bitmap.getHeight(), matrix, true); 上述代码中，bitmap是Bitmap对象，我这里需要在后面显示，所以暂时没有recycle()，提醒大家一下，免得内存溢出。到此，无论是三星还是什么机型，利用这种通用的方法，即可解决照片旋转的问题了。","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.xiaowenhan.com.cn/tags/Android/"}]},{"title":"个性化个人主站——使用Hexo框架","slug":"个性化个人主站——使用Hexo框架","date":"2015-07-02T05:55:23.000Z","updated":"2019-08-01T22:23:03.814Z","comments":true,"path":"2015/07/02/个性化个人主站——使用Hexo框架/","link":"","permalink":"http://www.xiaowenhan.com.cn/2015/07/02/个性化个人主站——使用Hexo框架/","excerpt":"","text":"开门见山，之前我们有谈过使用Github来搭建免费的个人博客站点，从而摆脱现有博客提供商的限制，实现对博客内容的完全自定义。今天我们借用Hexo的框架来搭建站点。 关于搭建的过程，可以参考这位仁兄的博文：http://ibruce.info/2013/11/22/hexo-your-blog/还有Hexo框架的网站（下载安装Hexo会用到）：http://hexo.io/我在这里依旧是给大家的建站过程提供一些提示。 Node.js关于Node.js呢，如果大家使用Windows，而且是下载的exe安装程序安装的话，即使在安装程序里面选中了加入环境变量，在命令提示符中敲npm指令依旧不起作用。起码在单位的Windows 7和我自己电脑的Windows 8.1平台上是这样。解决之道是打开系统的环境变量设置，输入一个空格，再去掉这个空格，确定生效一下即可。囧 关于本地化和个性化其实，Hexo官方给出了多语言的解决方案，在框架根目录的_config.yml中进行配置就好。但是当我一旦在language字段写入CN之后就会在生成过程中报错，不知为何。因此我就绕道而行，直接去改themes中的主题文件了。这里列举一些（以默认landscape为例）：在themes\\landscape目录下，也有一个叫做_config.yml文件。打开它，在menu组下有几对对应的关系，前面的”Home”之类的英文，这些对应与网站左上角的栏目，把它改成中文的吧。比如：首页、归档……此外，这里支持扩展，比如你可以加上：博客: http://blog.csdn.net/xwhnew当访客点击博客时，就会自动跳转到上面的网页了。Content注释下的excerpt_link是博文的概览后的“Read more”文字内容，将其改为“阅读更多”即完成汉化。Miscellaneous注释下的favicon是网站的图标，不多说了，个性化必须改的！在themes\\landscape\\layout_widget下各个文件中，widget-title记得改为中文，比如archive是归档。themes\\landscape\\source\\css\\images路径下的banner.jpg，是网站上方的背景图，换成自己喜欢的吧！ 有关博文移植相信不少朋友希望把自己的所有博文都移植到个人站点中。想法不错，实现起来呢，基本掌握Markdown语法是必须的；其次，要有一个比较好的编辑器，网上有在线版，也有软件。这里比较推荐MarkdownPad，是一个PC端软件，无需购买付费版即完全够用，我现在也在用。最后，Hexo是根据.md文件的头部信息来读取日期信息的，如果我们是移植之前的博文，只需在date后将当前的时间改为旧博文发布的时间即可。","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://www.xiaowenhan.com.cn/tags/Web/"}]},{"title":"提升应用崩溃时的用户体验——去掉烦人的“很抱歉”提示框","slug":"提升应用崩溃时的用户体验——去掉烦人的“很抱歉”提示框","date":"2015-04-21T11:51:37.000Z","updated":"2019-08-01T22:23:03.823Z","comments":true,"path":"2015/04/21/提升应用崩溃时的用户体验——去掉烦人的“很抱歉”提示框/","link":"","permalink":"http://www.xiaowenhan.com.cn/2015/04/21/提升应用崩溃时的用户体验——去掉烦人的“很抱歉”提示框/","excerpt":"","text":"好久不见了。最近，博主一直在忙着搞建站的事情，也有一段时间没有更新博客了，很抱歉。同时，希望朋友们访问我的主站，加收藏的就更好了，哈哈！相信很多在用或者用过Android系统的的手机的朋友都有过这样的经历：自己玩着玩着某个程序，突然屏幕一黑，然后出现一个对话框，提示很抱歉，应用程序已经停止工作。这意味着程序已然崩溃了，用户唯一要做的就是接下来重新运行这个程序，或者去干些别的。我个人推测，前者占大多数。当然，一些比较健壮的程序是一般不会出现这种情况的，但是，作为一名对用户负责的开发者，要时刻为用户着想，这就是我们今天要谈的话题——优化程序崩溃时的用户体验。我们的目标是：程序发生了异常后，自定义异常处理流程，然后自动重新启动程序。看上去貌似很复杂，其实很容易。核心在于对Application这个单例的继承。首先，在应用中写一个类，继承Application，然后在AndroidManifest.xml中注册，注册的代码可如下例： 12345678&lt;application android:name=&quot;.environment.BaseApplication&quot; android:enabled=&quot;true&quot; android:icon=&quot;@drawable/icon64&quot; android:label=&quot;@string/app_name&quot; android:persistent=&quot;true&quot; &gt; ......&lt;/application&gt; 其中，我把继承了Application的类是【包名】.environment.BaseApplication。大家可以根据自身的项目需要进行安排，不要忘了在这里注册就好。之后就是对应用中未捕获的异常做处理了。在BaseApplication中，创建一个名为CrashHandler的子类，该类实现UncaughtExceptionHandler接口，复写uncaughtException方法。在该方法中，进行相应的崩溃处理。这里我们需要重启程序，因此，该子类可以写成如下代码段所示的内容： 123456789101112// 异常处理class CrashHandler implements UncaughtExceptionHandler &#123; @Override public void uncaughtException(Thread thread, final Throwable ex) &#123; ex.printStackTrace(); Intent restartIntent = new Intent(BaseApplication.this, SplashScreen.class); restartIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(restartIntent); android.os.Process.killProcess(android.os.Process.myPid()); &#125;&#125; 这里需要注意的是，Intent对象的Flag必须包含FLAG_ACTIVITY_NEW_TASK。最后，在复写的onCreate方法中，指定异常处理的方法： 1Thread.setDefaultUncaughtExceptionHandler(crashHandler); 其中，crashHandler为CrashHandler的对象。到此，我们的程序在发生崩溃的时候就不会出现“很抱歉。。。”的对话框了，取而代之的是自动重启。当然，这只是一个治标不治本的方法，真正的解决之道依然要找到崩溃的位置，然后除掉这个Bug。最后，关于Application，我这里就不多说了，如果诸位不是很了解的话，可以看下这位兄弟的文章，会大有启发：http://blog.csdn.net/pi9nc/article/details/11200969","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.xiaowenhan.com.cn/tags/Android/"}]},{"title":"水上公园","slug":"水上公园","date":"2015-04-05T09:32:00.000Z","updated":"2019-08-28T00:27:38.018Z","comments":true,"path":"2015/04/05/水上公园/","link":"","permalink":"http://www.xiaowenhan.com.cn/2015/04/05/水上公园/","excerpt":"","text":"","categories":[{"name":"摄影作品","slug":"摄影作品","permalink":"http://www.xiaowenhan.com.cn/categories/摄影作品/"}],"tags":[{"name":"随手拍","slug":"随手拍","permalink":"http://www.xiaowenhan.com.cn/tags/随手拍/"}]},{"title":"轻松使用Github搭建个人网站","slug":"轻松使用Github搭建个人网站","date":"2015-03-08T04:40:43.000Z","updated":"2019-08-01T22:23:03.830Z","comments":true,"path":"2015/03/08/轻松使用Github搭建个人网站/","link":"","permalink":"http://www.xiaowenhan.com.cn/2015/03/08/轻松使用Github搭建个人网站/","excerpt":"","text":"今天我们来谈一个有关建站的话题。众所周知，Github有着程序员间的Facebook之称，很多知名的项目都是利用其公共Git服务进行开源，以供全球爱好者共享。Git的版本控制机制给我们提供了完善的版本管理功能，既能够团队协作，多地工作；又能在任何时间回滚到之前的任何版本，起到良好的备份作用。因此，在其上面搭建个人网站就变得很合适了。和传统的个人博客系统不同，传统的个人博客只能提供博文的发表、评论等等，而在Github上面建站，就好比一幅油画的白纸，很纯净，很自由，人们可以自定义上面的内容，尽情挥洒自己的创意。下面我们就一起体验建站之旅！Github地址：https://github.com/Github Windows版客户端：https://windows.github.com/首先要有一个Github账户，这个是前提。注册流程就不多说了，打开上面的地址，应该能找到注册入口。创建好用户后登录，然后创建一个新的库，如下图： 在创建新库的网页中，填写库名。名称必须为：username.github.io。例如，我的是XiaoWenHan.github.io。 通常情况下，不会出现上图中红色的部分不会变红。我这里变为红色是因为之前创建过了，因为重名，所以有错误提示。创建好之后，将其Clone到本地。可以通过上面提到过的客户端，如果你使用的是比Windows 7 还要低的Windows 版本，就需要使用命令行或其他的工具了，比如SourceTree。下面尝试建立一个index.html，在Clone出来的本地目录下。比如，可以写一段Hello World。然后保存，上传。上传成功后，打开浏览器，在地址栏处输入你的username.github.io。不出意外的话，应该能看到HelloWorld了。到此，白纸已经准备好。各位读者，动手实践起来吧！","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://www.xiaowenhan.com.cn/tags/Web/"}]},{"title":"IntelliJ IDEA 14 值得你弃用Eclipse的IDE神器","slug":"IntelliJ IDEA 14 值得你弃用Eclipse的IDE神器","date":"2014-11-06T11:42:33.000Z","updated":"2019-08-01T22:23:03.814Z","comments":true,"path":"2014/11/06/IntelliJ IDEA 14 值得你弃用Eclipse的IDE神器/","link":"","permalink":"http://www.xiaowenhan.com.cn/2014/11/06/IntelliJ IDEA 14 值得你弃用Eclipse的IDE神器/","excerpt":"","text":"今天看新闻，发现IntelliJ IDEA版本出了14，本着生命在于折腾的原则，下载并安装。当然，是开玩笑的啦！作为比较资深的Android开发者，相信朋友们不会不知道Android Studio这个软件。它就是基于IntelliJ IDEA（以下简称IDEA），所以借着新版本的发布，看看最原始的IDEA是个什么模样。注：大家一定要有信心，这款IDE我上手的时间仅仅用了2个小时不到，个人感觉还是比较适合我的。如果花上两个小时能够提高日后的编码效率，还是很值得的。IDEA分为两大版本，Ultimate（付费）和Community（免费）。大家可以搜索一下，他们的差距还是相当大的，主要区别在于对Web开发的支持。虽然我只是在Android平台上面开发，但是谁又说得准会不会写个JSP之类的，万一要写了呢？所以我使用了功能比较全面的Ultimate（收费软件在我国情况……大家了解的，可以去下载相关工具）。不出意外的话，首次运行会让用户选择使用的插件，默认是全开，一路下一步后显示下面的界面： 这里大家明确一下概念，往常在Eclipse中，有个“Workspace”的概念，我们会把很多项目放在一个工作空间中。到了idea中，完全不一样了。它的做法是，一个Project对应一个Module，一个Module对应我们的一个项目。但是不推荐一个Project包含多个Module，因为默认情况下输出目录之类的文件会放在一起，这也是官方不建议的。简而言之，就是一个Project对应一个项目，没有Workspace的概念。下面我们创建android应用程序，在此之前要创建一个Project，类型为Android。 大家注意看左边的类型，免费版会少很多，真的是很多。所以再次提醒一下，防患于未然，万一要用呢。下一步后和Eclipse里面创建项目大体相当，不再多说。 下一屏幕我们需要指定一下使用的JDK和SAndroid SDK版本，注意这里需要选择兼容的最低版本。单击“New…”之后，我们依次进行选择： 上图中，最后一项是运行选项，我们保持默认（运行时选择要运行该应用的设备）。完成后需要一段时间的等待，然后我们就可以顺利进入工作环境了。 我们可以发现，界面整体感觉还是很清晰、简洁的。要运行HelloWorld，需要Shift+F10即可。此外，对于Android的布局，有了实时预览功能： 这一点在Eclipse上面是不太好实现的，起码我没有找到这个功能，而这一功能可以说是广大Android开发者的福音。不仅如此，对于不建议使用的控件，在设计视图中也有明确的提示： 另外，诸位如果使用过最新版本的Eclipse Luna的话，可以发现有全黑主题了，但个人感觉Idea的全黑主题更好一些。这个大家可以从File-&gt;Settings-&gt;Appearance % Behavior-&gt;Appearance中选择Theme为Darcula。另外，还支持全屏显示（View-&gt;Enter Full Screen），这样一来，全屏都会是暗色系。 以上给广大开发者，尤其是Android开发者一个IDE的介绍，上手不难。用久了Eclipse后，换一个风格迥异的IDE也是一个不错的选择。最后希望上述内容能够提供一些比较实用的参考价值。","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.xiaowenhan.com.cn/tags/Java/"}]},{"title":"Android 5.0(L) ToolBar(替代ActionBar) 实战（四）","slug":"Android 5.0(L) ToolBar(替代ActionBar) 实战（四）","date":"2014-11-05T08:30:22.000Z","updated":"2019-08-01T22:23:03.812Z","comments":true,"path":"2014/11/05/Android 5.0(L) ToolBar(替代ActionBar) 实战（四）/","link":"","permalink":"http://www.xiaowenhan.com.cn/2014/11/05/Android 5.0(L) ToolBar(替代ActionBar) 实战（四）/","excerpt":"","text":"休息了三天后，我又回来了，我们继续讨论Toolbar。如果此前你是跟着连载一步一步走下来的，那么你应该会注意到MainActivity是一直在报警告的。因为其中我们声明了toolbar对象，但是一直没有使用。如果要实现菜单功能的话，就要使用了。结合Toolbar使用菜单还是很容易的。只需在MainActivity中重写onCreateOptionsMenu()和onOptionsItemSelected()就可以了。这种方法已经有着悠久的历史，这里就不再多说了。回忆一下ActionBar，此前的ActionBar在实现菜单时，如果遇到虚拟按键的机器，会在Activity的右上角显示菜单。如果遇到实体按键的机器，则不会，用户需要手动去触摸菜单键才能激活菜单。这其实是不太合理的，作为用户，很有可能不知道应用中还有菜单。因此，在Toolbar中，这个问题得到了很好的修复。效果就是，无论是否存在实体按键，右上角都会显示菜单，而要实现这一效果也是及其容易的，只需要下面的一句话： 1setSupportActionBar(toolbar); 下面放上效果图： 细心的朋友可以发现，上方的Toolbar已经改变了样式，那么它又是如何实现的呢？这里有两种方法： 在每个具有Toolbar的布局文件中定义风格； 在AndroidManifest中指向统一的应用主题样式。 前者不必多说，只需要在布局文件中指定特定字段的值就好。这里详细说下后者。首先我们在布局文件中，除了Toolbar的位置、标题文本和ID外，不要给定任何其他的值，比如： 12345&lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/demo_toolbar&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; app:title=&quot;@string/hello_world&quot; /&gt; 然后，在values文件夹中创建theme.xml，在其中定义主题风格，下面列出这段程序清单： 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!-- 默认的蓝色风格 --&gt; &lt;style name=&quot;DefaultBlueTheme&quot; parent=&quot;@style/Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;!-- Toolbar风格 --&gt; &lt;item name=&quot;toolbarStyle&quot;&gt;@style/DefaultBlueToolbar&lt;/item&gt; &lt;/style&gt; &lt;!-- 默认的Toolbar样式 --&gt; &lt;style name=&quot;DefaultBlueToolbar&quot; parent=&quot;@style/Widget.AppCompat.Toolbar&quot;&gt; &lt;item name=&quot;android:background&quot;&gt;@color/default_blue&lt;/item&gt; &lt;item name=&quot;titleTextAppearance&quot;&gt;@style/ToolBarTitleTextStyle&lt;/item&gt; &lt;/style&gt; &lt;/resources&gt; 引用的颜色值如下，在color.xml中定义： 12&lt;color name=&quot;default_blue&quot;&gt;#33B5E5&lt;/color&gt;&lt;color name=&quot;default_white&quot;&gt;#FFFFFF&lt;/color&gt; 这样就实现了上图的效果。","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.xiaowenhan.com.cn/tags/Android/"}]},{"title":"Android 5.0(L) ToolBar(替代ActionBar) 实战（三）","slug":"Android 5.0(L) ToolBar(替代ActionBar) 实战（三）","date":"2014-11-01T06:35:44.000Z","updated":"2019-08-01T22:23:03.811Z","comments":true,"path":"2014/11/01/Android 5.0(L) ToolBar(替代ActionBar) 实战（三）/","link":"","permalink":"http://www.xiaowenhan.com.cn/2014/11/01/Android 5.0(L) ToolBar(替代ActionBar) 实战（三）/","excerpt":"","text":"《代码大全》一书中提到：当我们编程时，不要简单停留在“在一种编程语言上进行编程”，而是要“深入一种语言”编程。在前面两篇文章中，虽然初步实现了ViewPager+Tab的布局，但实际上还是有一些不足的。让我们把目光锁定在Tab： 可以发现，3个Tab加一起的宽度并没有填充屏幕整个宽度。实际上，Google这样的设计是为了应对多Tab的情形，当Tab总宽度超出屏幕宽度的时候，用户可以简单地通过滑动Tab看到后面未显示出来的Tab。这种情况其实还是比较多见的，比如众多的新闻阅读客户端和Google原生应用等等。但是如果我们只有三个Tab，甚至只有两个Tab，想让整个Tab的宽度等于屏幕宽度，该如何做呢？第一反应自然是要略微折腾一下SlidingTabLayout.java的源码了。经过研究发现，实际上如上图顶部Tab的实现通过HorizontalScrollView，然后add了一个又一个的view，这个View就是每个Tab的标题，而整个SlidingTabLayout是继承了HorizontalScrollView。接下来的思路就很清晰了：首先获取屏幕的总宽度，然后传给SlidingTabLayout对象，在其类内部对每个Tab所占的宽度进行计算和分配，最后将每个Tab标题的视图add到HorizontalScrollView就OK了。首先获取屏幕的宽度。这一操作我们在MainActivity中进行，下面列出这一段程序清单： 1234// 获取屏幕宽度private int caculateScreenX() &#123; return getResources().getDisplayMetrics().widthPixels;&#125; 获取到屏幕宽度之后，接下来就是把这个值传递给SlidingTabLayout。回顾一下用法，上一篇文章里面提到，我们在添加Tab导航栏的时候，仅仅是实例化了SlidingTabLayout的对象，然后调用了setViewPager()方法而已。那么，我们不妨在该方法上面添加一个参数，用来传递屏幕宽度。当然，我们需要在SlidingTabLayout中声明一个全局的int变量，用来存放每个Tab的宽度值： 123456789public void setViewPager(ViewPager viewPager, int screenX) &#123; this.screenX = screenX / viewPager.viewPager.getAdapter().getCount(); mTabStrip.removeAllViews(); mViewPager = viewPager; if (viewPager != null) &#123; viewPager.setOnPageChangeListener(new InternalViewPagerListener()); populateTabStrip(); &#125;&#125; 跟随该方法，找到populateTabStrip()方法，可以看到其中通过一个for循环以此添加了各个Tab视图。而每个Tab视图均通过createDefaultTabView()方法创建，因此该方法最为关键。找到这个方法之后我们发现，每个Tab的标题View实际上是TextView，那么我们只需将每个TextView的宽度制定为刚刚计算出来的screenX（每个Tab的宽度）即可。具体可参看下面的代码清单： 1234567891011121314151617181920212223242526272829protected TextView createDefaultTabView(Context context) &#123; TextView textView = new TextView(context); textView.setGravity(Gravity.CENTER); textView.setTextSize(TypedValue.COMPLEX_UNIT_SP, TAB_VIEW_TEXT_SIZE_SP); textView.setTypeface(Typeface.DEFAULT_BOLD); textView.setWidth(screenX); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123; // If we&apos;re running on Honeycomb or newer, then we can use the // Theme&apos;s // selectableItemBackground to ensure that the View has a pressed // state TypedValue outValue = new TypedValue(); getContext().getTheme().resolveAttribute( android.R.attr.selectableItemBackground, outValue, true); textView.setBackgroundResource(outValue.resourceId); &#125; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123; // If we&apos;re running on ICS or newer, enable all-caps to match the // Action Bar tab style textView.setAllCaps(true); &#125; int padding = (int) (TAB_VIEW_PADDING_DIPS * getResources() .getDisplayMetrics().density); textView.setPadding(padding, padding, padding, padding); return textView;&#125; 最后，我们修改MainActivity，把计算好的屏幕宽度传给SlidingTabLayout，Ctrl+F11看看效果吧！ 不出意外的话，看到上图就说明已经成功了！下面放上整个SlidingTabLayout修改后的类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343/* * Copyright (C) 2013 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.xwh.toolbardemo.view; import android.annotation.SuppressLint;import android.content.Context;import android.graphics.Typeface;import android.os.Build;import android.support.v4.view.PagerAdapter;import android.support.v4.view.ViewPager;import android.util.AttributeSet;import android.util.Log;import android.util.TypedValue;import android.view.Gravity;import android.view.LayoutInflater;import android.view.View;import android.widget.HorizontalScrollView;import android.widget.TextView; /** * To be used with ViewPager to provide a tab indicator component which give * constant feedback as to the user&apos;s scroll progress. * &lt;p&gt; * To use the component, simply add it to your view hierarchy. Then in your * &#123;@link android.app.Activity&#125; or &#123;@link android.support.v4.app.Fragment&#125; call * &#123;@link #setViewPager(ViewPager)&#125; providing it the ViewPager this layout is * being used for. * &lt;p&gt; * The colors can be customized in two ways. The first and simplest is to * provide an array of colors via &#123;@link #setSelectedIndicatorColors(int...)&#125; * and &#123;@link #setDividerColors(int...)&#125;. The alternative is via the * &#123;@link TabColorizer&#125; interface which provides you complete control over which * color is used for any individual position. * &lt;p&gt; * The views used as tabs can be customized by calling * &#123;@link #setCustomTabView(int, int)&#125;, providing the layout ID of your custom * layout. */public class SlidingTabLayout extends HorizontalScrollView &#123; /** * Allows complete control over the colors drawn in the tab layout. Set with * &#123;@link #setCustomTabColorizer(TabColorizer)&#125;. */ public interface TabColorizer &#123; /** * @return return the color of the indicator used when &#123;@code position&#125; * is selected. */ int getIndicatorColor(int position); /** * @return return the color of the divider drawn to the right of * &#123;@code position&#125;. */ int getDividerColor(int position); &#125; private static final int TITLE_OFFSET_DIPS = 24; private static final int TAB_VIEW_PADDING_DIPS = 16; private static final int TAB_VIEW_TEXT_SIZE_SP = 12; private int mTitleOffset; private int mTabViewLayoutId; private int mTabViewTextViewId; private ViewPager mViewPager; private ViewPager.OnPageChangeListener mViewPagerPageChangeListener; private final SlidingTabStrip mTabStrip; private int screenX; public SlidingTabLayout(Context context) &#123; this(context, null); &#125; public SlidingTabLayout(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public SlidingTabLayout(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); // Disable the Scroll Bar setHorizontalScrollBarEnabled(false); // Make sure that the Tab Strips fills this View setFillViewport(true); mTitleOffset = (int) (TITLE_OFFSET_DIPS * getResources() .getDisplayMetrics().density); mTabStrip = new SlidingTabStrip(context); addView(mTabStrip, LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT); &#125; /** * Set the custom &#123;@link TabColorizer&#125; to be used. * * If you only require simple custmisation then you can use * &#123;@link #setSelectedIndicatorColors(int...)&#125; and * &#123;@link #setDividerColors(int...)&#125; to achieve similar effects. */ public void setCustomTabColorizer(TabColorizer tabColorizer) &#123; mTabStrip.setCustomTabColorizer(tabColorizer); &#125; /** * Sets the colors to be used for indicating the selected tab. These colors * are treated as a circular array. Providing one color will mean that all * tabs are indicated with the same color. */ public void setSelectedIndicatorColors(int... colors) &#123; mTabStrip.setSelectedIndicatorColors(colors); &#125; /** * Sets the colors to be used for tab dividers. These colors are treated as * a circular array. Providing one color will mean that all tabs are * indicated with the same color. */ public void setDividerColors(int... colors) &#123; mTabStrip.setDividerColors(colors); &#125; /** * Set the &#123;@link ViewPager.OnPageChangeListener&#125;. When using * &#123;@link SlidingTabLayout&#125; you are required to set any * &#123;@link ViewPager.OnPageChangeListener&#125; through this method. This is so * that the layout can update it&apos;s scroll position correctly. * * @see ViewPager#setOnPageChangeListener(ViewPager.OnPageChangeListener) */ public void setOnPageChangeListener(ViewPager.OnPageChangeListener listener) &#123; mViewPagerPageChangeListener = listener; &#125; /** * Set the custom layout to be inflated for the tab views. * * @param layoutResId * Layout id to be inflated * @param textViewId * id of the &#123;@link TextView&#125; in the inflated view */ public void setCustomTabView(int layoutResId, int textViewId) &#123; mTabViewLayoutId = layoutResId; mTabViewTextViewId = textViewId; &#125; /** * Sets the associated view pager. Note that the assumption here is that the * pager content (number of tabs and tab titles) does not change after this * call has been made. */ public void setViewPager(ViewPager viewPager, int screenX) &#123; this.screenX = (screenX / viewPager.getAdapter().getCount()); mTabStrip.removeAllViews(); mViewPager = viewPager; if (viewPager != null) &#123; viewPager.setOnPageChangeListener(new InternalViewPagerListener()); populateTabStrip(); &#125; &#125; /** * Create a default view to be used for tabs. This is called if a custom tab * view is not set via &#123;@link #setCustomTabView(int, int)&#125;. */ @SuppressLint(&quot;NewApi&quot;) protected TextView createDefaultTabView(Context context) &#123; TextView textView = new TextView(context); textView.setGravity(Gravity.CENTER); textView.setTextSize(TypedValue.COMPLEX_UNIT_SP, TAB_VIEW_TEXT_SIZE_SP); textView.setTypeface(Typeface.DEFAULT_BOLD); textView.setWidth(screenX); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123; // If we&apos;re running on Honeycomb or newer, then we can use the // Theme&apos;s // selectableItemBackground to ensure that the View has a pressed // state TypedValue outValue = new TypedValue(); getContext().getTheme().resolveAttribute( android.R.attr.selectableItemBackground, outValue, true); textView.setBackgroundResource(outValue.resourceId); &#125; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123; // If we&apos;re running on ICS or newer, enable all-caps to match the // Action Bar tab style textView.setAllCaps(true); &#125; int padding = (int) (TAB_VIEW_PADDING_DIPS * getResources() .getDisplayMetrics().density); textView.setPadding(padding, padding, padding, padding); return textView; &#125; private void populateTabStrip() &#123; final PagerAdapter adapter = mViewPager.getAdapter(); final View.OnClickListener tabClickListener = new TabClickListener(); for (int i = 0; i &lt; adapter.getCount(); i++) &#123; View tabView = null; TextView tabTitleView = null; if (mTabViewLayoutId != 0) &#123; // If there is a custom tab view layout id set, try and inflate // it tabView = LayoutInflater.from(getContext()).inflate( mTabViewLayoutId, mTabStrip, false); tabTitleView = (TextView) tabView .findViewById(mTabViewTextViewId); &#125; if (tabView == null) &#123; tabView = createDefaultTabView(getContext()); &#125; if (tabTitleView == null &amp;&amp; TextView.class.isInstance(tabView)) &#123; tabTitleView = (TextView) tabView; &#125; tabTitleView.setText(adapter.getPageTitle(i)); tabView.setOnClickListener(tabClickListener); mTabStrip.addView(tabView); &#125; &#125; @Override protected void onAttachedToWindow() &#123; super.onAttachedToWindow(); if (mViewPager != null) &#123; scrollToTab(mViewPager.getCurrentItem(), 0); &#125; &#125; private void scrollToTab(int tabIndex, int positionOffset) &#123; final int tabStripChildCount = mTabStrip.getChildCount(); if (tabStripChildCount == 0 || tabIndex &lt; 0 || tabIndex &gt;= tabStripChildCount) &#123; return; &#125; View selectedChild = mTabStrip.getChildAt(tabIndex); if (selectedChild != null) &#123; int targetScrollX = selectedChild.getLeft() + positionOffset; if (tabIndex &gt; 0 || positionOffset &gt; 0) &#123; // If we&apos;re not at the first child and are mid-scroll, make sure // we obey the offset targetScrollX -= mTitleOffset; &#125; scrollTo(targetScrollX, 0); &#125; &#125; private class InternalViewPagerListener implements ViewPager.OnPageChangeListener &#123; private int mScrollState; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; int tabStripChildCount = mTabStrip.getChildCount(); if ((tabStripChildCount == 0) || (position &lt; 0) || (position &gt;= tabStripChildCount)) &#123; return; &#125; mTabStrip.onViewPagerPageChanged(position, positionOffset); View selectedTitle = mTabStrip.getChildAt(position); int extraOffset = (selectedTitle != null) ? (int) (positionOffset * selectedTitle .getWidth()) : 0; scrollToTab(position, extraOffset); if (mViewPagerPageChangeListener != null) &#123; mViewPagerPageChangeListener.onPageScrolled(position, positionOffset, positionOffsetPixels); &#125; &#125; @Override public void onPageScrollStateChanged(int state) &#123; mScrollState = state; if (mViewPagerPageChangeListener != null) &#123; mViewPagerPageChangeListener.onPageScrollStateChanged(state); &#125; &#125; @Override public void onPageSelected(int position) &#123; if (mScrollState == ViewPager.SCROLL_STATE_IDLE) &#123; mTabStrip.onViewPagerPageChanged(position, 0f); scrollToTab(position, 0); &#125; if (mViewPagerPageChangeListener != null) &#123; mViewPagerPageChangeListener.onPageSelected(position); &#125; &#125; &#125; private class TabClickListener implements View.OnClickListener &#123; @Override public void onClick(View v) &#123; for (int i = 0; i &lt; mTabStrip.getChildCount(); i++) &#123; if (v == mTabStrip.getChildAt(i)) &#123; mViewPager.setCurrentItem(i); return; &#125; &#125; &#125; &#125; &#125; 这一篇到此结束。下一篇将讨论菜单的添加和关于ToolBar的更多精彩用法。","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.xiaowenhan.com.cn/tags/Android/"}]},{"title":"Android 5.0(L) ToolBar(替代ActionBar) 实战（二）","slug":"Android 5.0(L) ToolBar(替代ActionBar) 实战（二）","date":"2014-10-31T09:16:27.000Z","updated":"2019-08-01T22:23:03.812Z","comments":true,"path":"2014/10/31/Android 5.0(L) ToolBar(替代ActionBar) 实战（二）/","link":"","permalink":"http://www.xiaowenhan.com.cn/2014/10/31/Android 5.0(L) ToolBar(替代ActionBar) 实战（二）/","excerpt":"","text":"上一次我们说到ToolBar的创建，这次我们来讨论一下ToolBar结合ViewPager实现类似微信的左右滑屏多个界面的效果。要实现滑屏，首先我们要到Android开发者官网去下载一个示例代码，它封装了Viewpager和Tab配合切换页卡的方法。当然，我们也可以自己来实现，为了节约时间成本，就直接拿来用了。如果在官网找不到或者无奈被墙，可以到这里下载：http://download.csdn.net/detail/wh1990xiao2005/8105345 把下载好的工具类复制到项目指定的包内，我是在之前的项目中创建了view专用的包，并将这两个类复制了进去。 这里要注意，复制进去之后有可能会报错，因为包名不符，只需把package包名修改为自己的类所在包名即可。打开布局文件，在上次Toolbar的声明下面添加SlidingTabLayout和ViewPager控件，下面放上示例： 12345678910111213141516171819202122232425262728&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; xmlns:app=&quot;http://schemas.android.com/apk/res/com.xwh.toolbardemo&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;com.xwh.toolbardemo.MainActivity&quot; &gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/demo_toolbar&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;?attr/colorPrimary&quot; android:minHeight=&quot;?attr/actionBarSize&quot; app:title=&quot;@string/hello_world&quot; /&gt; &lt;com.xwh.toolbardemo.view.SlidingTabLayout android:id=&quot;@+id/demo_tab&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_below=&quot;@+id/demo_toolbar&quot; /&gt; &lt;android.support.v4.view.ViewPager android:id=&quot;@+id/demo_vp&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:layout_below=&quot;@+id/demo_tab&quot; /&gt; &lt;/RelativeLayout&gt; ToolBar不用多说，SlidingTabLayout实际上是上方的Tab视图，而ViewPager是页卡的容器，而页卡是稍后添加的多个Fragment。下面我们来写三个Layout的xml文件和相关的三个Fragment的Java代码，分别代表三个页卡。 第一个页卡随意放置一个图片，代码如下： 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;ImageView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:contentDescription=&quot;@string/app_name&quot; android:src=&quot;@drawable/ic_launcher&quot; &gt; &lt;/ImageView&gt; 第二个页卡放置一个模拟时钟，代码如下： 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;AnalogClock xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt;&lt;/AnalogClock&gt; 第三个页卡放置一个数字时钟，代码如下： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;DigitalClock xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center&quot; android:textSize=&quot;40sp&quot; &gt;&lt;/DigitalClock&gt; 相应的，创建三个Fragment的Java代码文件，这里只列出其中一个文件的程序清单，另外两个按此自行编写： 12345678910111213141516package com.xwh.toolbardemo.fragment; import com.xwh.toolbardemo.R;import android.os.Bundle;import android.support.v4.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup; public class Fragment_Tab_1 extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; return inflater.inflate(R.layout.fragment_tab_1, container, false); &#125;&#125; 下面我们还需一个适配器（Adapter），用于将这三个Fragment适配到ViewPager之上，下面列出适配器的Java程序代码清单： 12345678910111213141516171819202122232425262728293031package com.xwh.toolbardemo.adapter; import java.util.ArrayList;import android.support.v4.app.Fragment;import android.support.v4.app.FragmentManager;import android.support.v4.app.FragmentPagerAdapter; public class ViewPager_Adapter extends FragmentPagerAdapter &#123; private ArrayList&lt;Fragment&gt; fragments; public ViewPager_Adapter(FragmentManager fm, ArrayList&lt;Fragment&gt; fragments) &#123; super(fm); this.fragments = fragments; &#125; @Override public Fragment getItem(int pos) &#123; return fragments.get(pos); &#125; @Override public int getCount() &#123; return fragments.size(); &#125; @Override public CharSequence getPageTitle(int position) &#123; return &quot;Tab_&quot; + position; &#125;&#125; 这里需要注意：下方的getPageTitle()方法是必要的，他用于相应Tab名称的显示。到此，我的程序架构如下图所示： 接下来，我们将三个Fragment通过Adapter适配到ViewPager上，这一过程，我们只对MainActivity做操作。完整代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.xwh.toolbardemo; import java.util.ArrayList; import com.xwh.toolbardemo.adapter.ViewPager_Adapter;import com.xwh.toolbardemo.fragment.Fragment_Tab_1;import com.xwh.toolbardemo.fragment.Fragment_Tab_2;import com.xwh.toolbardemo.fragment.Fragment_Tab_3;import com.xwh.toolbardemo.view.SlidingTabLayout; import android.support.v4.app.Fragment;import android.support.v4.view.ViewPager;import android.support.v7.app.ActionBarActivity;import android.support.v7.widget.Toolbar;import android.os.Bundle; public class MainActivity extends ActionBarActivity &#123; private Toolbar toolbar; private SlidingTabLayout slidingTabLayout; private ViewPager viewPager; private ArrayList&lt;Fragment&gt; fragments; private ViewPager_Adapter viewPager_Adapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findView(); &#125; // 初始化控件 private void findView() &#123; // 实例化控件 toolbar = (Toolbar) findViewById(R.id.demo_toolbar); slidingTabLayout = (SlidingTabLayout) findViewById(R.id.demo_tab); viewPager = (ViewPager) findViewById(R.id.demo_vp); // 设置ViewPager fragments = new ArrayList&lt;Fragment&gt;(); fragments.add(new Fragment_Tab_1()); fragments.add(new Fragment_Tab_2()); fragments.add(new Fragment_Tab_3()); viewPager_Adapter = new ViewPager_Adapter(getSupportFragmentManager(), fragments); viewPager.setOffscreenPageLimit(fragments.size()); viewPager.setAdapter(viewPager_Adapter); // 设置SlidingTab slidingTabLayout.setViewPager(viewPager); &#125;&#125; 到此，我们可以Ctrl+F11运行看效果了。如果不出意外的话，会是下面的效果： 仔细观察可以发现，ToolBar比ActionBar更好的一点在于上方Tab的选中状态，是根据滑动程度来的，而传统的ActionBar略显生硬。第二篇Toolbar文章到此为止，在下一篇里，我们将集中介绍Menu的使用以及关于Toolbar的更多功能，欢迎关注！","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.xiaowenhan.com.cn/tags/Android/"}]},{"title":"Android 5.0(L) ToolBar(替代ActionBar) 实战（一）","slug":"Android 5.0(L) ToolBar(替代ActionBar) 实战（一）","date":"2014-10-30T11:32:59.000Z","updated":"2019-08-01T22:23:03.811Z","comments":true,"path":"2014/10/30/Android 5.0(L) ToolBar(替代ActionBar) 实战（一）/","link":"","permalink":"http://www.xiaowenhan.com.cn/2014/10/30/Android 5.0(L) ToolBar(替代ActionBar) 实战（一）/","excerpt":"","text":"Android 5.0 SDK 在上周悄然发布了，由于更新了Appcombat V7库，将Google在IO 2014时提到的Material Design的UI界面元素带了进来。从此，开发者可以创建基于Material Design界面设计的APP了。诚然，在更新了新版SDK并引入新的Appcombat库后，发现之前的ActionBar的很多方法已经标记为不建议（Deprecated）的了。经过反复摸索，得知需要用ToolBar来代替古老的ActionBar。那么ToolBar与传统ActionBar相比，有何优越性呢？简单来说：多样、自由。下面来一起看看ToolBar的使用。首先，我们来新建一个项目 为了更好的兼容之前的版本，因此依旧将最低兼容的Android版本设置为2.2。其他保持默认，一路下一步，然后完成。为了方便开发者，在新建项目的时候Eclipse依然是自动引入了Appcombar库。如果这个时候代码报错，则要看看这个库的引入状况，并且检查一下是否作为Library被导入到新的项目中了。一切就绪的话，进入AndroidMenifest.xml，将ActionBar彻底废掉。废掉老旧的ActionBar的方法十分简单，将application下android:theme元素替换为：@style/Theme.AppCompat.NoActionBar就可以了。当然，下面的activity中切记不要再使用带有ActionBar的主题样式了，否则会报错的。另外，android:label对于Toolbar而言，也没有必要存在了，当然，即使存在这个字段是不会报错的。下面放上整个xml的例子： 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.xwh.toolbardemo&quot; android:versionCode=&quot;1&quot; android:versionName=&quot;1.0&quot; &gt; &lt;uses-sdk android:minSdkVersion=&quot;8&quot; android:targetSdkVersion=&quot;21&quot; /&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@drawable/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:theme=&quot;@style/Theme.AppCompat.NoActionBar&quot; &gt; &lt;activity android:name=&quot;.MainActivity&quot; android:label=&quot;@string/app_name&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt; &lt;/manifest&gt; 下面我们来到MainActivity的布局文件：activity_main.xml。如果你的SDK已经更新为最新而且此项目也是配置为5.0的编译状态下时，在布局预览视图中将会如下所示： 可以看到，预览窗格中，已经完全是5.0的UI设计风格了。至于为什么是深色的主题，是因为之前在AndroidMenifest.xml中设置了Theme.AppCompat.NoActionBar。换言之，如果我们设置成Theme.AppCompat.Light.NoActionBar，则会呈现浅色的主题。 下面切换到代码视图。对于ActionBar，我们无需关心在xml布局中的位置，只需要在Java代码中进行设置即可。而对于ToolBar，是要求我们自己写到Layout（布局xml）中的。这也就意味着它可以出现在任意一个我们希望它出现的位置，甚至能够同时存在多个ToolBar，并且互不干扰（参考多个ImageView，或者多个TextView等等）。我们可以通过创建android.support.v7.widget.Toolbar控件来显示自定义的Toolbar，参考下面的代码： 12345678910111213141516171819202122&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; xmlns:app=&quot;http://schemas.android.com/apk/res/com.xwh.toolbardemo&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;com.xwh.toolbardemo.MainActivity&quot; &gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/demo_toolbar&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;?attr/colorPrimary&quot; android:minHeight=&quot;?attr/actionBarSize&quot; app:title=&quot;@string/hello_world&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_below=&quot;@+id/demo_toolbar&quot; android:text=&quot;@string/hello_world&quot; /&gt; &lt;/RelativeLayout&gt; 关于Toolbar的可用属性，这里不多做赘述，大家可以去安卓开发者官网自行搜索API。到此，这个Toolbar已经可以正常显示了，并且其标题为“Hello World”。而且诸位可以发现，从Toolbar的创建到显示，我们还没有写过一句Java代码。下面放上运行效果截图： 在下一篇博文中，我们将集中介绍如何使用Toolbar，结合ViewPager，实现类似微信的滑动切换多视图效果。","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.xiaowenhan.com.cn/tags/Android/"}]},{"title":"解决Android录音iOS兼容性问题","slug":"解决Android录音iOS兼容性问题","date":"2014-09-11T02:50:46.000Z","updated":"2019-08-01T22:23:03.829Z","comments":true,"path":"2014/09/11/解决Android录音iOS兼容性问题/","link":"","permalink":"http://www.xiaowenhan.com.cn/2014/09/11/解决Android录音iOS兼容性问题/","excerpt":"","text":"最近在开发过程中遇到问题，Android客户端录制的AMR_NB编码的文件在iOS设备商播放失败。经过反复百度谷歌，得知iOS需要借助AmrToWave的转换，这无疑给iOS开发者带来不便。随即想到更改录音时的参数，经过测试，使用AAC可以解决该问题，而且Android本身使用MediaPlayer类播放即可，减轻了iOS开发者的工作量。录音示例部分代码如下： 12345MediaRecoder mediaRecorder = new MediaRecorder();mediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);mediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);mediaRecorder.setOutputFile(APPCFG.VOICE_FILE);mediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC); 希望上面的代码片对你有帮助。","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.xiaowenhan.com.cn/tags/Android/"}]},{"title":"Android 重写ImageView实现图片手势功能","slug":"Android 重写ImageView实现图片手势功能","date":"2014-08-05T05:22:43.000Z","updated":"2019-08-01T22:23:03.813Z","comments":true,"path":"2014/08/05/Android 重写ImageView实现图片手势功能/","link":"","permalink":"http://www.xiaowenhan.com.cn/2014/08/05/Android 重写ImageView实现图片手势功能/","excerpt":"","text":"通过这个XImageView.java类，可实现单点触摸移动，以及双指缩放图片功能。使用时，只要在布局文件中引入，并在Java代码中按照原生ImageView设置要现实的图片即可。代码如下（仅供参考）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131import android.annotation.SuppressLint;import android.content.Context;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.graphics.Canvas;import android.graphics.Matrix;import android.util.AttributeSet;import android.view.MotionEvent;import android.widget.ImageView; public class XImageView extends ImageView &#123; public static Bitmap gintama; private Matrix matrix; private float point1_old_x, point1_old_y, point1_new_x, point1_new_y, point2_old_x, point2_old_y, point2_new_x, point2_new_y, distance_old, distance_new; private float point_old_x, point_old_y, point_new_x, point_new_y; private boolean isMultiTouch = false; public XImageView(Context context, AttributeSet attrs) &#123; super(context, attrs); gintama = BitmapFactory.decodeResource(getResources(), R.drawable.ic_launcher); matrix = new Matrix(); &#125; public XImageView(Context context) &#123; super(context); gintama = BitmapFactory.decodeResource(getResources(), R.drawable.ic_launcher); matrix = new Matrix(); &#125; // 回调方法，用于画控件上的图片 @Override protected void onDraw(Canvas canvas) &#123; canvas.save(); canvas.drawBitmap(gintama, matrix, null); canvas.restore(); &#125; @SuppressLint(&quot;ClickableViewAccessibility&quot;) @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction() &amp; MotionEvent.ACTION_MASK) &#123; case MotionEvent.ACTION_DOWN: // 单点移动 按下 if (event.getPointerCount() == 1) &#123; isMultiTouch = false; point_old_x = event.getX(); point_old_y = event.getY(); &#125; break; case MotionEvent.ACTION_UP: // 单点移动 抬起 if (event.getPointerCount() == 1) &#123; isMultiTouch = false; point_old_x = point_new_x; point_old_y = point_new_y; &#125; break; case MotionEvent.ACTION_POINTER_UP: // 双点操作 抬起 if (event.getPointerCount() == 2) &#123; isMultiTouch = true; point1_old_x = point1_new_x; point1_old_y = point1_new_y; point2_old_x = point2_new_x; point2_old_y = point2_new_y; &#125; break; case MotionEvent.ACTION_POINTER_DOWN: // 双点操作 按下 if (event.getPointerCount() == 2) &#123; isMultiTouch = true; point1_old_x = event.getX(0); point1_old_y = event.getY(0); point2_old_x = event.getX(1); point2_old_y = event.getY(1); distance_old = (float) Math .sqrt(((point1_old_x - point2_old_x) * (point1_old_x - point2_old_x) + (point1_old_y - point2_old_y) * (point1_old_y - point2_old_y))); &#125; break; case MotionEvent.ACTION_MOVE: // 双点操作 移动 if (event.getPointerCount() == 2) &#123; isMultiTouch = true; point1_new_x = event.getX(0); point1_new_y = event.getY(0); point2_new_x = event.getX(1); point2_new_y = event.getY(1); pinch(); &#125; else &#123; // 单点移动 移动 if (event.getPointerCount() == 1) &#123; if (!isMultiTouch) &#123; point_new_x = event.getX(); point_new_y = event.getY(); matrix.postTranslate((point_new_x - point_old_x), (point_new_y - point_old_y)); point_old_x = point_new_x; point_old_y = point_new_y; invalidate(); &#125; &#125; &#125; break; &#125; return true; &#125; // 缩放图片方法 private void pinch() &#123; distance_new = (float) Math.sqrt(((point1_new_x - point2_new_x) * (point1_new_x - point2_new_x) + (point1_new_y - point2_new_y) * (point1_new_y - point2_new_y))); matrix.postScale((distance_new / distance_old), (distance_new / distance_old), this.getWidth() / 2, this.getTop() / 2); invalidate(); distance_old = distance_new; &#125; &#125;","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.xiaowenhan.com.cn/tags/Android/"}]},{"title":"Java 文件操作工具类（Android 适用）","slug":"Java 文件操作工具类（Android 适用）","date":"2014-07-31T06:59:06.000Z","updated":"2019-08-01T22:23:03.814Z","comments":true,"path":"2014/07/31/Java 文件操作工具类（Android 适用）/","link":"","permalink":"http://www.xiaowenhan.com.cn/2014/07/31/Java 文件操作工具类（Android 适用）/","excerpt":"","text":"该文件操作包含了文件/文件夹的创建、复制、剪切和删除操作。具体调用方法参见类方法注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStream; public class FileUtil &#123; /** * 在指定的位置创建指定的文件 * * @param filePath * 完整的文件路径 * @param mkdir * 是否创建相关的文件夹 * @throws Exception */ public static void mkFile(String filePath, boolean mkdir) throws Exception &#123; File file = new File(filePath); file.getParentFile().mkdirs(); file.createNewFile(); file = null; &#125; /** * 在指定的位置创建文件夹 * * @param dirPath * 文件夹路径 * @return 若创建成功，则返回True；反之，则返回False */ public static boolean mkDir(String dirPath) &#123; return new File(dirPath).mkdirs(); &#125; /** * 删除指定的文件 * * @param filePath * 文件路径 * * @return 若删除成功，则返回True；反之，则返回False * */ public static boolean delFile(String filePath) &#123; return new File(filePath).delete(); &#125; /** * 删除指定的文件夹 * * @param dirPath * 文件夹路径 * @param delFile * 文件夹中是否包含文件 * * @return 若删除成功，则返回True；反之，则返回False * */ public static boolean delDir(String dirPath, boolean delFile) &#123; if (delFile) &#123; File file = new File(dirPath); if (file.isFile()) &#123; return file.delete(); &#125; else if (file.isDirectory()) &#123; if (file.listFiles().length == 0) &#123; return file.delete(); &#125; else &#123; int zfiles = file.listFiles().length; File[] delfile = file.listFiles(); for (int i = 0; i &lt; zfiles; i++) &#123; if (delfile[i].isDirectory()) &#123; delDir(delfile[i].getAbsolutePath(), true); &#125; delfile[i].delete(); &#125; return file.delete(); &#125; &#125; else &#123; return false; &#125; &#125; else &#123; return new File(dirPath).delete(); &#125; &#125; /** * 复制文件/文件夹 若要进行文件夹复制，请勿将目标文件夹置于源文件夹中 * * @param source * 源文件（夹） * @param target * 目标文件（夹） * @param isFolder * 若进行文件夹复制，则为True；反之为False * @throws Exception */ public static void copy(String source, String target, boolean isFolder) throws Exception &#123; if (isFolder) &#123; (new File(target)).mkdirs(); File a = new File(source); String[] file = a.list(); File temp = null; for (int i = 0; i &lt; file.length; i++) &#123; if (source.endsWith(File.separator)) &#123; temp = new File(source + file[i]); &#125; else &#123; temp = new File(source + File.separator + file[i]); &#125; if (temp.isFile()) &#123; FileInputStream input = new FileInputStream(temp); FileOutputStream output = new FileOutputStream(target + &quot;/&quot; + (temp.getName()).toString()); byte[] b = new byte[1024]; int len; while ((len = input.read(b)) != -1) &#123; output.write(b, 0, len); &#125; output.flush(); output.close(); input.close(); &#125; if (temp.isDirectory()) &#123; copy(source + &quot;/&quot; + file[i], target + &quot;/&quot; + file[i], true); &#125; &#125; &#125; else &#123; int byteread = 0; File oldfile = new File(source); if (oldfile.exists()) &#123; InputStream inStream = new FileInputStream(source); File file = new File(target); file.getParentFile().mkdirs(); file.createNewFile(); FileOutputStream fs = new FileOutputStream(file); byte[] buffer = new byte[1024]; while ((byteread = inStream.read(buffer)) != -1) &#123; fs.write(buffer, 0, byteread); &#125; inStream.close(); fs.close(); &#125; &#125; &#125; /** * 移动指定的文件（夹）到目标文件（夹） * * @param source * 源文件（夹） * @param target * 目标文件（夹） * @param isFolder * 若为文件夹，则为True；反之为False * @return * @throws Exception */ public static boolean move(String source, String target, boolean isFolder) throws Exception &#123; copy(source, target, isFolder); if (isFolder) &#123; return delDir(source, true); &#125; else &#123; return delFile(source); &#125; &#125; &#125;","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.xiaowenhan.com.cn/tags/Java/"}]},{"title":"微信插件开发手记-聊天界面传送任意类型文件","slug":"微信插件开发手记-聊天界面传送任意类型文件","date":"2014-07-03T11:32:42.000Z","updated":"2019-08-01T22:23:03.819Z","comments":true,"path":"2014/07/03/微信插件开发手记-聊天界面传送任意类型文件/","link":"","permalink":"http://www.xiaowenhan.com.cn/2014/07/03/微信插件开发手记-聊天界面传送任意类型文件/","excerpt":"","text":"项目完整源码请见：https://github.com/XiaoWenHan/Anytransforwechat 目的好，这是整篇文章唯一一个看似废话的部分，毕竟它才是整个项目得以完成并分享的源动力。最初的想法是由于目前微信移动客户端无法给好友发送文件，除了图片、语音、视频。当然，询问了很多人之后答案是Web版可以，可是每次传文件都要去Web客户端也太麻烦了一些，于是萌发了要做一个文件传送的微信插件的想法，暂定为《微信随心传 1.0 Beta》。功能很明确，就是向好友分享文件，其他的功能就没有了。虽然功能很单一，但希望它能为更多的人提供方便。 微信审核这个是前提，只有通过审核，才能得到APP_ID；只有得到APP_ID，才能进行开发，才能在微信的附件栏里成功调用这个应用。具体方法如下： 登录微信开放平台：https://open.weixin.qq.com/，注册开发者帐号； 创建一个项目，使用微信开放平台提供的签名生成工具，生成此项目的签名信息（就是Debug Key）； 在移动应用板块，按照网页上的向导创建移动应用，填上相关信息，等待审核通过（这个过程不会太慢，差不多第三天就会通过，运气好的话几个小时而已）；一旦通过审核，会有通知，在管理中心的已通过审核部分，会看到我们创建好的应用信息，我们可以通过查看详情找到开发所需的APP_ID。 搭建项目从这个部分开始，就是真正编码的过程了。 首先从官方提供的SDK Demo项目中找到libammsdk.jar，复制到我们的项目lib文件夹中，这个Jar包是实现所有功能的核心。 修改AndroidManifest.xml文件，添加一个Activity。路径固定为包名后跟”.wxapi.WXEntryActivity”。具体代码块如下： 1234&lt;activity android:name=&quot;.wxapi.WXEntryActivity&quot; android:exported=&quot;true&quot;&lt;/activity&gt; 上述两个Activity属性固定，不要做任何改变。但不妨碍继续添加属性，比如加一个”android:label=”@string/app_name””，是没有关系的； 创建第2步中被添加的Activity，该Activity必须实现IWXAPIEventHandler。这时，该类会提示我们要去Override onReq()和onResp()方法，这里我们主要是重写onReq()方法即可； 声明一个全局的IWXAPI对象的变量，在onCreate方法中进行初始化。代码块如下： 123456@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); iwxapi = WXAPIFactory.createWXAPI(WXEntryActivity.this,MainActivity.APP_ID); iwxapi.handleIntent(getIntent(), this);&#125; 注意：iwxapi为已声明但尚未初始化的变量； 在onReq回调方法里，根据微信不同的响应类型分别做操作。类型我们可以通过req.getType()得到，具体代码块如下： 123456789@Overridepublic void onReq(BaseReq req) &#123; switch (req.getType()) &#123; case ConstantsAPI.COMMAND_GETMESSAGE_FROM_WX: // 选取文件发送 case ConstantsAPI.COMMAND_SHOWMESSAGE_FROM_WX: // 打开文件 &#125;&#125; 根据注释信息在相应的位置进行相应的操作即可； 获取到文件路径后，使用下面的方法，即可发送指定的文件： 123456789WXAppExtendObject wxAppExtendObject = new WXAppExtendObject();wxAppExtendObject.filePath = sendFile.getPath();WXMediaMessage msg = new WXMediaMessage();msg.mediaObject = wxAppExtendObject;SendMessageToWX.Req req = new SendMessageToWX.Req();req.transaction = getTransaction();req.message = msg;req.scene = SendMessageToWX.Req.WXSceneSession;iwxapi.sendReq(req); 注：sendFile是File类型的变量，是要发送的文件； 找到接收到的文件的路径的方法见此： 12WXAppExtendObject wxAppExtendObject = (WXAppExtendObject) ((((ShowMessageFromWX.Req) req).message.mediaObject));String filePath = wxAppExtendObject.filePath; 到此，获取到文件路径，可以通过该路径进行自定义的操作了。特别注意，这里的文件路径通常是微信的缓存路径，因此基本上无需考虑文件重名问题了。","categories":[{"name":"编程世界","slug":"编程世界","permalink":"http://www.xiaowenhan.com.cn/categories/编程世界/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.xiaowenhan.com.cn/tags/Android/"}]},{"title":"CSDN 开博寄语","slug":"CSDN 开博寄语","date":"2014-06-27T08:08:18.000Z","updated":"2019-08-01T22:23:03.813Z","comments":true,"path":"2014/06/27/CSDN 开博寄语/","link":"","permalink":"http://www.xiaowenhan.com.cn/2014/06/27/CSDN 开博寄语/","excerpt":"","text":"终于有个时间能让自己安静一下了。2014年已经过半，下周就是7月份了。自从新浪博客转战到CSDN之后就没怎么发过博文，说的实在一点，连博客也很少上了。发几句牢骚的话，现在的人们，内心比较浮躁，能踏实下来阅读博客的人越来越少，更别提写博文了。其实这样的情况也发生在我身上，写代码的时候经常是百度谷歌，然后复制粘贴，能用了就行了，虽然很多时候很想总结一些东西，可就是懒得去写，懒得去弄。工作了也有两年了差不多，能拿出来和别人Share的东西屈指可数。另外还有对技术的选择。今天看别人在博客里面说，现在的技术门类很多，当我们看到那一扇扇敞开的技术大门时，我们不知所措；当我们踏进其中的一个的时候，又发现一眼望不到头。而且有一种被技术所束缚的感觉，觉得自己的命运会随着某一项或者某几项技术所牵连。一旦这项技术大热，自己也会变得抢手；反之，则会担心自己的未来，悔恨当初的选择。这无疑体现了面对选择的迷茫和对自己能力的不自信，尽管从理论上讲，高级程序语言是有共性的，但还是会有这种担心。自从年初进了一家比较有年头的国企之后，人就变得更懒了。总想学点什么跟上时代，却总也是浅尝辄止。尽管最近事务繁多，可这也不能成为理由，总之这样的状态真的很不好。CSDN是我很少涉足的地界，希望在这里能够养成知识总结的好习惯，从现在开始。 PS：结尾一句颇有中“常立志”而非“立长志”的意味，不管如何，这篇文章虽是发在网上，但也是对自我的激励，其中的轻重唯有自己最清楚。","categories":[{"name":"聊聊人生","slug":"聊聊人生","permalink":"http://www.xiaowenhan.com.cn/categories/聊聊人生/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://www.xiaowenhan.com.cn/tags/其他/"}]}]}