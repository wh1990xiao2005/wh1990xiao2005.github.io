{"meta":{"title":"萧爷代码实验室","subtitle":null,"description":null,"author":"Wenhan Xiao","url":"http://www.xiaowenhan.com.cn","root":"/"},"pages":[],"posts":[{"title":"Flutter App 软件测试指南","slug":"hello-world","date":"2019-07-30T04:08:00.440Z","updated":"2019-07-30T11:02:21.876Z","comments":true,"path":"2019/07/30/hello-world/","link":"","permalink":"http://www.xiaowenhan.com.cn/2019/07/30/hello-world/","excerpt":"","text":"前言在实际开发中，测试和调试所占的时间比例，在总开发时间中还是比较高的。某些Bug隐藏之深是开发者通常想不到的，手动测试的难度也会随之加剧，甚至会有遗漏的情况出现。因此，自动化测试工具便因运而生，它可以帮助开发者或测试员在产品发布前确保产品的质量。随着应用的功能越多，手动测试的难度就越大。一套完整的自动化测试将帮助您，并确保您的应用在发布之前正确执行。本文涵盖了 Flutter App 的所有测试方式，通过本场 Chat 的学习，您将会得到以下知识： Flutter App 中的三种测试方式及优劣分析； 如何在 Flutter App 中进行单元测试； 如何在 Flutter App 中进行组件测试； 如何在 Flutter App 中进行集成测试。 Flutter框架提供了三种自动化测试方法：单元测试、组件测试和集成测试。在讲述以上三种测试方式之前，我们首先来看一下上述三种测试方式的优劣势，以及适用场景。 Flutter App 中的三种测试方式及优劣分析首先我们来看三种测试方式的能力： 单元测试：测试单个功能、单个方法或单个类，不会有文件IO，不会有UI显示，也不会接收用户操作； 组件测试：测试单个组件，当某个组件涉及多个类或存在不同的状态时，关联部分也会被测试，会有UI显示，可能会接收用户操作； 集成测试：测试App的整体或大部分。 因此，单元测试通常在用于验证某个逻辑单元的正确性，由于其不具有UI显示和用户输入操作，所以一般情况下，进行单元测试并不需要真机或模拟器；组件测试稍微复杂一点点，它可能涉及多个类或多个子组件，同时还需要提供适当的上下文才行。它通常用于测试某个组件具有正确的显示和用户交互；集成测试通常需要真机或者模拟器，它的目的是验证整个App的运行正确，所有Widgets的组合准确无误。 下面的表格向我们展示了三种测试方式在不同方面的优劣特点： 考量标准 单元测试 组件测试 集成测试 信赖度 低 中 高 维护成本 低 中 高 依赖性 低 中 高 执行速度 快速 稍慢 最慢 接下来我们分别看一下各种测试方式是如何进行的。 单元测试完整地进行一次单元测试总共有五个步骤，我们逐步进行： 添加测试库默认情况下，用于测试的库在新建Flutter工程的时候已经引入了，它位于pubspec.yaml中，打开后可以找到相关代码： 123dev_dependencies: flutter_test: sdk: flutter 但是，如果工程代码没有引入这个库，请按照如上所示将其添加到pubspec.yaml文件中。 创建测试类和被测试类顾名思义，测试类是用来测试另一个类的，被测试类是等待另一个类来测试。还记得上一次课中，我们回顾的Flutter App工程结构吗？在工程根目录下，包含test目录。通常，该目录就是用来放测试类的。App的业务逻辑代码则位于lib目录中。下面分别在这两个目录中创建dart文件： 12345counter_app/ lib/ counter.dart test/ counter_test.dart 像上述树形结构显示的那样，我们在lib目录中新建了counter.dart类，在test目录中新建了counter_test.dart类。前者是被测试类，后者是测试类。 开发业务逻辑接下来就是开发业务逻辑了。本例中，我们尝试实现一个简单的变量自增和自减两个方法，这部分的实现在lib目录下的counter.dart中。代码如下： 12345class Counter &#123; int value = 0; void increment() =&gt; value++; void decrement() =&gt; value--;&#125; 开发测试类下面我们编写counter_test.dart类，这里需要导入test.dart类，以便可以正常使用测试方法。下面是测试counter.dart类中，自增和自减方法正确性的代码： 12345678910111213141516171819202122import &apos;package:flutter_test/flutter_test.dart&apos;;import &apos;package:demo_unit_test/counter.dart&apos;;void main() &#123; test(&apos;Counter value should be incremented&apos;, () &#123; final counter = Counter(); counter.increment(); expect(counter.value, 1); &#125;); test(&apos;value should be decremented&apos;, () &#123; final counter = Counter(); counter.decrement(); expect(counter.value, -1); &#125;); &#125;);&#125; 怎么样？这段代码理解起来还不难吧？要注意的是，这里的测试内容十分简单。当要测试的单元过多时，我们可以将其归类。归类的依据可以按照功能来做，比如上例中，加减法都属于算术方法，因此可以归为同一类。使用group方法可实现归类效果，具体实现如下： 1234567891011121314151617181920212223242526import &apos;package:flutter_test/flutter_test.dart&apos;;import &apos;package:demo_unit_test/counter.dart&apos;;void main() &#123; group(&apos;Counter&apos;, () &#123; test(&apos;value should start at 0&apos;, () &#123; expect(Counter().value, 0); &#125;); test(&apos;value should be incremented&apos;, () &#123; final counter = Counter(); counter.increment(); expect(counter.value, 1); &#125;); test(&apos;value should be decremented&apos;, () &#123; final counter = Counter(); counter.decrement(); expect(counter.value, -1); &#125;); &#125;);&#125; 虽然看上去代码量增多了，但结构更加清晰了，阅读起来更加容易了。我们还可以使用IDE的折叠代码功能，将同类型的测试代码进行折叠，就更易读了。 运行测试类最后，我们运行测试类开始测试。打开Android Studio中的Terminal视图，运行集成的控制台，在其中输入一下命令： 1flutter test test/counter_test.dart 然后回车，稍等片刻，即可得到测试结果： 100:02 +2: All tests passed! 测试通过！当多个测试类存在时，如果我们想要执行所有的测试内容，直接不指定测试类即可： 1flutter test 组件测试完整的组件测试可分为八个步骤进行，这种类型的测试需要使用真机或模拟器。和单元测试一样，我们逐步进行讲解。 添加测试库运行组件测试依然需要添加测试库： 123dev_dependencies: flutter_test: sdk: flutter 这一步就不多说了。 创建要被测试的组件这一次，我们以新建的计数器应用为例，默认的widget_test.dart中其实已经包含了组件测试的方法。，我们一起来看一下。 创建组件测试类由于这一次采用了默认新建的工程作为示例，因此我们省略了开发业务逻辑代码的过程，直接来到测试类的编写。打开test目录下的widget_test.dart，阅读里面的代码，不难发现，用于组件测试的结构是这样的： 12345void main() &#123; testWidgets(&apos;MyWidget has a title and message&apos;, (WidgetTester tester) async &#123; // 测试代码 &#125;);&#125; 没错，我们用testWidgets()方法进行组件测试，它包含了WidgetTester对象——tester，我们将在下一步用到该对象。 使用WidgetTester创建组件继续阅读widget_test.dart代码，在testWidgets()方法中，一上来执行了以下语句： 1await tester.pumpWidget(MyApp()); pumpWidget方法创建了MyApp组件，这一步骤并没有在你的移动设备上运行，只是在后台默默地完成组件的渲染。继续阅读后面的代码，我们还发现了tester.tap()，该方法模拟一个点击操作；紧跟其后的tester.pump()则会重建组件（对应业务逻辑代码中的setState()方法），因为单纯的点击后，并不会使有状态组件发生最终显示变化，只有调用tester.pump()之后才行。通常，被测试的代码中有setState()的地方，就会有tester.pump()出现在测试代码中。 使用find找到被测组件在widget_test.dart中，还有类似这样的写法： 12find.text(&apos;0&apos;)find.byIcon(Icons.add) 使用find，可以帮我们找到要验证的组件。比如，上面的代码中，前者是通过“包含0”，去寻找符合该要求的组件。我们都知道，默认创建的工程，直接运行就会显示一个点按FloatingActionButton的计数器，默认值为0。显而易见地，符合包含0条件的，只有屏幕中央的计数器值。而后者则是通过加号条件来找到右下角的FloatingActionButton。 使用Matcher验证结果找到组件并模拟点击事件后，我们就要验证最终的结果了，在Widget_test.dart中，将查找组件和验证结果写到了一起。代码如下所示： 12expect(find.text(&apos;0&apos;), findsOneWidget);expect(find.text(&apos;1&apos;), findsNothing); 这段代码很容易理解，通过查找包含0的条件，若符合找到一个组件的结果，则表示测试通过。 运行测试运行组件测试的方法和运行单元测试相同。 最后，让我们回顾整个widget_test.dart： 1234567891011121314151617181920212223import &apos;package:flutter/material.dart&apos;;import &apos;package:flutter_test/flutter_test.dart&apos;;import &apos;package:demo_widget_test/main.dart&apos;;void main() &#123; testWidgets(&apos;Counter increments smoke test&apos;, (WidgetTester tester) async &#123; // Build our app and trigger a frame. await tester.pumpWidget(MyApp()); // Verify that our counter starts at 0. expect(find.text(&apos;0&apos;), findsOneWidget); expect(find.text(&apos;1&apos;), findsNothing); // Tap the &apos;+&apos; icon and trigger a frame. await tester.tap(find.byIcon(Icons.add)); await tester.pump(); // Verify that our counter has incremented. expect(find.text(&apos;0&apos;), findsNothing); expect(find.text(&apos;1&apos;), findsOneWidget); &#125;);&#125; 梳理一下整个组件测试流程： 创建MyApp组件； 查找符合“包含0”条件的组件，期望结果是1个； 查找符合“包含1”条件的组件，期望结果是0个； 点击包含加号图标的组件； 重建组件； 查找符合“包含0”条件的组件，期望结果是0个； 查找符合“包含1”条件的组件，期望结果是1个； 运行测试，检查测试结果。 集成测试说过了单元测试和组件测试，我们下面来聊聊集成测试。我们可以分6个步骤进行集成测试，这一节我们依旧使用新建的默认工程为例。 创建要测试的App虽说我们直接使用新建的默认工程，但为了完成集成测试，还需要在原有的代码基础上做点小改动——在计数值显示的Text组件和FloatingActionButton组件上添加key属性。完整的main.dart代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import &apos;package:flutter/material.dart&apos;;void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: &apos;Flutter Demo&apos;, theme: ThemeData( primarySwatch: Colors.blue, ), home: MyHomePage(title: &apos;Flutter Demo Home Page&apos;), ); &#125;&#125;class MyHomePage extends StatefulWidget &#123; MyHomePage(&#123;Key key, this.title&#125;) : super(key: key); final String title; @override _MyHomePageState createState() =&gt; _MyHomePageState();&#125;class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; int _counter = 0; void _incrementCounter() &#123; setState(() &#123; _counter++; &#125;); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text( &apos;You have pushed the button this many times:&apos;, ), Text( &apos;$_counter&apos;, key: Key(&apos;counter&apos;), style: Theme.of(context).textTheme.display1, ), ], ), ), floatingActionButton: FloatingActionButton( key: Key(&apos;increment&apos;), onPressed: _incrementCounter, tooltip: &apos;Increment&apos;, child: Icon(Icons.add), ), ); &#125;&#125; 注意：上述代码精简了原代码中的注释部分。 添加必要的测试库进行集成测试，需要使用flutter_driver库。和flutter_test库类似，将其添加到pubspec.yaml的dev_dependencies节点下即可。 123456dev_dependencies: flutter_test: sdk: flutter flutter_driver: sdk: flutter test: any 当然，不要忘记声明flutter_test库。 创建测试类集成测试用到的测试类位于工程根目录下的test_driver目录中，默认创建的Flutter工程并不包含这个目录，因此需要手动创建它。创建好这个目录后，我们还需要创建指令化的Flutter应用程序类和集成测试用到的类： 创建指令化的Flutter应用程序类：指令化的应用程序是启用了Flutter Driver扩展的应用程序。 创建集成测试用到的类：集成测试类包含用于验证运行结果正确与否的测试套件。测试套件同样记录性能分析数据。该类的命名规则必需以与之相关的指令化应用程序类名后加_test为名。 本例中，指令化的Flutter应用程序类名为app.dart，集成测试用到的类则为app_test.dart。创建好上述两个类后的工程目录结构如下： 12345lib/ main.darttest_driver/ app.dart app_test.dart 构建指令化的Flutter应用程序类创建指令化的Flutter应用程序很简单，只需启动Flutter drive扩展，并运行程序即可。完整的app.dart代码如下： 1234567import &apos;package:flutter_driver/driver_extension.dart&apos;;import &apos;package:demo_integration_test/main.dart&apos; as app;void main() &#123; enableFlutterDriverExtension(); app.main();&#125; 注意：由于main()方法在app.dart中也有声明，因此这里使用了import … as …的方式导入类。在使用时利用app.main()的调用方式区分了不同类的同名的main()方法。 构建集成测试用到的类在构建好指令化的Flutter应用程序后，我们就可以写针对它的测试类了。这个测试类使用Flutter driver API来指导应用程序执行操作，之后再验证这个操作是否正确。完整的app_test.dart如下： 12345678910111213141516171819202122232425262728293031import &apos;package:flutter_driver/flutter_driver.dart&apos;;import &apos;package:flutter_test/flutter_test.dart&apos;;void main() &#123; group(&apos;Counter App&apos;, () &#123; final counterTextFinder = find.byValueKey(&apos;counter&apos;); final buttonFinder = find.byValueKey(&apos;increment&apos;); FlutterDriver driver; setUpAll(() async &#123; driver = await FlutterDriver.connect(); &#125;); tearDownAll(() async &#123; if (driver != null) &#123; driver.close(); &#125; &#125;); test(&apos;starts at 0&apos;, () async &#123; expect(await driver.getText(counterTextFinder), &quot;0&quot;); &#125;); test(&apos;increments the counter&apos;, () async &#123; await driver.tap(buttonFinder); expect(await driver.getText(counterTextFinder), &quot;1&quot;); &#125;); &#125;);&#125; 如上代码所示，首先使用find定位要测试的组件。本例中通过key的方式找到了计数值Text组件和FloatingActionButton组件。接着，在正式测试前调用setUpAll()方法连接到App。然后就是测试脚本的内容了，分别对应本例中的两个test()方法。最后调用tearDownAll()方法和App断开连接，结束测试流程。 运行测试现在就可以运行测试代码，观察测试结果了！运行方法是启动集成的命令行视图，在工程根目录下运行以下指令： 1flutter drive --target=test_driver/app.dart 注意：集成测试将真正地在设备上运行App，你将看到测试操作的全过程。在测试完成后，App将自动关闭，并在命令行留下相关日志。我们可以从日志中得到类似如下的测试结果： 1234567891011121314151617181920Using device Android SDK built for x86.Starting application: test_driver/app.dartInitializing gradle... 2.5sResolving dependencies... 10.4sInstalling build\\app\\outputs\\apk\\app.apk... 2.3sRunning Gradle task &apos;assembleDebug&apos;... 8.0sBuilt build\\app\\outputs\\apk\\debug\\app-debug.apk.I/flutter (25973): Observatory listening on http://127.0.0.1:33620/bq9GdK_WZuM=/00:00 [32m+0[0m: Counter App (setUpAll)[0m[info ] FlutterDriver: Connecting to Flutter application at http://127.0.0.1:53896/bq9GdK_WZuM=/[trace] FlutterDriver: Isolate found with number: 197444479[trace] FlutterDriver: Isolate is paused at start.[trace] FlutterDriver: Attempting to resume isolate[trace] FlutterDriver: Waiting for service extension[info ] FlutterDriver: Connected to Flutter application.00:01 [32m+0[0m: Counter App starts at 0[0m00:01 [32m+1[0m: Counter App increments the counter[0m00:04 [32m+2[0m: Counter App (tearDownAll)[0m00:04 [32m+2[0m: All tests passed![0mStopping application instance. 到此，Flutter App的三种测试方法就讲完了，不知道各位会用了吗？","categories":[],"tags":[]}]}