{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/pure/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/pure/source/fonts/README.md","path":"fonts/README.md","modified":0,"renderable":1},{"_id":"themes/pure/source/fonts/iconfont.eot","path":"fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/pure/source/fonts/iconfont.ttf","path":"fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/pure/source/fonts/iconfont.woff","path":"fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/pure/source/images/thumb-default.png","path":"images/thumb-default.png","modified":0,"renderable":1},{"_id":"themes/pure/source/images/xingqiu-qrcode.jpg","path":"images/xingqiu-qrcode.jpg","modified":0,"renderable":1},{"_id":"themes/pure/source/js/application.js","path":"js/application.js","modified":0,"renderable":1},{"_id":"themes/pure/source/js/application.min.js","path":"js/application.min.js","modified":0,"renderable":1},{"_id":"themes/pure/source/js/insight.js","path":"js/insight.js","modified":0,"renderable":1},{"_id":"themes/pure/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/pure/source/js/plugin.min.js","path":"js/plugin.min.js","modified":0,"renderable":1},{"_id":"themes/pure/source/css/style.min.css","path":"css/style.min.css","modified":0,"renderable":1},{"_id":"themes/pure/source/images/donate/wechatpayimg.png","path":"images/donate/wechatpayimg.png","modified":0,"renderable":1},{"_id":"themes/pure/source/images/donate/alipayimg.png","path":"images/donate/alipayimg.png","modified":0,"renderable":1},{"_id":"themes/pure/source/images/favatar/chuangzaoshi-logo.png","path":"images/favatar/chuangzaoshi-logo.png","modified":0,"renderable":1},{"_id":"themes/pure/source/images/favatar/SzsFox-logo.png","path":"images/favatar/SzsFox-logo.png","modified":0,"renderable":1},{"_id":"themes/pure/source/images/favatar/idesign-logo.png","path":"images/favatar/idesign-logo.png","modified":0,"renderable":1},{"_id":"themes/pure/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/pure/source/js/plugin.js","path":"js/plugin.js","modified":0,"renderable":1},{"_id":"themes/pure/source/js/plugin.js.map","path":"js/plugin.js.map","modified":0,"renderable":1},{"_id":"themes/pure/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/pure/source/fonts/iconfont.svg","path":"fonts/iconfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/pure/LICENSE","hash":"82ce1e15ddeabeaaca60e2186b5a3ce42b1a9c49","modified":1564466019590},{"_id":"themes/pure/README.cn.md","hash":"7facc2f8aadaf4c172dfc931bebcc37b9ef3d7e8","modified":1564466019590},{"_id":"themes/pure/_config.yml","hash":"0bd64c5f07e32edd66a5e34e8eca450e9b6d9ab6","modified":1564561378932},{"_id":"themes/pure/README.md","hash":"94fe451bf920cec6152e7bf9cbff4ccf0af0febc","modified":1564466019590},{"_id":"themes/pure/_config.yml.example","hash":"a3b55d01598967db40da6f740b38cdba4f17d7bc","modified":1564466019590},{"_id":"themes/pure/package.json","hash":"d5bad0f074925c46e8ee5a75d385346d2fcea850","modified":1564466019625},{"_id":"source/_posts/Activity与DialogFragment交互的方法.md","hash":"a8cbc28abc5461465cdad0383d7506893347e0e2","modified":1564546172544},{"_id":"source/_posts/Android 5.0(L) ToolBar(替代ActionBar) 实战（一）.md","hash":"a4c0e0761ff4147e5b7e6ae0f6c470aed622ac09","modified":1564546181547},{"_id":"source/_posts/Android 5.0(L) ToolBar(替代ActionBar) 实战（三）.md","hash":"d5d27efe052cf12937e886adddf566b93eb98056","modified":1564546210050},{"_id":"source/_posts/Android 5.0(L) ToolBar(替代ActionBar) 实战（二）.md","hash":"b6e9c96664a1f6802fd7ea703f6a73d58eb18631","modified":1564546208994},{"_id":"source/_posts/Android 5.0(L) ToolBar(替代ActionBar) 实战（四）.md","hash":"b2d9067599c1bb35d2df8eaf2a04b9c5682efb04","modified":1564546204355},{"_id":"source/_posts/Android 6.0 运行时权限简明处理.md","hash":"9dfbfc90f0c3737b5c5b12a1f6b69553fcc6b4ab","modified":1564546202751},{"_id":"source/_posts/Android GridView 点击效果（可能是最快捷的实现，另有福利）.md","hash":"51707b15d1d98410e50757fcb5d1477f965e3481","modified":1564546207890},{"_id":"source/_posts/Android Jetpack之AppCompat - Actionbar篇.md","hash":"69db8d2d68cbc5e63174c96e3ecbfbb003cc5f36","modified":1564546199967},{"_id":"source/_posts/Android 重写ImageView实现图片手势功能.md","hash":"2f88be0198c0ecf887e9be6de2db57dfa2c4b2ac","modified":1564546221566},{"_id":"source/_posts/Android平台下使用ormLite的一个小Tip.md","hash":"1d06b102c40f174f5b653fcdef1f8e781b6c8785","modified":1564546224687},{"_id":"source/_posts/Android平台录音音量计的实现.md","hash":"87d9f8bd37c9ab1f0c31ab2a2ae75421864da256","modified":1564546227444},{"_id":"source/_posts/CSDN 开博寄语.md","hash":"68baaf2c9aa78b0b6da11982e5f795c8a6b58914","modified":1564546245967},{"_id":"source/_posts/Java 文件操作工具类（Android 适用）.md","hash":"ab2963c40bac61f701be086dc0718457fffd8426","modified":1564546255450},{"_id":"source/_posts/个性化个人主站——使用Hexo框架.md","hash":"edb232f659cf9ede25cdfe16a872645745510ba2","modified":1564546261782},{"_id":"source/_posts/为了安全——应用锁屏开发实战.md","hash":"f3f3aebcfb774b90b9b8886b67cefd1171082fa5","modified":1564546265542},{"_id":"source/_posts/IntelliJ IDEA 14 值得你弃用Eclipse的IDE神器.md","hash":"cada08c87371e026d61aecc0197ca92ee30c3562","modified":1564546251748},{"_id":"source/_posts/优化Activity启动速度的另类解法.md","hash":"b14d9fe109548999b9e4c825bc87e31217a8001f","modified":1564546268465},{"_id":"source/_posts/博客园 开博寄语.md","hash":"04e0b31c9ddb2e927e9d2cae63ddedbc314c32bf","modified":1564546276743},{"_id":"source/_posts/取之有道——巧用Root权限 启动其他APP中的Activity.md","hash":"181ce5c3a108222407a28d2bed98ff3f8656fcce","modified":1564546280432},{"_id":"source/_posts/巧用Handler获取View控件信息.md","hash":"a0f6d641c534ed5cd640272af2efd829c58330d2","modified":1564546283417},{"_id":"source/_posts/微信插件开发手记-聊天界面传送任意类型文件.md","hash":"7d43a23e26d84ccda7c71e5eb3a3906c25e7b4ba","modified":1564546286147},{"_id":"source/_posts/抓出卡顿元凶，从分析掉帧开始.md","hash":"f11184a05cf51333e61050eb2a0753f3e9de5db4","modified":1564546292159},{"_id":"source/_posts/提升应用崩溃时的用户体验——去掉烦人的“很抱歉”提示框.md","hash":"c02672e1e7e56841e033b006bc8442de472ed73c","modified":1564546295447},{"_id":"source/_posts/Mapbox 地图SDK极速集成指导.md","hash":"1307d49073103cfc34c82396faf9f00e3a17e310","modified":1564546258593},{"_id":"source/_posts/搭建React Native环境的几个Tips.md","hash":"3d86ae954c19197077800c3b5835e14eba8943a2","modified":1564546300351},{"_id":"source/_posts/简易实现脸部贴近自动关屏.md","hash":"f20b501587bf549e755971a211434310304b3320","modified":1564546303998},{"_id":"source/_posts/粮草先行——Android折叠屏开发技术点番外篇之运行时变更处理原则.md","hash":"57231c2489298eba765be474df4184539f14cff6","modified":1564546312998},{"_id":"source/_posts/粮草先行——Android折叠屏开发技术点（一）.md","hash":"9075980030c9a5c5bab6ef3e8447a0566e8cf00d","modified":1564546307123},{"_id":"source/_posts/粮草先行——Android折叠屏开发技术点（二）.md","hash":"0703b688864ebff3b453015d4d5aec2593223a3f","modified":1564546310002},{"_id":"source/_posts/自定义ImageView系列 － 区域截图（上）.md","hash":"63abe3bcfd129b84aca08b31bc44786e1fa8910b","modified":1564546316584},{"_id":"source/_posts/自定义ImageView系列 － 区域截图（下）.md","hash":"cda1bcef10a6a9bb3ed523f1aa1d00ac4a3e419a","modified":1564546319822},{"_id":"source/_posts/解决Android录音iOS兼容性问题.md","hash":"9cceb97774bce8174bbd36f1e2ec7ac53dfa20a8","modified":1564546322763},{"_id":"source/_posts/解决TextView引起的莫名崩溃.md","hash":"35028a8ca2dba316a749bd1b6d275b9d354e28c2","modified":1564546333599},{"_id":"source/_posts/调用系统相机导致照片旋转问题的修复.md","hash":"9b1ad99403ac3f9cc94d14dd764e7322cf5fa465","modified":1564546336364},{"_id":"source/_posts/身为程序员，你焦虑吗.md","hash":"ac9cab492307037233d85b6b399bceeb4a6c91d4","modified":1564546345767},{"_id":"source/categories/index.md","hash":"b0006184ce9570766e7c7507d20fede1079f4992","modified":1564466019595},{"_id":"source/_posts/轻松使用Github搭建个人网站.md","hash":"c9a2f3a8457f3c28246bfb5d916f1c2f0d2fabc4","modified":1564546349428},{"_id":"themes/pure/layout/about.ejs","hash":"4b64515ccc801cc9eba637a1e1909c6c4dd203f6","modified":1564466019620},{"_id":"themes/pure/layout/archive.ejs","hash":"90fa5b0d8f081d0bde33b2784f66e6a80e5b0dac","modified":1564466019620},{"_id":"themes/pure/layout/books.ejs","hash":"75cbd31d3551c730e8a683bd5b08562881a95b51","modified":1564466019620},{"_id":"themes/pure/layout/categories.ejs","hash":"9cc7b5f5af40fd7ec641bf0f5a5f8f1ce1ac22d5","modified":1564466019625},{"_id":"themes/pure/layout/category.ejs","hash":"b3f7a96fbaf201a65ed64d509edc29976542fbfb","modified":1564466019625},{"_id":"themes/pure/layout/index.ejs","hash":"44418dbf1fb82392b8e1e4cc910d16a383190433","modified":1564466019625},{"_id":"themes/pure/layout/layout.ejs","hash":"71bdeba7b8be0c4f56a87ad05da2c6d4254da55e","modified":1564466019625},{"_id":"themes/pure/layout/links.ejs","hash":"ee90a5f2a9d19bc02682ea3a59177b947f7f7284","modified":1564466019625},{"_id":"themes/pure/layout/page.ejs","hash":"fbfed3c882059e757b23ff57924400683631594b","modified":1564466019625},{"_id":"themes/pure/layout/repository.ejs","hash":"0ecad33b6c1ec741eb3b02bb47a3824ac3749d09","modified":1564466019625},{"_id":"themes/pure/layout/tag.ejs","hash":"30d8ddd84c9aa87dff1be02af308097cf4e72448","modified":1564466019625},{"_id":"themes/pure/layout/tags.ejs","hash":"76bc71f3dfd8a5b1aa14b09dec7b460b14f5028a","modified":1564466019625},{"_id":"themes/pure/scripts/thumbnail.js","hash":"4a7385e533f3567758bc995a8be5eb3e7839ac9c","modified":1564466019645},{"_id":"themes/pure/source/favicon.png","hash":"71688aa146d231af3df5d4317e38ddf9dc131474","modified":1564471886466},{"_id":"themes/pure/layout/post.ejs","hash":"fbfed3c882059e757b23ff57924400683631594b","modified":1564466019625},{"_id":"themes/pure/languages/default.yml","hash":"433a5d38ab0907356ee19be6e8fad28e3a9d3333","modified":1564480568634},{"_id":"themes/pure/languages/en.yml","hash":"eb6add772187749934d32fcbb9694830db07fd1e","modified":1564480756557},{"_id":"themes/pure/languages/zh-CN.yml","hash":"bb7bcfe33bdad2e2e6ac63edc916924d97809cc9","modified":1564555400660},{"_id":"themes/pure/languages/zh-TW.yml","hash":"aad887f89b292fe6392321c6c0c86ac3d25f5bc7","modified":1564480751278},{"_id":"themes/pure/screenshot/pure-theme-blue.png","hash":"6146890a68d5ea9d343c48d50151ddd5a2a1872c","modified":1564466019630},{"_id":"themes/pure/screenshot/pure-theme-green.png","hash":"12ec0c6033cb2762839fdf75434bbb4fbf946022","modified":1564466019630},{"_id":"themes/pure/screenshot/pure-theme-purple.png","hash":"9855d2eb0acd23370209354f232471df8f4f72e2","modified":1564466019630},{"_id":"themes/pure/screenshot/pure.png","hash":"8f4cfd8d7edfa4fbffdf375291302d9807f5cc1c","modified":1564466019630},{"_id":"themes/pure/screenshot/pure-theme-black.png","hash":"10b40f398af7eb7e8ba2bf2f2a959d8779fc1fe1","modified":1564466019630},{"_id":"themes/pure/_source/404/index.md","hash":"16638b081d796638565ca462f3c87339b9a0577e","modified":1564466019595},{"_id":"themes/pure/_source/_data/gallery.yml","hash":"eef9b025c2a81fdc714967d0c7b21bed9d55cff5","modified":1564466019595},{"_id":"themes/pure/_source/_data/links.yml","hash":"a5e31f35ebb8e1e8811f2e3d957cf4d4835aa2f9","modified":1564466019595},{"_id":"themes/pure/_source/books/index.md","hash":"d913d58987f539ac2ca4cca366ebf42f8b1a03d1","modified":1564466019595},{"_id":"themes/pure/_source/about/index.md","hash":"b72470146e8244886e15715e0cae79b4130305e8","modified":1564466019595},{"_id":"themes/pure/_source/categories/index.md","hash":"b0006184ce9570766e7c7507d20fede1079f4992","modified":1564466019595},{"_id":"themes/pure/_source/links/index.md","hash":"d768332d0d322fe39267dbbda05b931488c27d7e","modified":1564466019595},{"_id":"themes/pure/_source/repository/index.md","hash":"bf2bec13066d7d53fc05a334876eb482e6f95825","modified":1564466019600},{"_id":"themes/pure/layout/_common/footer.ejs","hash":"6a1677f7bbed60b6442e73d1fbf45e235eda7c0f","modified":1564480547643},{"_id":"themes/pure/layout/_common/head.ejs","hash":"4135b80c40cc970f9dc30fdd02e4f3e0a8b0af67","modified":1564466019600},{"_id":"themes/pure/layout/_common/header.ejs","hash":"c05070274965692a270c7e07ad9f4dad6f2c5888","modified":1564466019600},{"_id":"themes/pure/layout/_common/script.ejs","hash":"3045da0c1979946694b628fbef39c01cc98b6e75","modified":1564466019600},{"_id":"themes/pure/layout/_common/social.ejs","hash":"2bcdc7b0ee3905e724b01c2efa1ca6b47a846e1f","modified":1564466019600},{"_id":"themes/pure/_source/tags/index.md","hash":"c35ba8af5acf41102909a9f9c1349a24d89f97a6","modified":1564466019600},{"_id":"themes/pure/layout/_partial/archive-book.ejs","hash":"944913dcabd09c10d3014c844abf851f4dfdba8d","modified":1564466019600},{"_id":"themes/pure/layout/_partial/archive-category.ejs","hash":"4be88eec64fd40c7e1b74df8ccb6c8cdfa3e7a17","modified":1564466019605},{"_id":"themes/pure/layout/_partial/archive-link.ejs","hash":"a8a387f9e7289a6524cf46d7ab76c34fff37f4bf","modified":1564466019605},{"_id":"themes/pure/layout/_partial/archive-list.ejs","hash":"e4810f8e03986d5a8afdf4c0932814a3d0db9ffe","modified":1564466019605},{"_id":"themes/pure/layout/_partial/archive-post.ejs","hash":"513892fae41de4e68963c95a9358285714274bb4","modified":1564466019605},{"_id":"themes/pure/layout/_partial/archive-repository.ejs","hash":"6408e37ec1a8ee868cf36d5b0e020d5d97ea2f27","modified":1564466019605},{"_id":"themes/pure/layout/_partial/archive-tag.ejs","hash":"db8cba32bf6655a8d21fe8c8ccd0695b049e1d4c","modified":1564466019605},{"_id":"themes/pure/layout/_partial/archive.ejs","hash":"c196b54f92eff017a48e02bacc029dd82edc8cf9","modified":1564466019605},{"_id":"themes/pure/layout/_partial/article-about.ejs","hash":"47bbb53fe9cca05928c45782c6897c8a94d597ff","modified":1564466019605},{"_id":"themes/pure/layout/_partial/article.ejs","hash":"8af3bcfc07c344cefa0655dbe83f3c1a55954899","modified":1564466019605},{"_id":"themes/pure/layout/_partial/item-post.ejs","hash":"fdc5ac554e375f2e8b1e4dbe77cedda692f1228e","modified":1564466019605},{"_id":"themes/pure/layout/_partial/pagination.ejs","hash":"bae5b4eb8b6415dc988bda88be1c4f8e252b1844","modified":1564466019605},{"_id":"themes/pure/layout/_partial/sidebar-about.ejs","hash":"be30d7eb0b391759ac329b8a7b410d758ff8b032","modified":1564466019610},{"_id":"themes/pure/layout/_partial/sidebar-toc.ejs","hash":"335a906404dada013d83508244e992c7a26fa879","modified":1564466019610},{"_id":"themes/pure/layout/_partial/sidebar.ejs","hash":"a6662f79f7fd6f1cc9b5180672ba8e1d0192fbe2","modified":1564466019610},{"_id":"themes/pure/layout/_script/analytics.ejs","hash":"db2967c6902ceb67caa70364935ef3441b10432f","modified":1564466019615},{"_id":"themes/pure/layout/_script/comment.ejs","hash":"d5c98ab345952bb11d9ee69a9c1e3432b6760c55","modified":1564466019615},{"_id":"themes/pure/layout/_script/douban.ejs","hash":"1e4bad0e7d04352e3634994f413c16b0001efa4a","modified":1564466019615},{"_id":"themes/pure/layout/_script/fancybox.ejs","hash":"4558b5713926735d874deb14d8b21ed2e597b714","modified":1564466019615},{"_id":"themes/pure/layout/_script/mathjax.ejs","hash":"7a64d98212769423425102a441fca52eb6930fff","modified":1564466019615},{"_id":"themes/pure/layout/_script/pv.ejs","hash":"a464706b7a903e25d34b104bdfb298b260abc132","modified":1564466019615},{"_id":"themes/pure/layout/_script/repository.ejs","hash":"6b5cc1ef09d1602a526d67ad7a8ba1c995fbb597","modified":1564466019615},{"_id":"themes/pure/layout/_script/search.ejs","hash":"2b784d15581df4309f56682896b725da7d44fcdd","modified":1564466019620},{"_id":"themes/pure/layout/_widget/board.ejs","hash":"9811bab46dcf436c6d05ae78acd62bc25751df78","modified":1564466019620},{"_id":"themes/pure/layout/_widget/archive.ejs","hash":"b250fb0f63286f9648cd8bf428bed6a88901b481","modified":1564466019620},{"_id":"themes/pure/layout/_widget/category.ejs","hash":"83c8ce4b099951d58b2be5006f6963afbbe7d4e9","modified":1564466019620},{"_id":"themes/pure/layout/_widget/recent_posts.ejs","hash":"8932ce5283a7e6a356c6840104a7d6984f2ea986","modified":1564466019620},{"_id":"themes/pure/layout/_widget/tag.ejs","hash":"24823a881a6c15fd846c7f4780eb90fe869a813b","modified":1564466019620},{"_id":"themes/pure/layout/_widget/tagcloud.ejs","hash":"e6967ec160b93a5f466a73a36745833e644d04c0","modified":1564466019620},{"_id":"themes/pure/layout/_search/baidu.ejs","hash":"89848cc8e0190ca76cc26d42c6880a23e370702e","modified":1564466019620},{"_id":"themes/pure/layout/_search/index-mobile.ejs","hash":"5e9a5cc9bdc05fabf939db494c3937cc0df48a72","modified":1564466019620},{"_id":"themes/pure/layout/_search/index.ejs","hash":"2c1f06dac5710e5fd073f3e5739545f3f6a0a56f","modified":1564466019620},{"_id":"themes/pure/layout/_search/swiftype.ejs","hash":"dc548a83c33b5a598683bf2e1cb723bc3be4a76b","modified":1564466019620},{"_id":"themes/pure/layout/_search/insight.ejs","hash":"14b1ec0bdb911ab6d92046c78d371264afc4fb19","modified":1564466019620},{"_id":"themes/pure/source/fonts/README.md","hash":"b5b2aac1b36a86dac2217d242d650e026c5a3b0c","modified":1564466019650},{"_id":"themes/pure/source/fonts/iconfont.eot","hash":"6819d9bb643bdeafc17bfecb0746ae641b018fdf","modified":1564466019650},{"_id":"themes/pure/source/fonts/iconfont.ttf","hash":"9b8837f9f79cf6ab794736301d0665345183a20c","modified":1564466019650},{"_id":"themes/pure/source/fonts/iconfont.woff","hash":"78d29194287b8885d25212048c4f787705212a6e","modified":1564466019650},{"_id":"themes/pure/source/images/thumb-default.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1564466019655},{"_id":"themes/pure/source/images/xingqiu-qrcode.jpg","hash":"ef2c2848dc79db6df7c752510651ed8ba57f2daf","modified":1564466019655},{"_id":"themes/pure/source/js/application.js","hash":"c29f52f5ed2d1a5d8185b115f2962d22e707e19e","modified":1564466019655},{"_id":"themes/pure/source/js/application.min.js","hash":"34d765e982c7d6360c37f82202d99f63ac40e408","modified":1564466019655},{"_id":"themes/pure/source/js/insight.js","hash":"a1b773d9ce470bf0e2f8fdca1b6fac2ac3d31aeb","modified":1564466019655},{"_id":"themes/pure/source/images/avatar.jpg","hash":"dc13ce379f5ac6e50c3150745c918ecbf75c9fc7","modified":1564471770376},{"_id":"themes/pure/source/js/plugin.min.js","hash":"4eded164f8b6f5187fbf10065873ebeee5ab8787","modified":1564466019660},{"_id":"themes/pure/layout/_partial/post/category.ejs","hash":"20ef0d47ec3d2de7d94db9778ddac092dc2bd4b5","modified":1564466019605},{"_id":"themes/pure/layout/_partial/post/comment.ejs","hash":"0ef132fc45042b28411e3334e77b6e2a7f47fae2","modified":1564466019605},{"_id":"themes/pure/layout/_partial/post/copyright.ejs","hash":"a45d6ce83fd48e223557116edd7a78749242ff21","modified":1564482215275},{"_id":"themes/pure/layout/_partial/post/donate.ejs","hash":"bdef9836ca91b3e45498a9d98bcaec69e6627ced","modified":1564466019610},{"_id":"themes/pure/layout/_partial/post/date.ejs","hash":"8cbaef422bd7f3d1581d1198dd1c36e4c0e1e46e","modified":1564466019605},{"_id":"themes/pure/layout/_partial/post/gallery.ejs","hash":"b0bf3f5d923c261ca2b5fabab513f1ec2708c8ca","modified":1564466019610},{"_id":"themes/pure/layout/_partial/post/pv.ejs","hash":"946f4bcfa5e5dc4d60c05916c8187bd2c06d1a95","modified":1564466019610},{"_id":"themes/pure/layout/_partial/post/nav.ejs","hash":"15255c9b1644a79be097f6af26f0317a507b0690","modified":1564466019610},{"_id":"themes/pure/layout/_partial/post/tag.ejs","hash":"8fd470b8d52606a90d475f7da9dbbed32742b1c9","modified":1564466019610},{"_id":"themes/pure/layout/_partial/post/thumbnail.ejs","hash":"0d8b9a3aeaed95b74e292c593f0a8225711bfdca","modified":1564466019610},{"_id":"themes/pure/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1564466019610},{"_id":"themes/pure/layout/_partial/post/wordcount.ejs","hash":"81e9a89734505f54fef83dc74d2e277dab1bfa75","modified":1564466019610},{"_id":"themes/pure/layout/_script/_analytics/baidu-analytics.ejs","hash":"829778c19025882fe73cf1b297a36a9d0eff39a1","modified":1564466019610},{"_id":"themes/pure/layout/_script/_analytics/google-analytics.ejs","hash":"4557389e499b89982eb005a821208fdd3dbac627","modified":1564466019610},{"_id":"themes/pure/layout/_script/_analytics/tencent-analytics.ejs","hash":"19585fc666e13a2816d74a8046998ac7fd36f75c","modified":1564466019610},{"_id":"themes/pure/layout/_script/_comment/disqus.ejs","hash":"98dac12a9cbf47098b49183893d714355e2e5999","modified":1564466019615},{"_id":"themes/pure/layout/_script/_comment/gitalk.ejs","hash":"6234ef13a1290f8849ca850641c0be0ab6af8cef","modified":1564466019615},{"_id":"themes/pure/layout/_script/_comment/gitment.ejs","hash":"0af71b5b354fdddd576fbd55c3aeb0221af71e7d","modified":1564466019615},{"_id":"themes/pure/layout/_script/_comment/livere.ejs","hash":"2cc7b1cb7bdf157fe6470eb34a613963df75afa3","modified":1564466019615},{"_id":"themes/pure/layout/_script/_comment/youyan.ejs","hash":"96fcc36560a8367e6c4ba9ec1e82d0c5a730b1b4","modified":1564466019615},{"_id":"themes/pure/layout/_script/_comment/valine.ejs","hash":"19120669bfea521e0b9d2df5bf3a34f0ecb8bb68","modified":1564466019615},{"_id":"themes/pure/layout/_script/_search/baidu.ejs","hash":"72b48dcaab830b615c71f6e810e96100b715c682","modified":1564466019615},{"_id":"themes/pure/layout/_script/_search/insight.ejs","hash":"f95c3289c03fa084afce64e3c399cb5127707f56","modified":1564466019615},{"_id":"themes/pure/source/css/style.min.css","hash":"4e46cbfadf9f0c5c236239a163058a3f525492ce","modified":1564466019650},{"_id":"themes/pure/source/images/donate/wechatpayimg.png","hash":"b751d63c0066f92edebcf478ca0fa38d2e992409","modified":1564481142500},{"_id":"themes/pure/source/images/donate/alipayimg.png","hash":"bd7e9587680824495045c37fdf9545069a0cff25","modified":1564481181992},{"_id":"themes/pure/source/images/favatar/chuangzaoshi-logo.png","hash":"7fa5734072050952159a02d330bbc008b5a99122","modified":1564466019655},{"_id":"themes/pure/source/images/favatar/SzsFox-logo.png","hash":"d71fcc73b7bc2a439d8c7ba461137856d190bd76","modified":1564466019655},{"_id":"themes/pure/source/images/favatar/idesign-logo.png","hash":"6b150a2dbb9912b7a7662255c27e4d4baaecee71","modified":1564466019655},{"_id":"themes/pure/source/js/jquery.min.js","hash":"dacc1f76630a9708add066819b1aabf8dce01056","modified":1564466019655},{"_id":"themes/pure/source/js/plugin.js","hash":"59cb2985d8d21653f0f80ef327517eca86af0ac6","modified":1564466019660},{"_id":"themes/pure/source/js/plugin.js.map","hash":"1730c0cc660f863120aca0a439d7264e2e245fc5","modified":1564466019660},{"_id":"themes/pure/source/css/style.css","hash":"ff0731ff99c03b9120a60e1a70df78d209f7cbf4","modified":1564466019645},{"_id":"themes/pure/source/fonts/iconfont.svg","hash":"1af91521f1c29c231ffc19d7f64696ddcd71470b","modified":1564466019650},{"_id":"themes/pure/screenshot/pure.psd","hash":"a31cea40b45bdc31f051fca2f1e2f4ecbaee1a94","modified":1564466019645},{"_id":"source/about/index.md","hash":"18504622bf27fb939762c2362d851bed0509a91c","modified":1564555288815},{"_id":"source/tags/index.md","hash":"c35ba8af5acf41102909a9f9c1349a24d89f97a6","modified":1564466019600},{"_id":"public/sitemap.xml","hash":"097161fd37d27e941ab5758503862d9e66a0a21b","modified":1564561499257},{"_id":"public/content.json","hash":"3865bd19d663b433c2061857f96dedcaeb7cc2fc","modified":1564561499258},{"_id":"public/about/index.html","hash":"46683079c1dd4475b2b8fed9306188ddefe2ef11","modified":1564561499948},{"_id":"public/tags/index.html","hash":"14b8e743d56f2c81ef0c2fa38f5d9a1ba21957e2","modified":1564561499948},{"_id":"public/categories/index.html","hash":"6921e9f15b5bdc39641c95c1f7ce39fcdd9180f6","modified":1564561499948},{"_id":"public/2019/07/02/身为程序员，你焦虑吗/index.html","hash":"8588fd6479845d2cfecc65e66aad3959e226585a","modified":1564561499949},{"_id":"public/2019/03/11/Android Jetpack之AppCompat - Actionbar篇/index.html","hash":"48c9d803fefdb46187d15eb878f17b792efe713e","modified":1564561499949},{"_id":"public/2019/02/25/抓出卡顿元凶，从分析掉帧开始/index.html","hash":"c53aa9e0632b1620b0c2efd32bce6caf55f01fdb","modified":1564561499949},{"_id":"public/2019/02/20/粮草先行——Android折叠屏开发技术点（二）/index.html","hash":"b316eda338ddb7751ab7f31bbbe1db9ed007b898","modified":1564561499949},{"_id":"public/2019/02/14/粮草先行——Android折叠屏开发技术点番外篇之运行时变更处理原则/index.html","hash":"85ba623c19e2ce1c16b7b27b01501d06449dbaac","modified":1564561499949},{"_id":"public/2019/01/30/粮草先行——Android折叠屏开发技术点（一）/index.html","hash":"70a12e0264ad36bf1e129a899f92a423c0bee8dd","modified":1564561499949},{"_id":"public/2019/01/29/博客园 开博寄语/index.html","hash":"70f60b9453f7ee05389f1a2ec85548dbfd6e21a7","modified":1564561499949},{"_id":"public/2019/01/14/巧用Handler获取View控件信息/index.html","hash":"f7a1b2e967ff21feb3eb1e4c39245c109c296490","modified":1564561499949},{"_id":"public/2018/07/29/优化Activity启动速度的另类解法/index.html","hash":"f6157e92a6235160e5827a2adaf801b39f01fb6a","modified":1564561499949},{"_id":"public/2017/04/06/Android平台下使用ormLite的一个小Tip/index.html","hash":"a2a028e17d0ad34262a38f4bfaf1eacdf0f4c250","modified":1564561499949},{"_id":"public/2017/04/06/解决TextView引起的莫名崩溃/index.html","hash":"513f11ab60cad3ff613f364fb39185824e073465","modified":1564561499949},{"_id":"public/2016/12/22/Mapbox 地图SDK极速集成指导/index.html","hash":"1a62f3c9c380610bd74d66192b45da87f3b06995","modified":1564561499949},{"_id":"public/2016/12/19/Android 6.0 运行时权限简明处理/index.html","hash":"e60f6f42c3f124be414b8210d7133f310fe26f19","modified":1564561499949},{"_id":"public/2016/11/08/搭建React Native环境的几个Tips/index.html","hash":"7d94da163266f176a9d10b27a98df0cefaa2d280","modified":1564561499949},{"_id":"public/2016/10/16/简易实现脸部贴近自动关屏/index.html","hash":"0333421e4c3179329afd1386e7882029ae301652","modified":1564561499950},{"_id":"public/2016/06/16/取之有道——巧用Root权限 启动其他APP中的Activity/index.html","hash":"9c53323ed7c09283817b5a1c5bd71f5276bd3f4e","modified":1564561499950},{"_id":"public/2016/03/16/为了安全——应用锁屏开发实战/index.html","hash":"62ab7855035b0858eb32db1438bc30582443509b","modified":1564561499950},{"_id":"public/2015/11/06/自定义ImageView系列 － 区域截图（下）/index.html","hash":"08acfdc4fb6be7324648fe090b2a62107f9d0347","modified":1564561499950},{"_id":"public/2015/11/04/自定义ImageView系列 － 区域截图（上）/index.html","hash":"cd715fb6237d6149bf264a4b73642551c7a8c695","modified":1564561499950},{"_id":"public/2015/10/27/Activity与DialogFragment交互的方法/index.html","hash":"ac0554c422f84d61d2c9d5f7a1b5035c0ae8a811","modified":1564561499950},{"_id":"public/2015/08/12/Android GridView 点击效果（可能是最快捷的实现，另有福利）/index.html","hash":"b0ea274d17d553a3d52da4ef736518d449be8d65","modified":1564561499950},{"_id":"public/2015/07/08/Android平台录音音量计的实现/index.html","hash":"99029c74c73952295ee0540e4b88ae9afeff6931","modified":1564561499950},{"_id":"public/2015/07/02/调用系统相机导致照片旋转问题的修复/index.html","hash":"7542be748f81c56414c740d254f158a507d68a64","modified":1564561499950},{"_id":"public/2015/07/02/个性化个人主站——使用Hexo框架/index.html","hash":"30da440c419152f469cee0b1528d0f7d593f928b","modified":1564561499950},{"_id":"public/2015/04/21/提升应用崩溃时的用户体验——去掉烦人的“很抱歉”提示框/index.html","hash":"9cbfb7b505f9d4aaa3bd443ce0a57d6c464b82fb","modified":1564561499950},{"_id":"public/2015/03/08/轻松使用Github搭建个人网站/index.html","hash":"6369c8ee7830a6d30b0cabd19d41e5669ff9cde1","modified":1564561499950},{"_id":"public/2014/11/06/IntelliJ IDEA 14 值得你弃用Eclipse的IDE神器/index.html","hash":"7e4868975cefa458d9e86d6244c20d1aa138d83b","modified":1564561499950},{"_id":"public/2014/11/05/Android 5.0(L) ToolBar(替代ActionBar) 实战（四）/index.html","hash":"a7e553e5ef3b2107cbfc63ee8960f4ead5c81c3f","modified":1564561499950},{"_id":"public/2014/11/01/Android 5.0(L) ToolBar(替代ActionBar) 实战（三）/index.html","hash":"8204337dbb6748c6ee006ad9ea67d518cece2d6d","modified":1564561499950},{"_id":"public/2014/10/31/Android 5.0(L) ToolBar(替代ActionBar) 实战（二）/index.html","hash":"aa235ddb58e9b9acf23e895e8b2e34fafaf8f8ed","modified":1564561499951},{"_id":"public/2014/10/30/Android 5.0(L) ToolBar(替代ActionBar) 实战（一）/index.html","hash":"813d2c1d91ce87f3611f5f8f3d2e839519a56529","modified":1564561499951},{"_id":"public/2014/09/11/解决Android录音iOS兼容性问题/index.html","hash":"a032c77d407c7db38cee4f91b45144c7bf22d9cb","modified":1564561499951},{"_id":"public/2014/08/05/Android 重写ImageView实现图片手势功能/index.html","hash":"95a3269b7924b8c1dce15e267efa2d4d3eb62108","modified":1564561499951},{"_id":"public/2014/07/31/Java 文件操作工具类（Android 适用）/index.html","hash":"9a44c607f47c6286cbfa4831c53e8921e62e3e92","modified":1564561499951},{"_id":"public/2014/07/03/微信插件开发手记-聊天界面传送任意类型文件/index.html","hash":"e2824d79f86295b49af022cc4f177bda98c37828","modified":1564561499951},{"_id":"public/2014/06/27/CSDN 开博寄语/index.html","hash":"8288e4b84eb336a484d3a76a2236150b8001d570","modified":1564561499951},{"_id":"public/archives/index.html","hash":"428ccbdc3786237de94a8b4d8ded8dc1969e0eb8","modified":1564561499951},{"_id":"public/archives/page/2/index.html","hash":"be97a937e6e6f073d0b0997d64c403ff3a2c5b8c","modified":1564561499951},{"_id":"public/archives/page/3/index.html","hash":"08e18cd3cb54fab8d4b79f60f3e658cb6c4dcdca","modified":1564561499951},{"_id":"public/archives/page/4/index.html","hash":"6c40d9f6def34aa8b847a695b2df8ff5efc1e454","modified":1564561499951},{"_id":"public/archives/2014/index.html","hash":"5b506af381669da32d66d85a9dc3b64d5cb17051","modified":1564561499951},{"_id":"public/archives/2014/06/index.html","hash":"1d93e4ecf4707a4492e873b2d6cc32c46bf65f02","modified":1564561499951},{"_id":"public/archives/2014/07/index.html","hash":"b4170c3990d3355a816d25409252ef554035c66c","modified":1564561499951},{"_id":"public/archives/2014/08/index.html","hash":"17010235bfb7dd12a630f0568363b25fdf64dacb","modified":1564561499951},{"_id":"public/archives/2014/09/index.html","hash":"01f659ca5022a6bef05046832c074e8753c8cfbb","modified":1564561499952},{"_id":"public/archives/2014/10/index.html","hash":"a48913fbe6e9624e027eea63164b1a3749fa4f56","modified":1564561499952},{"_id":"public/archives/2014/11/index.html","hash":"537b78117597218278d47bc4763622d512e2aef2","modified":1564561499952},{"_id":"public/archives/2015/index.html","hash":"2bbf899eec4b6e8aae1b6db021a34ae16c2a27f2","modified":1564561499952},{"_id":"public/archives/2015/03/index.html","hash":"84decfbb3bc3d97c45e621ae97dff4f1be3d6680","modified":1564561499952},{"_id":"public/archives/2015/04/index.html","hash":"1e9f521817fba464b97078deeca4da7bcb5a1e01","modified":1564561499952},{"_id":"public/archives/2015/07/index.html","hash":"17dec4746b7eea3ad43f25490948d9899a41078e","modified":1564561499952},{"_id":"public/archives/2015/08/index.html","hash":"a35c0eb7562522368a02b44695811ea33c3766be","modified":1564561499952},{"_id":"public/archives/2015/10/index.html","hash":"76560d0e39dd84ef44b4ce1a8e8427b00383f5b2","modified":1564561499952},{"_id":"public/archives/2015/11/index.html","hash":"b45f68593589af42aa89b78ecfa33141637617c3","modified":1564561499952},{"_id":"public/archives/2016/index.html","hash":"d23601eb7250410cd10265c7569b065387133118","modified":1564561499952},{"_id":"public/archives/2016/03/index.html","hash":"3b8c5c85c908068dc7473a9d1ca0885a02ef6a49","modified":1564561499952},{"_id":"public/archives/2016/06/index.html","hash":"3c0c3229b9459c68613f228ce4e08e1e5ee8f709","modified":1564561499952},{"_id":"public/archives/2016/10/index.html","hash":"38b17ebb25cf6ae045dc0915f31ee8191b3428c9","modified":1564561499952},{"_id":"public/archives/2016/11/index.html","hash":"239a9067f9ffed0e4530ee61a82bba2dfc93e0ce","modified":1564561499952},{"_id":"public/archives/2016/12/index.html","hash":"ab87e226683097951e1770fa4b5b36b8568a5c07","modified":1564561499952},{"_id":"public/archives/2017/index.html","hash":"63d3677c6b30feebf96cb8d07acc3b17c2e738ad","modified":1564561499953},{"_id":"public/archives/2017/04/index.html","hash":"a3cf69fbf425da5a14167db9d06e21048a9082d7","modified":1564561499953},{"_id":"public/archives/2018/index.html","hash":"d57a65e0bbeb4c85882412d5da81bc1f3f0a57ca","modified":1564561499953},{"_id":"public/archives/2018/07/index.html","hash":"7559285c8819ed6767eb2c11f84efe5930947872","modified":1564561499953},{"_id":"public/archives/2019/index.html","hash":"68c04359bade1eb16d9ba6e07a463d51a61cafb3","modified":1564561499953},{"_id":"public/archives/2019/01/index.html","hash":"cfe8efb59b2708cf71cccb102882e99dc203ced1","modified":1564561499953},{"_id":"public/archives/2019/02/index.html","hash":"0353c2fd787605010cb01f925000c4b25f4aea61","modified":1564561499953},{"_id":"public/archives/2019/03/index.html","hash":"cd27b8ea18a4f604fd891fd04c7203b165749ad2","modified":1564561499953},{"_id":"public/archives/2019/07/index.html","hash":"ae3a2584f2e825281b4dd06c14e61dc998647682","modified":1564561499953},{"_id":"public/categories/编程世界/index.html","hash":"5ea214940199e785151696e7baa66dc5b424ea59","modified":1564561499954},{"_id":"public/categories/编程世界/page/2/index.html","hash":"5694d5125bbbc706db8beba1620ed992622297aa","modified":1564561499954},{"_id":"public/categories/编程世界/page/3/index.html","hash":"8c65ecad4a27bc061990c61990721bf2380997e3","modified":1564561499954},{"_id":"public/categories/编程世界/page/4/index.html","hash":"541f45763a59f9e9ae31c34314311fe98e2b1f17","modified":1564561499954},{"_id":"public/categories/聊聊人生/index.html","hash":"47603e5030652316defa452f54083ef752888ea1","modified":1564561499954},{"_id":"public/tags/Android/index.html","hash":"08affad21743ea477c6fb10ebe2177049fc43af4","modified":1564561499954},{"_id":"public/tags/Android/page/2/index.html","hash":"8ada39b0e39e62d514c039fb9cd7e9a3f77dd0a5","modified":1564561499955},{"_id":"public/tags/Android/page/3/index.html","hash":"2bc66d11bb673c5d4fdb27f7706d5858136b257c","modified":1564561499955},{"_id":"public/tags/Java/index.html","hash":"b909081b354740d74cd64cc65205bf05ed3d75a9","modified":1564561499955},{"_id":"public/tags/其他/index.html","hash":"a0541a9ab09357628016a9b02087df7052bffbdc","modified":1564561499955},{"_id":"public/tags/Web/index.html","hash":"677e410e986be50ac7329311522b5ea878a8ec50","modified":1564561499955},{"_id":"public/tags/React-Native/index.html","hash":"b8af68405d9566602cc4935b1c1794c3d423a4e1","modified":1564561499956},{"_id":"public/tags/人生杂谈/index.html","hash":"db3dc46f503ea511447fcc8dbfc81f7833798ef9","modified":1564561499956},{"_id":"public/index.html","hash":"71c596fcbdc7fa9f4efc4f702f9a904996623819","modified":1564561499953},{"_id":"public/page/2/index.html","hash":"6043ad8c670e40283c2738f0703b18f54210760e","modified":1564561499953},{"_id":"public/page/3/index.html","hash":"37e16e2baaf65e7c0269757492fe3550060d3a43","modified":1564561499953},{"_id":"public/page/4/index.html","hash":"4476efae94c189ea0f0dbf77f71db3764b461155","modified":1564561499954},{"_id":"public/favicon.png","hash":"71688aa146d231af3df5d4317e38ddf9dc131474","modified":1564561499965},{"_id":"public/fonts/iconfont.eot","hash":"6819d9bb643bdeafc17bfecb0746ae641b018fdf","modified":1564561499965},{"_id":"public/fonts/iconfont.ttf","hash":"9b8837f9f79cf6ab794736301d0665345183a20c","modified":1564561499965},{"_id":"public/fonts/iconfont.woff","hash":"78d29194287b8885d25212048c4f787705212a6e","modified":1564561499965},{"_id":"public/images/thumb-default.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1564561499965},{"_id":"public/images/xingqiu-qrcode.jpg","hash":"ef2c2848dc79db6df7c752510651ed8ba57f2daf","modified":1564561499966},{"_id":"public/images/avatar.jpg","hash":"dc13ce379f5ac6e50c3150745c918ecbf75c9fc7","modified":1564561499966},{"_id":"public/images/donate/alipayimg.png","hash":"bd7e9587680824495045c37fdf9545069a0cff25","modified":1564561499966},{"_id":"public/images/donate/wechatpayimg.png","hash":"b751d63c0066f92edebcf478ca0fa38d2e992409","modified":1564561499992},{"_id":"public/images/favatar/chuangzaoshi-logo.png","hash":"7fa5734072050952159a02d330bbc008b5a99122","modified":1564561499966},{"_id":"public/images/favatar/SzsFox-logo.png","hash":"d71fcc73b7bc2a439d8c7ba461137856d190bd76","modified":1564561499966},{"_id":"public/images/favatar/idesign-logo.png","hash":"6b150a2dbb9912b7a7662255c27e4d4baaecee71","modified":1564561499966},{"_id":"public/js/application.min.js","hash":"34d765e982c7d6360c37f82202d99f63ac40e408","modified":1564561500005},{"_id":"public/js/application.js","hash":"46d1fb207ce5f0acb83803f927985dfcea86f9ef","modified":1564561500005},{"_id":"public/fonts/README.html","hash":"7c1128fed284d2fb7fee743e8a739da99385b358","modified":1564561500005},{"_id":"public/js/plugin.js.map","hash":"1730c0cc660f863120aca0a439d7264e2e245fc5","modified":1564561500005},{"_id":"public/fonts/iconfont.svg","hash":"1af91521f1c29c231ffc19d7f64696ddcd71470b","modified":1564561500037},{"_id":"public/js/insight.js","hash":"298e8ca42517984bd26f34caa4c45560b0e909ad","modified":1564561500009},{"_id":"public/js/plugin.min.js","hash":"07fe34638f9832702c5f81d8583c5e4e8b3d9659","modified":1564561500176},{"_id":"public/js/jquery.min.js","hash":"5a9dcfbef655a2668e78baebeaa8dc6f41d8dabb","modified":1564561500178},{"_id":"public/css/style.min.css","hash":"1d23abc76726ebe042f7df4749f00f8f73338444","modified":1564561500181},{"_id":"public/js/plugin.js","hash":"a8524d42b8621bfaa06602a163c6a1f82702b91d","modified":1564561500183},{"_id":"public/css/style.css","hash":"3b693ce41c2e35ece4773593e94b4c17aeaee02f","modified":1564561500187},{"_id":"source/books/index.md","hash":"d913d58987f539ac2ca4cca366ebf42f8b1a03d1","modified":1564466019595}],"Category":[{"name":"编程世界","_id":"cjyqqcq7p0007vkqd0ppu4nv6"},{"name":"聊聊人生","_id":"cjyqqii840009a0qdhgrd4d09"}],"Data":[],"Page":[{"title":"关于","description":"个人介绍","layout":"about","comments":0,"sidebar":"custom","_content":"","source":"about/index.md","raw":"---\ntitle: 关于\ndescription: 个人介绍\nlayout: about\ncomments: false\nsidebar: custom\n---\n","date":"2019-07-31T06:41:28.815Z","updated":"2019-07-31T06:41:28.815Z","path":"about/index.html","_id":"cjyqrlgry0000woqddqsz4c1y","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","layout":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\nlayout: tags\ncomments: false\n---\n","date":"2019-07-31T04:43:08.954Z","updated":"2019-07-30T05:53:39.600Z","path":"tags/index.html","_id":"cjyqrlgs00001woqd0omhubrl","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"分类","layout":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\nlayout: categories\ncomments: false\n---\n","date":"2019-07-31T04:43:08.959Z","updated":"2019-07-30T05:53:39.595Z","path":"categories/index.html","_id":"cjyqrlgs20002woqd7jth1ioe","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Activity与DialogFragment交互的方法","date":"2015-10-27T12:23:49.000Z","_content":"\n好久没有更新博客了，今天我们来讨论一下如何在Activity与DialogFragment交互的方法，这里包括了DialogFragment的启动以及Activity方法的调用。   \nDialogFragment与Dialog相比类似，是官方现在更建议使用的Dialog。   \n**DialogFragment的定义**  \n新建一个DialogFragment，该类继承DialogFragment。复写onCreateView()方法，在该方法中设置Dialog的布局。这个Dialog的布局可以完全自定义，可以包括任何常见的河自定义的控件。  \n下面是一个实例：  \n\n```\n@Override\npublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {  \n    getDialog().requestWindowFeature(Window.FEATURE_NO_TITLE);\n    View layoutView = inflater.inflate(R.layout.fragment_dialog_login_tip, container, false);     \n```\n\n如上代码块所示，fragment_dialog_login_tip.xml里面我只定义了一个TextView显示一些信息。如果读者想要添加按钮或其他控件，可在这个复写的方法中通过layoutView.findViewById()来初始化并设置监听器。  \n**DialogFragment的启动**  \n要启动一个DialogFragment，要在Activity中new出该类的实例，然后通过.show()方法启动。    \n下面是一个实例：  \n\n```\nFragmentManager fragmentManager = getSupportFragmentManager();\nloginTipDialogFragment = new LoginTipDialogFragment();\nloginTipDialogFragment.setCancelable(false);\nloginTipDialogFragment.show(fragmentManager, \"login_tip_dialog\");\n```\n\n如上所示，这个DialogFragment就可以显示出来了。  \n**从DialogFragment调用Activity中的方法**  \n要从DialogFragment调用Activity中的方法，首先满足下列两点要求：  \n\n\t 1. 该Activity是启动该DialogFragment的；  \n\t 2. 要被调用的方法是public的。\n\n比如，在上面那个启动DialogFragment的Activity中有一个exit()方法，用来退出应用程序，Activity的名字叫做TestActivity。DialogFragment中要实现退出程序可以按照如下方法发起调用：  \n\n```\n((TestActivity)getActivity()).exit();\n```\n\n**从Activity 调用DialogFragment中的方法**  \n这种方式的调用就简单多了。由于有对象实例，直接 .方法名 就可以了。","source":"_posts/Activity与DialogFragment交互的方法.md","raw":"---\ntitle: Activity与DialogFragment交互的方法\ndate: 2015-10-27 20:23:49\ntags: Android\ncategories: 编程世界\n---\n\n好久没有更新博客了，今天我们来讨论一下如何在Activity与DialogFragment交互的方法，这里包括了DialogFragment的启动以及Activity方法的调用。   \nDialogFragment与Dialog相比类似，是官方现在更建议使用的Dialog。   \n**DialogFragment的定义**  \n新建一个DialogFragment，该类继承DialogFragment。复写onCreateView()方法，在该方法中设置Dialog的布局。这个Dialog的布局可以完全自定义，可以包括任何常见的河自定义的控件。  \n下面是一个实例：  \n\n```\n@Override\npublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {  \n    getDialog().requestWindowFeature(Window.FEATURE_NO_TITLE);\n    View layoutView = inflater.inflate(R.layout.fragment_dialog_login_tip, container, false);     \n```\n\n如上代码块所示，fragment_dialog_login_tip.xml里面我只定义了一个TextView显示一些信息。如果读者想要添加按钮或其他控件，可在这个复写的方法中通过layoutView.findViewById()来初始化并设置监听器。  \n**DialogFragment的启动**  \n要启动一个DialogFragment，要在Activity中new出该类的实例，然后通过.show()方法启动。    \n下面是一个实例：  \n\n```\nFragmentManager fragmentManager = getSupportFragmentManager();\nloginTipDialogFragment = new LoginTipDialogFragment();\nloginTipDialogFragment.setCancelable(false);\nloginTipDialogFragment.show(fragmentManager, \"login_tip_dialog\");\n```\n\n如上所示，这个DialogFragment就可以显示出来了。  \n**从DialogFragment调用Activity中的方法**  \n要从DialogFragment调用Activity中的方法，首先满足下列两点要求：  \n\n\t 1. 该Activity是启动该DialogFragment的；  \n\t 2. 要被调用的方法是public的。\n\n比如，在上面那个启动DialogFragment的Activity中有一个exit()方法，用来退出应用程序，Activity的名字叫做TestActivity。DialogFragment中要实现退出程序可以按照如下方法发起调用：  \n\n```\n((TestActivity)getActivity()).exit();\n```\n\n**从Activity 调用DialogFragment中的方法**  \n这种方式的调用就简单多了。由于有对象实例，直接 .方法名 就可以了。","slug":"Activity与DialogFragment交互的方法","published":1,"updated":"2019-07-31T04:09:32.544Z","_id":"cjyqq3tiv0000fkqd501vwtj3","comments":1,"layout":"post","photos":[],"link":"","content":"<p>好久没有更新博客了，今天我们来讨论一下如何在Activity与DialogFragment交互的方法，这里包括了DialogFragment的启动以及Activity方法的调用。<br>DialogFragment与Dialog相比类似，是官方现在更建议使用的Dialog。<br><strong>DialogFragment的定义</strong><br>新建一个DialogFragment，该类继承DialogFragment。复写onCreateView()方法，在该方法中设置Dialog的布局。这个Dialog的布局可以完全自定义，可以包括任何常见的河自定义的控件。<br>下面是一个实例：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;  </span><br><span class=\"line\">    getDialog().requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class=\"line\">    View layoutView = inflater.inflate(R.layout.fragment_dialog_login_tip, container, false);</span><br></pre></td></tr></table></figure>\n\n<p>如上代码块所示，fragment_dialog_login_tip.xml里面我只定义了一个TextView显示一些信息。如果读者想要添加按钮或其他控件，可在这个复写的方法中通过layoutView.findViewById()来初始化并设置监听器。<br><strong>DialogFragment的启动</strong><br>要启动一个DialogFragment，要在Activity中new出该类的实例，然后通过.show()方法启动。<br>下面是一个实例：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FragmentManager fragmentManager = getSupportFragmentManager();</span><br><span class=\"line\">loginTipDialogFragment = new LoginTipDialogFragment();</span><br><span class=\"line\">loginTipDialogFragment.setCancelable(false);</span><br><span class=\"line\">loginTipDialogFragment.show(fragmentManager, &quot;login_tip_dialog&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>如上所示，这个DialogFragment就可以显示出来了。<br><strong>从DialogFragment调用Activity中的方法</strong><br>要从DialogFragment调用Activity中的方法，首先满足下列两点要求：  </p>\n<pre><code>1. 该Activity是启动该DialogFragment的；  \n2. 要被调用的方法是public的。</code></pre><p>比如，在上面那个启动DialogFragment的Activity中有一个exit()方法，用来退出应用程序，Activity的名字叫做TestActivity。DialogFragment中要实现退出程序可以按照如下方法发起调用：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">((TestActivity)getActivity()).exit();</span><br></pre></td></tr></table></figure>\n\n<p><strong>从Activity 调用DialogFragment中的方法</strong><br>这种方式的调用就简单多了。由于有对象实例，直接 .方法名 就可以了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>好久没有更新博客了，今天我们来讨论一下如何在Activity与DialogFragment交互的方法，这里包括了DialogFragment的启动以及Activity方法的调用。<br>DialogFragment与Dialog相比类似，是官方现在更建议使用的Dialog。<br><strong>DialogFragment的定义</strong><br>新建一个DialogFragment，该类继承DialogFragment。复写onCreateView()方法，在该方法中设置Dialog的布局。这个Dialog的布局可以完全自定义，可以包括任何常见的河自定义的控件。<br>下面是一个实例：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;  </span><br><span class=\"line\">    getDialog().requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class=\"line\">    View layoutView = inflater.inflate(R.layout.fragment_dialog_login_tip, container, false);</span><br></pre></td></tr></table></figure>\n\n<p>如上代码块所示，fragment_dialog_login_tip.xml里面我只定义了一个TextView显示一些信息。如果读者想要添加按钮或其他控件，可在这个复写的方法中通过layoutView.findViewById()来初始化并设置监听器。<br><strong>DialogFragment的启动</strong><br>要启动一个DialogFragment，要在Activity中new出该类的实例，然后通过.show()方法启动。<br>下面是一个实例：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FragmentManager fragmentManager = getSupportFragmentManager();</span><br><span class=\"line\">loginTipDialogFragment = new LoginTipDialogFragment();</span><br><span class=\"line\">loginTipDialogFragment.setCancelable(false);</span><br><span class=\"line\">loginTipDialogFragment.show(fragmentManager, &quot;login_tip_dialog&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>如上所示，这个DialogFragment就可以显示出来了。<br><strong>从DialogFragment调用Activity中的方法</strong><br>要从DialogFragment调用Activity中的方法，首先满足下列两点要求：  </p>\n<pre><code>1. 该Activity是启动该DialogFragment的；  \n2. 要被调用的方法是public的。</code></pre><p>比如，在上面那个启动DialogFragment的Activity中有一个exit()方法，用来退出应用程序，Activity的名字叫做TestActivity。DialogFragment中要实现退出程序可以按照如下方法发起调用：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">((TestActivity)getActivity()).exit();</span><br></pre></td></tr></table></figure>\n\n<p><strong>从Activity 调用DialogFragment中的方法</strong><br>这种方式的调用就简单多了。由于有对象实例，直接 .方法名 就可以了。</p>\n"},{"title":"Android 5.0(L) ToolBar(替代ActionBar) 实战（一）","date":"2014-10-30T11:32:59.000Z","_content":"\nAndroid 5.0 SDK 在上周悄然发布了，由于更新了Appcombat V7库，将Google在IO 2014时提到的Material Design的UI界面元素带了进来。从此，开发者可以创建基于Material Design界面设计的APP了。   \n诚然，在更新了新版SDK并引入新的Appcombat库后，发现之前的ActionBar的很多方法已经标记为不建议（Deprecated）的了。经过反复摸索，得知需要用ToolBar来代替古老的ActionBar。   \n那么ToolBar与传统ActionBar相比，有何优越性呢？简单来说：多样、自由。下面来一起看看ToolBar的使用。   \n首先，我们来新建一个项目   \n\n![新建项目](https://img-blog.csdn.net/20141030193650197?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)  \n\n为了更好的兼容之前的版本，因此依旧将最低兼容的Android版本设置为2.2。其他保持默认，一路下一步，然后完成。   \n为了方便开发者，在新建项目的时候Eclipse依然是自动引入了Appcombar库。如果这个时候代码报错，则要看看这个库的引入状况，并且检查一下是否作为Library被导入到新的项目中了。   \n一切就绪的话，进入AndroidMenifest.xml，将ActionBar彻底废掉。废掉老旧的ActionBar的方法十分简单，将application下android:theme元素替换为：@style/Theme.AppCompat.NoActionBar就可以了。当然，下面的activity中切记不要再使用带有ActionBar的主题样式了，否则会报错的。另外，android:label对于Toolbar而言，也没有必要存在了，当然，即使存在这个字段是不会报错的。下面放上整个xml的例子：    \n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.xwh.toolbardemo\"\n    android:versionCode=\"1\"\n    android:versionName=\"1.0\" >\n \n    <uses-sdk\n        android:minSdkVersion=\"8\"\n        android:targetSdkVersion=\"21\" />\n \n    <application\n        android:allowBackup=\"true\"\n        android:icon=\"@drawable/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:theme=\"@style/Theme.AppCompat.NoActionBar\" >\n        <activity\n            android:name=\".MainActivity\"\n            android:label=\"@string/app_name\" >\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n \n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n    </application>\n \n</manifest>\n```\n\n下面我们来到MainActivity的布局文件：activity_main.xml。如果你的SDK已经更新为最新而且此项目也是配置为5.0的编译状态下时，在布局预览视图中将会如下所示：    \n\n![布局预览 深色主题](https://img-blog.csdn.net/20141030193706094?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n可以看到，预览窗格中，已经完全是5.0的UI设计风格了。至于为什么是深色的主题，是因为之前在AndroidMenifest.xml中设置了Theme.AppCompat.NoActionBar。换言之，如果我们设置成Theme.AppCompat.Light.NoActionBar，则会呈现浅色的主题。   \n\n![布局预览 浅色主题](https://img-blog.csdn.net/20141030193718168?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n下面切换到代码视图。对于ActionBar，我们无需关心在xml布局中的位置，只需要在Java代码中进行设置即可。而对于ToolBar，是要求我们自己写到Layout（布局xml）中的。这也就意味着它可以出现在任意一个我们希望它出现的位置，甚至能够同时存在多个ToolBar，并且互不干扰（参考多个ImageView，或者多个TextView等等）。   \n我们可以通过创建android.support.v7.widget.Toolbar控件来显示自定义的Toolbar，参考下面的代码：   \n\n```\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    xmlns:app=\"http://schemas.android.com/apk/res/com.xwh.toolbardemo\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\"com.xwh.toolbardemo.MainActivity\" >\n \n    <android.support.v7.widget.Toolbar\n        android:id=\"@+id/demo_toolbar\"\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"wrap_content\"\n        android:background=\"?attr/colorPrimary\"\n        android:minHeight=\"?attr/actionBarSize\"\n        app:title=\"@string/hello_world\" />\n \n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_below=\"@+id/demo_toolbar\"\n        android:text=\"@string/hello_world\" />\n \n</RelativeLayout>\n```\n\n关于Toolbar的可用属性，这里不多做赘述，大家可以去安卓开发者官网自行搜索API。   \n到此，这个Toolbar已经可以正常显示了，并且其标题为“Hello World”。而且诸位可以发现，从Toolbar的创建到显示，我们还没有写过一句Java代码。   \n下面放上运行效果截图：   \n\n![运行效果截图](https://img-blog.csdn.net/20141030193730102?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)  \n在下一篇博文中，我们将集中介绍如何使用Toolbar，结合ViewPager，实现类似微信的滑动切换多视图效果。  ","source":"_posts/Android 5.0(L) ToolBar(替代ActionBar) 实战（一）.md","raw":"---\ntitle: Android 5.0(L) ToolBar(替代ActionBar) 实战（一）\ndate: 2014-10-30 19:32:59\ntags: Android\ncategories: 编程世界\n---\n\nAndroid 5.0 SDK 在上周悄然发布了，由于更新了Appcombat V7库，将Google在IO 2014时提到的Material Design的UI界面元素带了进来。从此，开发者可以创建基于Material Design界面设计的APP了。   \n诚然，在更新了新版SDK并引入新的Appcombat库后，发现之前的ActionBar的很多方法已经标记为不建议（Deprecated）的了。经过反复摸索，得知需要用ToolBar来代替古老的ActionBar。   \n那么ToolBar与传统ActionBar相比，有何优越性呢？简单来说：多样、自由。下面来一起看看ToolBar的使用。   \n首先，我们来新建一个项目   \n\n![新建项目](https://img-blog.csdn.net/20141030193650197?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)  \n\n为了更好的兼容之前的版本，因此依旧将最低兼容的Android版本设置为2.2。其他保持默认，一路下一步，然后完成。   \n为了方便开发者，在新建项目的时候Eclipse依然是自动引入了Appcombar库。如果这个时候代码报错，则要看看这个库的引入状况，并且检查一下是否作为Library被导入到新的项目中了。   \n一切就绪的话，进入AndroidMenifest.xml，将ActionBar彻底废掉。废掉老旧的ActionBar的方法十分简单，将application下android:theme元素替换为：@style/Theme.AppCompat.NoActionBar就可以了。当然，下面的activity中切记不要再使用带有ActionBar的主题样式了，否则会报错的。另外，android:label对于Toolbar而言，也没有必要存在了，当然，即使存在这个字段是不会报错的。下面放上整个xml的例子：    \n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.xwh.toolbardemo\"\n    android:versionCode=\"1\"\n    android:versionName=\"1.0\" >\n \n    <uses-sdk\n        android:minSdkVersion=\"8\"\n        android:targetSdkVersion=\"21\" />\n \n    <application\n        android:allowBackup=\"true\"\n        android:icon=\"@drawable/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:theme=\"@style/Theme.AppCompat.NoActionBar\" >\n        <activity\n            android:name=\".MainActivity\"\n            android:label=\"@string/app_name\" >\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n \n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n    </application>\n \n</manifest>\n```\n\n下面我们来到MainActivity的布局文件：activity_main.xml。如果你的SDK已经更新为最新而且此项目也是配置为5.0的编译状态下时，在布局预览视图中将会如下所示：    \n\n![布局预览 深色主题](https://img-blog.csdn.net/20141030193706094?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n可以看到，预览窗格中，已经完全是5.0的UI设计风格了。至于为什么是深色的主题，是因为之前在AndroidMenifest.xml中设置了Theme.AppCompat.NoActionBar。换言之，如果我们设置成Theme.AppCompat.Light.NoActionBar，则会呈现浅色的主题。   \n\n![布局预览 浅色主题](https://img-blog.csdn.net/20141030193718168?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n下面切换到代码视图。对于ActionBar，我们无需关心在xml布局中的位置，只需要在Java代码中进行设置即可。而对于ToolBar，是要求我们自己写到Layout（布局xml）中的。这也就意味着它可以出现在任意一个我们希望它出现的位置，甚至能够同时存在多个ToolBar，并且互不干扰（参考多个ImageView，或者多个TextView等等）。   \n我们可以通过创建android.support.v7.widget.Toolbar控件来显示自定义的Toolbar，参考下面的代码：   \n\n```\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    xmlns:app=\"http://schemas.android.com/apk/res/com.xwh.toolbardemo\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\"com.xwh.toolbardemo.MainActivity\" >\n \n    <android.support.v7.widget.Toolbar\n        android:id=\"@+id/demo_toolbar\"\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"wrap_content\"\n        android:background=\"?attr/colorPrimary\"\n        android:minHeight=\"?attr/actionBarSize\"\n        app:title=\"@string/hello_world\" />\n \n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_below=\"@+id/demo_toolbar\"\n        android:text=\"@string/hello_world\" />\n \n</RelativeLayout>\n```\n\n关于Toolbar的可用属性，这里不多做赘述，大家可以去安卓开发者官网自行搜索API。   \n到此，这个Toolbar已经可以正常显示了，并且其标题为“Hello World”。而且诸位可以发现，从Toolbar的创建到显示，我们还没有写过一句Java代码。   \n下面放上运行效果截图：   \n\n![运行效果截图](https://img-blog.csdn.net/20141030193730102?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)  \n在下一篇博文中，我们将集中介绍如何使用Toolbar，结合ViewPager，实现类似微信的滑动切换多视图效果。  ","slug":"Android 5.0(L) ToolBar(替代ActionBar) 实战（一）","published":1,"updated":"2019-07-31T04:09:41.547Z","_id":"cjyqq3tj10002fkqdjkyoawrm","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Android 5.0 SDK 在上周悄然发布了，由于更新了Appcombat V7库，将Google在IO 2014时提到的Material Design的UI界面元素带了进来。从此，开发者可以创建基于Material Design界面设计的APP了。<br>诚然，在更新了新版SDK并引入新的Appcombat库后，发现之前的ActionBar的很多方法已经标记为不建议（Deprecated）的了。经过反复摸索，得知需要用ToolBar来代替古老的ActionBar。<br>那么ToolBar与传统ActionBar相比，有何优越性呢？简单来说：多样、自由。下面来一起看看ToolBar的使用。<br>首先，我们来新建一个项目   </p>\n<p><img src=\"https://img-blog.csdn.net/20141030193650197?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"新建项目\">  </p>\n<p>为了更好的兼容之前的版本，因此依旧将最低兼容的Android版本设置为2.2。其他保持默认，一路下一步，然后完成。<br>为了方便开发者，在新建项目的时候Eclipse依然是自动引入了Appcombar库。如果这个时候代码报错，则要看看这个库的引入状况，并且检查一下是否作为Library被导入到新的项目中了。<br>一切就绪的话，进入AndroidMenifest.xml，将ActionBar彻底废掉。废掉老旧的ActionBar的方法十分简单，将application下android:theme元素替换为：@style/Theme.AppCompat.NoActionBar就可以了。当然，下面的activity中切记不要再使用带有ActionBar的主题样式了，否则会报错的。另外，android:label对于Toolbar而言，也没有必要存在了，当然，即使存在这个字段是不会报错的。下面放上整个xml的例子：    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    package=&quot;com.xwh.toolbardemo&quot;</span><br><span class=\"line\">    android:versionCode=&quot;1&quot;</span><br><span class=\"line\">    android:versionName=&quot;1.0&quot; &gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &lt;uses-sdk</span><br><span class=\"line\">        android:minSdkVersion=&quot;8&quot;</span><br><span class=\"line\">        android:targetSdkVersion=&quot;21&quot; /&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &lt;application</span><br><span class=\"line\">        android:allowBackup=&quot;true&quot;</span><br><span class=\"line\">        android:icon=&quot;@drawable/ic_launcher&quot;</span><br><span class=\"line\">        android:label=&quot;@string/app_name&quot;</span><br><span class=\"line\">        android:theme=&quot;@style/Theme.AppCompat.NoActionBar&quot; &gt;</span><br><span class=\"line\">        &lt;activity</span><br><span class=\"line\">            android:name=&quot;.MainActivity&quot;</span><br><span class=\"line\">            android:label=&quot;@string/app_name&quot; &gt;</span><br><span class=\"line\">            &lt;intent-filter&gt;</span><br><span class=\"line\">                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</span><br><span class=\"line\">            &lt;/intent-filter&gt;</span><br><span class=\"line\">        &lt;/activity&gt;</span><br><span class=\"line\">    &lt;/application&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>\n\n<p>下面我们来到MainActivity的布局文件：activity_main.xml。如果你的SDK已经更新为最新而且此项目也是配置为5.0的编译状态下时，在布局预览视图中将会如下所示：    </p>\n<p><img src=\"https://img-blog.csdn.net/20141030193706094?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"布局预览 深色主题\"></p>\n<p>可以看到，预览窗格中，已经完全是5.0的UI设计风格了。至于为什么是深色的主题，是因为之前在AndroidMenifest.xml中设置了Theme.AppCompat.NoActionBar。换言之，如果我们设置成Theme.AppCompat.Light.NoActionBar，则会呈现浅色的主题。   </p>\n<p><img src=\"https://img-blog.csdn.net/20141030193718168?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"布局预览 浅色主题\"></p>\n<p>下面切换到代码视图。对于ActionBar，我们无需关心在xml布局中的位置，只需要在Java代码中进行设置即可。而对于ToolBar，是要求我们自己写到Layout（布局xml）中的。这也就意味着它可以出现在任意一个我们希望它出现的位置，甚至能够同时存在多个ToolBar，并且互不干扰（参考多个ImageView，或者多个TextView等等）。<br>我们可以通过创建android.support.v7.widget.Toolbar控件来显示自定义的Toolbar，参考下面的代码：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class=\"line\">    xmlns:app=&quot;http://schemas.android.com/apk/res/com.xwh.toolbardemo&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">    tools:context=&quot;com.xwh.toolbardemo.MainActivity&quot; &gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &lt;android.support.v7.widget.Toolbar</span><br><span class=\"line\">        android:id=&quot;@+id/demo_toolbar&quot;</span><br><span class=\"line\">        android:layout_width=&quot;fill_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:background=&quot;?attr/colorPrimary&quot;</span><br><span class=\"line\">        android:minHeight=&quot;?attr/actionBarSize&quot;</span><br><span class=\"line\">        app:title=&quot;@string/hello_world&quot; /&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &lt;TextView</span><br><span class=\"line\">        android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_below=&quot;@+id/demo_toolbar&quot;</span><br><span class=\"line\">        android:text=&quot;@string/hello_world&quot; /&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure>\n\n<p>关于Toolbar的可用属性，这里不多做赘述，大家可以去安卓开发者官网自行搜索API。<br>到此，这个Toolbar已经可以正常显示了，并且其标题为“Hello World”。而且诸位可以发现，从Toolbar的创建到显示，我们还没有写过一句Java代码。<br>下面放上运行效果截图：   </p>\n<p><img src=\"https://img-blog.csdn.net/20141030193730102?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"运行效果截图\"><br>在下一篇博文中，我们将集中介绍如何使用Toolbar，结合ViewPager，实现类似微信的滑动切换多视图效果。  </p>\n","site":{"data":{}},"excerpt":"","more":"<p>Android 5.0 SDK 在上周悄然发布了，由于更新了Appcombat V7库，将Google在IO 2014时提到的Material Design的UI界面元素带了进来。从此，开发者可以创建基于Material Design界面设计的APP了。<br>诚然，在更新了新版SDK并引入新的Appcombat库后，发现之前的ActionBar的很多方法已经标记为不建议（Deprecated）的了。经过反复摸索，得知需要用ToolBar来代替古老的ActionBar。<br>那么ToolBar与传统ActionBar相比，有何优越性呢？简单来说：多样、自由。下面来一起看看ToolBar的使用。<br>首先，我们来新建一个项目   </p>\n<p><img src=\"https://img-blog.csdn.net/20141030193650197?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"新建项目\">  </p>\n<p>为了更好的兼容之前的版本，因此依旧将最低兼容的Android版本设置为2.2。其他保持默认，一路下一步，然后完成。<br>为了方便开发者，在新建项目的时候Eclipse依然是自动引入了Appcombar库。如果这个时候代码报错，则要看看这个库的引入状况，并且检查一下是否作为Library被导入到新的项目中了。<br>一切就绪的话，进入AndroidMenifest.xml，将ActionBar彻底废掉。废掉老旧的ActionBar的方法十分简单，将application下android:theme元素替换为：@style/Theme.AppCompat.NoActionBar就可以了。当然，下面的activity中切记不要再使用带有ActionBar的主题样式了，否则会报错的。另外，android:label对于Toolbar而言，也没有必要存在了，当然，即使存在这个字段是不会报错的。下面放上整个xml的例子：    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    package=&quot;com.xwh.toolbardemo&quot;</span><br><span class=\"line\">    android:versionCode=&quot;1&quot;</span><br><span class=\"line\">    android:versionName=&quot;1.0&quot; &gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &lt;uses-sdk</span><br><span class=\"line\">        android:minSdkVersion=&quot;8&quot;</span><br><span class=\"line\">        android:targetSdkVersion=&quot;21&quot; /&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &lt;application</span><br><span class=\"line\">        android:allowBackup=&quot;true&quot;</span><br><span class=\"line\">        android:icon=&quot;@drawable/ic_launcher&quot;</span><br><span class=\"line\">        android:label=&quot;@string/app_name&quot;</span><br><span class=\"line\">        android:theme=&quot;@style/Theme.AppCompat.NoActionBar&quot; &gt;</span><br><span class=\"line\">        &lt;activity</span><br><span class=\"line\">            android:name=&quot;.MainActivity&quot;</span><br><span class=\"line\">            android:label=&quot;@string/app_name&quot; &gt;</span><br><span class=\"line\">            &lt;intent-filter&gt;</span><br><span class=\"line\">                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</span><br><span class=\"line\">            &lt;/intent-filter&gt;</span><br><span class=\"line\">        &lt;/activity&gt;</span><br><span class=\"line\">    &lt;/application&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>\n\n<p>下面我们来到MainActivity的布局文件：activity_main.xml。如果你的SDK已经更新为最新而且此项目也是配置为5.0的编译状态下时，在布局预览视图中将会如下所示：    </p>\n<p><img src=\"https://img-blog.csdn.net/20141030193706094?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"布局预览 深色主题\"></p>\n<p>可以看到，预览窗格中，已经完全是5.0的UI设计风格了。至于为什么是深色的主题，是因为之前在AndroidMenifest.xml中设置了Theme.AppCompat.NoActionBar。换言之，如果我们设置成Theme.AppCompat.Light.NoActionBar，则会呈现浅色的主题。   </p>\n<p><img src=\"https://img-blog.csdn.net/20141030193718168?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"布局预览 浅色主题\"></p>\n<p>下面切换到代码视图。对于ActionBar，我们无需关心在xml布局中的位置，只需要在Java代码中进行设置即可。而对于ToolBar，是要求我们自己写到Layout（布局xml）中的。这也就意味着它可以出现在任意一个我们希望它出现的位置，甚至能够同时存在多个ToolBar，并且互不干扰（参考多个ImageView，或者多个TextView等等）。<br>我们可以通过创建android.support.v7.widget.Toolbar控件来显示自定义的Toolbar，参考下面的代码：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class=\"line\">    xmlns:app=&quot;http://schemas.android.com/apk/res/com.xwh.toolbardemo&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">    tools:context=&quot;com.xwh.toolbardemo.MainActivity&quot; &gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &lt;android.support.v7.widget.Toolbar</span><br><span class=\"line\">        android:id=&quot;@+id/demo_toolbar&quot;</span><br><span class=\"line\">        android:layout_width=&quot;fill_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:background=&quot;?attr/colorPrimary&quot;</span><br><span class=\"line\">        android:minHeight=&quot;?attr/actionBarSize&quot;</span><br><span class=\"line\">        app:title=&quot;@string/hello_world&quot; /&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &lt;TextView</span><br><span class=\"line\">        android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_below=&quot;@+id/demo_toolbar&quot;</span><br><span class=\"line\">        android:text=&quot;@string/hello_world&quot; /&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure>\n\n<p>关于Toolbar的可用属性，这里不多做赘述，大家可以去安卓开发者官网自行搜索API。<br>到此，这个Toolbar已经可以正常显示了，并且其标题为“Hello World”。而且诸位可以发现，从Toolbar的创建到显示，我们还没有写过一句Java代码。<br>下面放上运行效果截图：   </p>\n<p><img src=\"https://img-blog.csdn.net/20141030193730102?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"运行效果截图\"><br>在下一篇博文中，我们将集中介绍如何使用Toolbar，结合ViewPager，实现类似微信的滑动切换多视图效果。  </p>\n"},{"title":"Android 5.0(L) ToolBar(替代ActionBar) 实战（四）","date":"2014-11-05T08:30:22.000Z","_content":"\n休息了三天后，我又回来了，我们继续讨论Toolbar。   \n如果此前你是跟着连载一步一步走下来的，那么你应该会注意到MainActivity是一直在报警告的。因为其中我们声明了toolbar对象，但是一直没有使用。如果要实现菜单功能的话，就要使用了。   \n结合Toolbar使用菜单还是很容易的。只需在MainActivity中重写onCreateOptionsMenu()和onOptionsItemSelected()就可以了。这种方法已经有着悠久的历史，这里就不再多说了。   \n回忆一下ActionBar，此前的ActionBar在实现菜单时，如果遇到虚拟按键的机器，会在Activity的右上角显示菜单。如果遇到实体按键的机器，则不会，用户需要手动去触摸菜单键才能激活菜单。这其实是不太合理的，作为用户，很有可能不知道应用中还有菜单。因此，在Toolbar中，这个问题得到了很好的修复。效果就是，无论是否存在实体按键，右上角都会显示菜单，而要实现这一效果也是及其容易的，只需要下面的一句话：   \n\n```\nsetSupportActionBar(toolbar);\n```\n\n下面放上效果图：   \n\n![显示菜单项](https://img-blog.csdn.net/20141105161803835?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n细心的朋友可以发现，上方的Toolbar已经改变了样式，那么它又是如何实现的呢？   \n这里有两种方法：   \n\n - 在每个具有Toolbar的布局文件中定义风格；\n - 在AndroidManifest中指向统一的应用主题样式。\n\n前者不必多说，只需要在布局文件中指定特定字段的值就好。这里详细说下后者。   \n首先我们在布局文件中，除了Toolbar的位置、标题文本和ID外，不要给定任何其他的值，比如：   \n\n```\n <android.support.v7.widget.Toolbar\n        android:id=\"@+id/demo_toolbar\"\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"wrap_content\"\n        app:title=\"@string/hello_world\" />\n```\n\n然后，在values文件夹中创建theme.xml，在其中定义主题风格，下面列出这段程序清单：   \n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources xmlns:android=\"http://schemas.android.com/apk/res/android\">\n \n    <!-- 默认的蓝色风格 -->\n    <style name=\"DefaultBlueTheme\" parent=\"@style/Theme.AppCompat.Light.NoActionBar\">\n        <!-- Toolbar风格 -->\n        <item name=\"toolbarStyle\">@style/DefaultBlueToolbar</item>\n    </style>\n \n    <!-- 默认的Toolbar样式 -->\n    <style name=\"DefaultBlueToolbar\" parent=\"@style/Widget.AppCompat.Toolbar\">\n        <item name=\"android:background\">@color/default_blue</item>\n        <item name=\"titleTextAppearance\">@style/ToolBarTitleTextStyle</item>\n    </style>\n \n</resources>\n```\n\n引用的颜色值如下，在color.xml中定义：   \n\n```\n<color name=\"default_blue\">#33B5E5</color>\n<color name=\"default_white\">#FFFFFF</color>\n```\n\n这样就实现了上图的效果。","source":"_posts/Android 5.0(L) ToolBar(替代ActionBar) 实战（四）.md","raw":"---\ntitle: Android 5.0(L) ToolBar(替代ActionBar) 实战（四）\ndate: 2014-11-05 16:30:22\ntags: Android\ncategories: 编程世界\n---\n\n休息了三天后，我又回来了，我们继续讨论Toolbar。   \n如果此前你是跟着连载一步一步走下来的，那么你应该会注意到MainActivity是一直在报警告的。因为其中我们声明了toolbar对象，但是一直没有使用。如果要实现菜单功能的话，就要使用了。   \n结合Toolbar使用菜单还是很容易的。只需在MainActivity中重写onCreateOptionsMenu()和onOptionsItemSelected()就可以了。这种方法已经有着悠久的历史，这里就不再多说了。   \n回忆一下ActionBar，此前的ActionBar在实现菜单时，如果遇到虚拟按键的机器，会在Activity的右上角显示菜单。如果遇到实体按键的机器，则不会，用户需要手动去触摸菜单键才能激活菜单。这其实是不太合理的，作为用户，很有可能不知道应用中还有菜单。因此，在Toolbar中，这个问题得到了很好的修复。效果就是，无论是否存在实体按键，右上角都会显示菜单，而要实现这一效果也是及其容易的，只需要下面的一句话：   \n\n```\nsetSupportActionBar(toolbar);\n```\n\n下面放上效果图：   \n\n![显示菜单项](https://img-blog.csdn.net/20141105161803835?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n细心的朋友可以发现，上方的Toolbar已经改变了样式，那么它又是如何实现的呢？   \n这里有两种方法：   \n\n - 在每个具有Toolbar的布局文件中定义风格；\n - 在AndroidManifest中指向统一的应用主题样式。\n\n前者不必多说，只需要在布局文件中指定特定字段的值就好。这里详细说下后者。   \n首先我们在布局文件中，除了Toolbar的位置、标题文本和ID外，不要给定任何其他的值，比如：   \n\n```\n <android.support.v7.widget.Toolbar\n        android:id=\"@+id/demo_toolbar\"\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"wrap_content\"\n        app:title=\"@string/hello_world\" />\n```\n\n然后，在values文件夹中创建theme.xml，在其中定义主题风格，下面列出这段程序清单：   \n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources xmlns:android=\"http://schemas.android.com/apk/res/android\">\n \n    <!-- 默认的蓝色风格 -->\n    <style name=\"DefaultBlueTheme\" parent=\"@style/Theme.AppCompat.Light.NoActionBar\">\n        <!-- Toolbar风格 -->\n        <item name=\"toolbarStyle\">@style/DefaultBlueToolbar</item>\n    </style>\n \n    <!-- 默认的Toolbar样式 -->\n    <style name=\"DefaultBlueToolbar\" parent=\"@style/Widget.AppCompat.Toolbar\">\n        <item name=\"android:background\">@color/default_blue</item>\n        <item name=\"titleTextAppearance\">@style/ToolBarTitleTextStyle</item>\n    </style>\n \n</resources>\n```\n\n引用的颜色值如下，在color.xml中定义：   \n\n```\n<color name=\"default_blue\">#33B5E5</color>\n<color name=\"default_white\">#FFFFFF</color>\n```\n\n这样就实现了上图的效果。","slug":"Android 5.0(L) ToolBar(替代ActionBar) 实战（四）","published":1,"updated":"2019-07-31T04:10:04.355Z","_id":"cjyqq3tj40004fkqdfds3xb8m","comments":1,"layout":"post","photos":[],"link":"","content":"<p>休息了三天后，我又回来了，我们继续讨论Toolbar。<br>如果此前你是跟着连载一步一步走下来的，那么你应该会注意到MainActivity是一直在报警告的。因为其中我们声明了toolbar对象，但是一直没有使用。如果要实现菜单功能的话，就要使用了。<br>结合Toolbar使用菜单还是很容易的。只需在MainActivity中重写onCreateOptionsMenu()和onOptionsItemSelected()就可以了。这种方法已经有着悠久的历史，这里就不再多说了。<br>回忆一下ActionBar，此前的ActionBar在实现菜单时，如果遇到虚拟按键的机器，会在Activity的右上角显示菜单。如果遇到实体按键的机器，则不会，用户需要手动去触摸菜单键才能激活菜单。这其实是不太合理的，作为用户，很有可能不知道应用中还有菜单。因此，在Toolbar中，这个问题得到了很好的修复。效果就是，无论是否存在实体按键，右上角都会显示菜单，而要实现这一效果也是及其容易的，只需要下面的一句话：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setSupportActionBar(toolbar);</span><br></pre></td></tr></table></figure>\n\n<p>下面放上效果图：   </p>\n<p><img src=\"https://img-blog.csdn.net/20141105161803835?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"显示菜单项\"></p>\n<p>细心的朋友可以发现，上方的Toolbar已经改变了样式，那么它又是如何实现的呢？<br>这里有两种方法：   </p>\n<ul>\n<li>在每个具有Toolbar的布局文件中定义风格；</li>\n<li>在AndroidManifest中指向统一的应用主题样式。</li>\n</ul>\n<p>前者不必多说，只需要在布局文件中指定特定字段的值就好。这里详细说下后者。<br>首先我们在布局文件中，除了Toolbar的位置、标题文本和ID外，不要给定任何其他的值，比如：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;android.support.v7.widget.Toolbar</span><br><span class=\"line\">       android:id=&quot;@+id/demo_toolbar&quot;</span><br><span class=\"line\">       android:layout_width=&quot;fill_parent&quot;</span><br><span class=\"line\">       android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">       app:title=&quot;@string/hello_world&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>然后，在values文件夹中创建theme.xml，在其中定义主题风格，下面列出这段程序清单：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;resources xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &lt;!-- 默认的蓝色风格 --&gt;</span><br><span class=\"line\">    &lt;style name=&quot;DefaultBlueTheme&quot; parent=&quot;@style/Theme.AppCompat.Light.NoActionBar&quot;&gt;</span><br><span class=\"line\">        &lt;!-- Toolbar风格 --&gt;</span><br><span class=\"line\">        &lt;item name=&quot;toolbarStyle&quot;&gt;@style/DefaultBlueToolbar&lt;/item&gt;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &lt;!-- 默认的Toolbar样式 --&gt;</span><br><span class=\"line\">    &lt;style name=&quot;DefaultBlueToolbar&quot; parent=&quot;@style/Widget.AppCompat.Toolbar&quot;&gt;</span><br><span class=\"line\">        &lt;item name=&quot;android:background&quot;&gt;@color/default_blue&lt;/item&gt;</span><br><span class=\"line\">        &lt;item name=&quot;titleTextAppearance&quot;&gt;@style/ToolBarTitleTextStyle&lt;/item&gt;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>\n\n<p>引用的颜色值如下，在color.xml中定义：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;color name=&quot;default_blue&quot;&gt;#33B5E5&lt;/color&gt;</span><br><span class=\"line\">&lt;color name=&quot;default_white&quot;&gt;#FFFFFF&lt;/color&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这样就实现了上图的效果。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>休息了三天后，我又回来了，我们继续讨论Toolbar。<br>如果此前你是跟着连载一步一步走下来的，那么你应该会注意到MainActivity是一直在报警告的。因为其中我们声明了toolbar对象，但是一直没有使用。如果要实现菜单功能的话，就要使用了。<br>结合Toolbar使用菜单还是很容易的。只需在MainActivity中重写onCreateOptionsMenu()和onOptionsItemSelected()就可以了。这种方法已经有着悠久的历史，这里就不再多说了。<br>回忆一下ActionBar，此前的ActionBar在实现菜单时，如果遇到虚拟按键的机器，会在Activity的右上角显示菜单。如果遇到实体按键的机器，则不会，用户需要手动去触摸菜单键才能激活菜单。这其实是不太合理的，作为用户，很有可能不知道应用中还有菜单。因此，在Toolbar中，这个问题得到了很好的修复。效果就是，无论是否存在实体按键，右上角都会显示菜单，而要实现这一效果也是及其容易的，只需要下面的一句话：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setSupportActionBar(toolbar);</span><br></pre></td></tr></table></figure>\n\n<p>下面放上效果图：   </p>\n<p><img src=\"https://img-blog.csdn.net/20141105161803835?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"显示菜单项\"></p>\n<p>细心的朋友可以发现，上方的Toolbar已经改变了样式，那么它又是如何实现的呢？<br>这里有两种方法：   </p>\n<ul>\n<li>在每个具有Toolbar的布局文件中定义风格；</li>\n<li>在AndroidManifest中指向统一的应用主题样式。</li>\n</ul>\n<p>前者不必多说，只需要在布局文件中指定特定字段的值就好。这里详细说下后者。<br>首先我们在布局文件中，除了Toolbar的位置、标题文本和ID外，不要给定任何其他的值，比如：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;android.support.v7.widget.Toolbar</span><br><span class=\"line\">       android:id=&quot;@+id/demo_toolbar&quot;</span><br><span class=\"line\">       android:layout_width=&quot;fill_parent&quot;</span><br><span class=\"line\">       android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">       app:title=&quot;@string/hello_world&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>然后，在values文件夹中创建theme.xml，在其中定义主题风格，下面列出这段程序清单：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;resources xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &lt;!-- 默认的蓝色风格 --&gt;</span><br><span class=\"line\">    &lt;style name=&quot;DefaultBlueTheme&quot; parent=&quot;@style/Theme.AppCompat.Light.NoActionBar&quot;&gt;</span><br><span class=\"line\">        &lt;!-- Toolbar风格 --&gt;</span><br><span class=\"line\">        &lt;item name=&quot;toolbarStyle&quot;&gt;@style/DefaultBlueToolbar&lt;/item&gt;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &lt;!-- 默认的Toolbar样式 --&gt;</span><br><span class=\"line\">    &lt;style name=&quot;DefaultBlueToolbar&quot; parent=&quot;@style/Widget.AppCompat.Toolbar&quot;&gt;</span><br><span class=\"line\">        &lt;item name=&quot;android:background&quot;&gt;@color/default_blue&lt;/item&gt;</span><br><span class=\"line\">        &lt;item name=&quot;titleTextAppearance&quot;&gt;@style/ToolBarTitleTextStyle&lt;/item&gt;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>\n\n<p>引用的颜色值如下，在color.xml中定义：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;color name=&quot;default_blue&quot;&gt;#33B5E5&lt;/color&gt;</span><br><span class=\"line\">&lt;color name=&quot;default_white&quot;&gt;#FFFFFF&lt;/color&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这样就实现了上图的效果。</p>\n"},{"title":"Android 5.0(L) ToolBar(替代ActionBar) 实战（二）","date":"2014-10-31T09:16:27.000Z","_content":"\n上一次我们说到ToolBar的创建，这次我们来讨论一下ToolBar结合ViewPager实现类似微信的左右滑屏多个界面的效果。    \n要实现滑屏，首先我们要到Android开发者官网去下载一个示例代码，它封装了Viewpager和Tab配合切换页卡的方法。当然，我们也可以自己来实现，为了节约时间成本，就直接拿来用了。如果在官网找不到或者无奈被墙，可以到这里下载：http://download.csdn.net/detail/wh1990xiao2005/8105345   \n\n把下载好的工具类复制到项目指定的包内，我是在之前的项目中创建了view专用的包，并将这两个类复制了进去。   \n\n![项目结构](https://img-blog.csdn.net/20141031161432427?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n这里要注意，复制进去之后有可能会报错，因为包名不符，只需把package包名修改为自己的类所在包名即可。   \n打开布局文件，在上次Toolbar的声明下面添加SlidingTabLayout和ViewPager控件，下面放上示例：   \n\n```\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    xmlns:app=\"http://schemas.android.com/apk/res/com.xwh.toolbardemo\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\"com.xwh.toolbardemo.MainActivity\" >\n \n    <android.support.v7.widget.Toolbar\n        android:id=\"@+id/demo_toolbar\"\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"wrap_content\"\n        android:background=\"?attr/colorPrimary\"\n        android:minHeight=\"?attr/actionBarSize\"\n        app:title=\"@string/hello_world\" />\n \n    <com.xwh.toolbardemo.view.SlidingTabLayout\n        android:id=\"@+id/demo_tab\"\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"wrap_content\"\n        android:layout_below=\"@+id/demo_toolbar\" />\n \n    <android.support.v4.view.ViewPager\n        android:id=\"@+id/demo_vp\"\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"fill_parent\"\n        android:layout_below=\"@+id/demo_tab\" />\n \n</RelativeLayout>\n```\n\nToolBar不用多说，SlidingTabLayout实际上是上方的Tab视图，而ViewPager是页卡的容器，而页卡是稍后添加的多个Fragment。  \n下面我们来写三个Layout的xml文件和相关的三个Fragment的Java代码，分别代表三个页卡。  \n\n第一个页卡随意放置一个图片，代码如下：  \n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<ImageView xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:contentDescription=\"@string/app_name\"\n    android:src=\"@drawable/ic_launcher\" >\n \n</ImageView>\n```\n\n第二个页卡放置一个模拟时钟，代码如下：   \n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<AnalogClock xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\" >\n</AnalogClock>\n```\n\n第三个页卡放置一个数字时钟，代码如下：   \n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<DigitalClock xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:gravity=\"center\"\n    android:textSize=\"40sp\" >\n</DigitalClock>\n```\n\n相应的，创建三个Fragment的Java代码文件，这里只列出其中一个文件的程序清单，另外两个按此自行编写：   \n\n```\npackage com.xwh.toolbardemo.fragment;\n \nimport com.xwh.toolbardemo.R;\nimport android.os.Bundle;\nimport android.support.v4.app.Fragment;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\n \npublic class Fragment_Tab_1 extends Fragment {\n\t@Override\n\tpublic View onCreateView(LayoutInflater inflater, ViewGroup container,\n\t\t\tBundle savedInstanceState) {\n\t\treturn inflater.inflate(R.layout.fragment_tab_1, container, false);\n\t}\n}\n```\n\n下面我们还需一个适配器（Adapter），用于将这三个Fragment适配到ViewPager之上，下面列出适配器的Java程序代码清单：   \n\n```\npackage com.xwh.toolbardemo.adapter;\n \nimport java.util.ArrayList;\nimport android.support.v4.app.Fragment;\nimport android.support.v4.app.FragmentManager;\nimport android.support.v4.app.FragmentPagerAdapter;\n \npublic class ViewPager_Adapter extends FragmentPagerAdapter {\n \n\tprivate ArrayList<Fragment> fragments;\n \n\tpublic ViewPager_Adapter(FragmentManager fm, ArrayList<Fragment> fragments) {\n\t\tsuper(fm);\n\t\tthis.fragments = fragments;\n\t}\n \n\t@Override\n\tpublic Fragment getItem(int pos) {\n\t\treturn fragments.get(pos);\n\t}\n \n\t@Override\n\tpublic int getCount() {\n\t\treturn fragments.size();\n\t}\n \n\t@Override\n\tpublic CharSequence getPageTitle(int position) {\n\t\treturn \"Tab_\" + position;\n\t}\n}\n```\n\n**这里需要注意：下方的getPageTitle()方法是必要的，他用于相应Tab名称的显示。**   \n到此，我的程序架构如下图所示：   \n\n![程序架构图](https://img-blog.csdn.net/20141031164441484?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n接下来，我们将三个Fragment通过Adapter适配到ViewPager上，这一过程，我们只对MainActivity做操作。完整代码如下所示：   \n\n```\npackage com.xwh.toolbardemo;\n \nimport java.util.ArrayList;\n \nimport com.xwh.toolbardemo.adapter.ViewPager_Adapter;\nimport com.xwh.toolbardemo.fragment.Fragment_Tab_1;\nimport com.xwh.toolbardemo.fragment.Fragment_Tab_2;\nimport com.xwh.toolbardemo.fragment.Fragment_Tab_3;\nimport com.xwh.toolbardemo.view.SlidingTabLayout;\n \nimport android.support.v4.app.Fragment;\nimport android.support.v4.view.ViewPager;\nimport android.support.v7.app.ActionBarActivity;\nimport android.support.v7.widget.Toolbar;\nimport android.os.Bundle;\n \npublic class MainActivity extends ActionBarActivity {\n \n\tprivate Toolbar toolbar;\n\tprivate SlidingTabLayout slidingTabLayout;\n\tprivate ViewPager viewPager;\n \n\tprivate ArrayList<Fragment> fragments;\n\tprivate ViewPager_Adapter viewPager_Adapter;\n \n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.activity_main);\n\t\tfindView();\n\t}\n \n\t// 初始化控件\n\tprivate void findView() {\n\t\t// 实例化控件\n\t\ttoolbar = (Toolbar) findViewById(R.id.demo_toolbar);\n\t\tslidingTabLayout = (SlidingTabLayout) findViewById(R.id.demo_tab);\n\t\tviewPager = (ViewPager) findViewById(R.id.demo_vp);\n\t\t// 设置ViewPager\n\t\tfragments = new ArrayList<Fragment>();\n\t\tfragments.add(new Fragment_Tab_1());\n\t\tfragments.add(new Fragment_Tab_2());\n\t\tfragments.add(new Fragment_Tab_3());\n\t\tviewPager_Adapter = new ViewPager_Adapter(getSupportFragmentManager(),\n\t\t\t\tfragments);\n\t\tviewPager.setOffscreenPageLimit(fragments.size());\n\t\tviewPager.setAdapter(viewPager_Adapter);\n\t\t// 设置SlidingTab\n\t\tslidingTabLayout.setViewPager(viewPager);\n\t}\n}\n```\n\n到此，我们可以Ctrl+F11运行看效果了。如果不出意外的话，会是下面的效果：   \n\n![运行效果图 Tab1](https://img-blog.csdn.net/20141031171242013?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![运行效果图 Tab2](https://img-blog.csdn.net/20141031171311996?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![运行效果图 Tab3](https://img-blog.csdn.net/20141031171337268?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n仔细观察可以发现，ToolBar比ActionBar更好的一点在于上方Tab的选中状态，是根据滑动程度来的，而传统的ActionBar略显生硬。   \n第二篇Toolbar文章到此为止，在下一篇里，我们将集中介绍Menu的使用以及关于Toolbar的更多功能，欢迎关注！   ","source":"_posts/Android 5.0(L) ToolBar(替代ActionBar) 实战（二）.md","raw":"---\ntitle: Android 5.0(L) ToolBar(替代ActionBar) 实战（二）\ndate: 2014-10-31 17:16:27\ntags: Android\ncategories: 编程世界\n---\n\n上一次我们说到ToolBar的创建，这次我们来讨论一下ToolBar结合ViewPager实现类似微信的左右滑屏多个界面的效果。    \n要实现滑屏，首先我们要到Android开发者官网去下载一个示例代码，它封装了Viewpager和Tab配合切换页卡的方法。当然，我们也可以自己来实现，为了节约时间成本，就直接拿来用了。如果在官网找不到或者无奈被墙，可以到这里下载：http://download.csdn.net/detail/wh1990xiao2005/8105345   \n\n把下载好的工具类复制到项目指定的包内，我是在之前的项目中创建了view专用的包，并将这两个类复制了进去。   \n\n![项目结构](https://img-blog.csdn.net/20141031161432427?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n这里要注意，复制进去之后有可能会报错，因为包名不符，只需把package包名修改为自己的类所在包名即可。   \n打开布局文件，在上次Toolbar的声明下面添加SlidingTabLayout和ViewPager控件，下面放上示例：   \n\n```\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    xmlns:app=\"http://schemas.android.com/apk/res/com.xwh.toolbardemo\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\"com.xwh.toolbardemo.MainActivity\" >\n \n    <android.support.v7.widget.Toolbar\n        android:id=\"@+id/demo_toolbar\"\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"wrap_content\"\n        android:background=\"?attr/colorPrimary\"\n        android:minHeight=\"?attr/actionBarSize\"\n        app:title=\"@string/hello_world\" />\n \n    <com.xwh.toolbardemo.view.SlidingTabLayout\n        android:id=\"@+id/demo_tab\"\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"wrap_content\"\n        android:layout_below=\"@+id/demo_toolbar\" />\n \n    <android.support.v4.view.ViewPager\n        android:id=\"@+id/demo_vp\"\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"fill_parent\"\n        android:layout_below=\"@+id/demo_tab\" />\n \n</RelativeLayout>\n```\n\nToolBar不用多说，SlidingTabLayout实际上是上方的Tab视图，而ViewPager是页卡的容器，而页卡是稍后添加的多个Fragment。  \n下面我们来写三个Layout的xml文件和相关的三个Fragment的Java代码，分别代表三个页卡。  \n\n第一个页卡随意放置一个图片，代码如下：  \n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<ImageView xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:contentDescription=\"@string/app_name\"\n    android:src=\"@drawable/ic_launcher\" >\n \n</ImageView>\n```\n\n第二个页卡放置一个模拟时钟，代码如下：   \n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<AnalogClock xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\" >\n</AnalogClock>\n```\n\n第三个页卡放置一个数字时钟，代码如下：   \n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<DigitalClock xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:gravity=\"center\"\n    android:textSize=\"40sp\" >\n</DigitalClock>\n```\n\n相应的，创建三个Fragment的Java代码文件，这里只列出其中一个文件的程序清单，另外两个按此自行编写：   \n\n```\npackage com.xwh.toolbardemo.fragment;\n \nimport com.xwh.toolbardemo.R;\nimport android.os.Bundle;\nimport android.support.v4.app.Fragment;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\n \npublic class Fragment_Tab_1 extends Fragment {\n\t@Override\n\tpublic View onCreateView(LayoutInflater inflater, ViewGroup container,\n\t\t\tBundle savedInstanceState) {\n\t\treturn inflater.inflate(R.layout.fragment_tab_1, container, false);\n\t}\n}\n```\n\n下面我们还需一个适配器（Adapter），用于将这三个Fragment适配到ViewPager之上，下面列出适配器的Java程序代码清单：   \n\n```\npackage com.xwh.toolbardemo.adapter;\n \nimport java.util.ArrayList;\nimport android.support.v4.app.Fragment;\nimport android.support.v4.app.FragmentManager;\nimport android.support.v4.app.FragmentPagerAdapter;\n \npublic class ViewPager_Adapter extends FragmentPagerAdapter {\n \n\tprivate ArrayList<Fragment> fragments;\n \n\tpublic ViewPager_Adapter(FragmentManager fm, ArrayList<Fragment> fragments) {\n\t\tsuper(fm);\n\t\tthis.fragments = fragments;\n\t}\n \n\t@Override\n\tpublic Fragment getItem(int pos) {\n\t\treturn fragments.get(pos);\n\t}\n \n\t@Override\n\tpublic int getCount() {\n\t\treturn fragments.size();\n\t}\n \n\t@Override\n\tpublic CharSequence getPageTitle(int position) {\n\t\treturn \"Tab_\" + position;\n\t}\n}\n```\n\n**这里需要注意：下方的getPageTitle()方法是必要的，他用于相应Tab名称的显示。**   \n到此，我的程序架构如下图所示：   \n\n![程序架构图](https://img-blog.csdn.net/20141031164441484?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n接下来，我们将三个Fragment通过Adapter适配到ViewPager上，这一过程，我们只对MainActivity做操作。完整代码如下所示：   \n\n```\npackage com.xwh.toolbardemo;\n \nimport java.util.ArrayList;\n \nimport com.xwh.toolbardemo.adapter.ViewPager_Adapter;\nimport com.xwh.toolbardemo.fragment.Fragment_Tab_1;\nimport com.xwh.toolbardemo.fragment.Fragment_Tab_2;\nimport com.xwh.toolbardemo.fragment.Fragment_Tab_3;\nimport com.xwh.toolbardemo.view.SlidingTabLayout;\n \nimport android.support.v4.app.Fragment;\nimport android.support.v4.view.ViewPager;\nimport android.support.v7.app.ActionBarActivity;\nimport android.support.v7.widget.Toolbar;\nimport android.os.Bundle;\n \npublic class MainActivity extends ActionBarActivity {\n \n\tprivate Toolbar toolbar;\n\tprivate SlidingTabLayout slidingTabLayout;\n\tprivate ViewPager viewPager;\n \n\tprivate ArrayList<Fragment> fragments;\n\tprivate ViewPager_Adapter viewPager_Adapter;\n \n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.activity_main);\n\t\tfindView();\n\t}\n \n\t// 初始化控件\n\tprivate void findView() {\n\t\t// 实例化控件\n\t\ttoolbar = (Toolbar) findViewById(R.id.demo_toolbar);\n\t\tslidingTabLayout = (SlidingTabLayout) findViewById(R.id.demo_tab);\n\t\tviewPager = (ViewPager) findViewById(R.id.demo_vp);\n\t\t// 设置ViewPager\n\t\tfragments = new ArrayList<Fragment>();\n\t\tfragments.add(new Fragment_Tab_1());\n\t\tfragments.add(new Fragment_Tab_2());\n\t\tfragments.add(new Fragment_Tab_3());\n\t\tviewPager_Adapter = new ViewPager_Adapter(getSupportFragmentManager(),\n\t\t\t\tfragments);\n\t\tviewPager.setOffscreenPageLimit(fragments.size());\n\t\tviewPager.setAdapter(viewPager_Adapter);\n\t\t// 设置SlidingTab\n\t\tslidingTabLayout.setViewPager(viewPager);\n\t}\n}\n```\n\n到此，我们可以Ctrl+F11运行看效果了。如果不出意外的话，会是下面的效果：   \n\n![运行效果图 Tab1](https://img-blog.csdn.net/20141031171242013?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![运行效果图 Tab2](https://img-blog.csdn.net/20141031171311996?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![运行效果图 Tab3](https://img-blog.csdn.net/20141031171337268?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n仔细观察可以发现，ToolBar比ActionBar更好的一点在于上方Tab的选中状态，是根据滑动程度来的，而传统的ActionBar略显生硬。   \n第二篇Toolbar文章到此为止，在下一篇里，我们将集中介绍Menu的使用以及关于Toolbar的更多功能，欢迎关注！   ","slug":"Android 5.0(L) ToolBar(替代ActionBar) 实战（二）","published":1,"updated":"2019-07-31T04:10:08.994Z","_id":"cjyqq3tj60005fkqd5ygslsmk","comments":1,"layout":"post","photos":[],"link":"","content":"<p>上一次我们说到ToolBar的创建，这次我们来讨论一下ToolBar结合ViewPager实现类似微信的左右滑屏多个界面的效果。<br>要实现滑屏，首先我们要到Android开发者官网去下载一个示例代码，它封装了Viewpager和Tab配合切换页卡的方法。当然，我们也可以自己来实现，为了节约时间成本，就直接拿来用了。如果在官网找不到或者无奈被墙，可以到这里下载：<a href=\"http://download.csdn.net/detail/wh1990xiao2005/8105345\" target=\"_blank\" rel=\"noopener\">http://download.csdn.net/detail/wh1990xiao2005/8105345</a>   </p>\n<p>把下载好的工具类复制到项目指定的包内，我是在之前的项目中创建了view专用的包，并将这两个类复制了进去。   </p>\n<p><img src=\"https://img-blog.csdn.net/20141031161432427?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"项目结构\"></p>\n<p>这里要注意，复制进去之后有可能会报错，因为包名不符，只需把package包名修改为自己的类所在包名即可。<br>打开布局文件，在上次Toolbar的声明下面添加SlidingTabLayout和ViewPager控件，下面放上示例：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class=\"line\">    xmlns:app=&quot;http://schemas.android.com/apk/res/com.xwh.toolbardemo&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">    tools:context=&quot;com.xwh.toolbardemo.MainActivity&quot; &gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &lt;android.support.v7.widget.Toolbar</span><br><span class=\"line\">        android:id=&quot;@+id/demo_toolbar&quot;</span><br><span class=\"line\">        android:layout_width=&quot;fill_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:background=&quot;?attr/colorPrimary&quot;</span><br><span class=\"line\">        android:minHeight=&quot;?attr/actionBarSize&quot;</span><br><span class=\"line\">        app:title=&quot;@string/hello_world&quot; /&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &lt;com.xwh.toolbardemo.view.SlidingTabLayout</span><br><span class=\"line\">        android:id=&quot;@+id/demo_tab&quot;</span><br><span class=\"line\">        android:layout_width=&quot;fill_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_below=&quot;@+id/demo_toolbar&quot; /&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &lt;android.support.v4.view.ViewPager</span><br><span class=\"line\">        android:id=&quot;@+id/demo_vp&quot;</span><br><span class=\"line\">        android:layout_width=&quot;fill_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;fill_parent&quot;</span><br><span class=\"line\">        android:layout_below=&quot;@+id/demo_tab&quot; /&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure>\n\n<p>ToolBar不用多说，SlidingTabLayout实际上是上方的Tab视图，而ViewPager是页卡的容器，而页卡是稍后添加的多个Fragment。<br>下面我们来写三个Layout的xml文件和相关的三个Fragment的Java代码，分别代表三个页卡。  </p>\n<p>第一个页卡随意放置一个图片，代码如下：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;ImageView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">    android:contentDescription=&quot;@string/app_name&quot;</span><br><span class=\"line\">    android:src=&quot;@drawable/ic_launcher&quot; &gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">&lt;/ImageView&gt;</span><br></pre></td></tr></table></figure>\n\n<p>第二个页卡放置一个模拟时钟，代码如下：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;AnalogClock xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;match_parent&quot; &gt;</span><br><span class=\"line\">&lt;/AnalogClock&gt;</span><br></pre></td></tr></table></figure>\n\n<p>第三个页卡放置一个数字时钟，代码如下：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;DigitalClock xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">    android:gravity=&quot;center&quot;</span><br><span class=\"line\">    android:textSize=&quot;40sp&quot; &gt;</span><br><span class=\"line\">&lt;/DigitalClock&gt;</span><br></pre></td></tr></table></figure>\n\n<p>相应的，创建三个Fragment的Java代码文件，这里只列出其中一个文件的程序清单，另外两个按此自行编写：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.xwh.toolbardemo.fragment;</span><br><span class=\"line\"> </span><br><span class=\"line\">import com.xwh.toolbardemo.R;</span><br><span class=\"line\">import android.os.Bundle;</span><br><span class=\"line\">import android.support.v4.app.Fragment;</span><br><span class=\"line\">import android.view.LayoutInflater;</span><br><span class=\"line\">import android.view.View;</span><br><span class=\"line\">import android.view.ViewGroup;</span><br><span class=\"line\"> </span><br><span class=\"line\">public class Fragment_Tab_1 extends Fragment &#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic View onCreateView(LayoutInflater inflater, ViewGroup container,</span><br><span class=\"line\">\t\t\tBundle savedInstanceState) &#123;</span><br><span class=\"line\">\t\treturn inflater.inflate(R.layout.fragment_tab_1, container, false);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面我们还需一个适配器（Adapter），用于将这三个Fragment适配到ViewPager之上，下面列出适配器的Java程序代码清单：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.xwh.toolbardemo.adapter;</span><br><span class=\"line\"> </span><br><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\">import android.support.v4.app.Fragment;</span><br><span class=\"line\">import android.support.v4.app.FragmentManager;</span><br><span class=\"line\">import android.support.v4.app.FragmentPagerAdapter;</span><br><span class=\"line\"> </span><br><span class=\"line\">public class ViewPager_Adapter extends FragmentPagerAdapter &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate ArrayList&lt;Fragment&gt; fragments;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tpublic ViewPager_Adapter(FragmentManager fm, ArrayList&lt;Fragment&gt; fragments) &#123;</span><br><span class=\"line\">\t\tsuper(fm);</span><br><span class=\"line\">\t\tthis.fragments = fragments;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic Fragment getItem(int pos) &#123;</span><br><span class=\"line\">\t\treturn fragments.get(pos);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic int getCount() &#123;</span><br><span class=\"line\">\t\treturn fragments.size();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic CharSequence getPageTitle(int position) &#123;</span><br><span class=\"line\">\t\treturn &quot;Tab_&quot; + position;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>这里需要注意：下方的getPageTitle()方法是必要的，他用于相应Tab名称的显示。</strong><br>到此，我的程序架构如下图所示：   </p>\n<p><img src=\"https://img-blog.csdn.net/20141031164441484?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"程序架构图\"></p>\n<p>接下来，我们将三个Fragment通过Adapter适配到ViewPager上，这一过程，我们只对MainActivity做操作。完整代码如下所示：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.xwh.toolbardemo;</span><br><span class=\"line\"> </span><br><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\"> </span><br><span class=\"line\">import com.xwh.toolbardemo.adapter.ViewPager_Adapter;</span><br><span class=\"line\">import com.xwh.toolbardemo.fragment.Fragment_Tab_1;</span><br><span class=\"line\">import com.xwh.toolbardemo.fragment.Fragment_Tab_2;</span><br><span class=\"line\">import com.xwh.toolbardemo.fragment.Fragment_Tab_3;</span><br><span class=\"line\">import com.xwh.toolbardemo.view.SlidingTabLayout;</span><br><span class=\"line\"> </span><br><span class=\"line\">import android.support.v4.app.Fragment;</span><br><span class=\"line\">import android.support.v4.view.ViewPager;</span><br><span class=\"line\">import android.support.v7.app.ActionBarActivity;</span><br><span class=\"line\">import android.support.v7.widget.Toolbar;</span><br><span class=\"line\">import android.os.Bundle;</span><br><span class=\"line\"> </span><br><span class=\"line\">public class MainActivity extends ActionBarActivity &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate Toolbar toolbar;</span><br><span class=\"line\">\tprivate SlidingTabLayout slidingTabLayout;</span><br><span class=\"line\">\tprivate ViewPager viewPager;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate ArrayList&lt;Fragment&gt; fragments;</span><br><span class=\"line\">\tprivate ViewPager_Adapter viewPager_Adapter;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tprotected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">\t\tsuper.onCreate(savedInstanceState);</span><br><span class=\"line\">\t\tsetContentView(R.layout.activity_main);</span><br><span class=\"line\">\t\tfindView();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t// 初始化控件</span><br><span class=\"line\">\tprivate void findView() &#123;</span><br><span class=\"line\">\t\t// 实例化控件</span><br><span class=\"line\">\t\ttoolbar = (Toolbar) findViewById(R.id.demo_toolbar);</span><br><span class=\"line\">\t\tslidingTabLayout = (SlidingTabLayout) findViewById(R.id.demo_tab);</span><br><span class=\"line\">\t\tviewPager = (ViewPager) findViewById(R.id.demo_vp);</span><br><span class=\"line\">\t\t// 设置ViewPager</span><br><span class=\"line\">\t\tfragments = new ArrayList&lt;Fragment&gt;();</span><br><span class=\"line\">\t\tfragments.add(new Fragment_Tab_1());</span><br><span class=\"line\">\t\tfragments.add(new Fragment_Tab_2());</span><br><span class=\"line\">\t\tfragments.add(new Fragment_Tab_3());</span><br><span class=\"line\">\t\tviewPager_Adapter = new ViewPager_Adapter(getSupportFragmentManager(),</span><br><span class=\"line\">\t\t\t\tfragments);</span><br><span class=\"line\">\t\tviewPager.setOffscreenPageLimit(fragments.size());</span><br><span class=\"line\">\t\tviewPager.setAdapter(viewPager_Adapter);</span><br><span class=\"line\">\t\t// 设置SlidingTab</span><br><span class=\"line\">\t\tslidingTabLayout.setViewPager(viewPager);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到此，我们可以Ctrl+F11运行看效果了。如果不出意外的话，会是下面的效果：   </p>\n<p><img src=\"https://img-blog.csdn.net/20141031171242013?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"运行效果图 Tab1\"></p>\n<p><img src=\"https://img-blog.csdn.net/20141031171311996?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"运行效果图 Tab2\"></p>\n<p><img src=\"https://img-blog.csdn.net/20141031171337268?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"运行效果图 Tab3\"></p>\n<p>仔细观察可以发现，ToolBar比ActionBar更好的一点在于上方Tab的选中状态，是根据滑动程度来的，而传统的ActionBar略显生硬。<br>第二篇Toolbar文章到此为止，在下一篇里，我们将集中介绍Menu的使用以及关于Toolbar的更多功能，欢迎关注！   </p>\n","site":{"data":{}},"excerpt":"","more":"<p>上一次我们说到ToolBar的创建，这次我们来讨论一下ToolBar结合ViewPager实现类似微信的左右滑屏多个界面的效果。<br>要实现滑屏，首先我们要到Android开发者官网去下载一个示例代码，它封装了Viewpager和Tab配合切换页卡的方法。当然，我们也可以自己来实现，为了节约时间成本，就直接拿来用了。如果在官网找不到或者无奈被墙，可以到这里下载：<a href=\"http://download.csdn.net/detail/wh1990xiao2005/8105345\" target=\"_blank\" rel=\"noopener\">http://download.csdn.net/detail/wh1990xiao2005/8105345</a>   </p>\n<p>把下载好的工具类复制到项目指定的包内，我是在之前的项目中创建了view专用的包，并将这两个类复制了进去。   </p>\n<p><img src=\"https://img-blog.csdn.net/20141031161432427?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"项目结构\"></p>\n<p>这里要注意，复制进去之后有可能会报错，因为包名不符，只需把package包名修改为自己的类所在包名即可。<br>打开布局文件，在上次Toolbar的声明下面添加SlidingTabLayout和ViewPager控件，下面放上示例：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class=\"line\">    xmlns:app=&quot;http://schemas.android.com/apk/res/com.xwh.toolbardemo&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">    tools:context=&quot;com.xwh.toolbardemo.MainActivity&quot; &gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &lt;android.support.v7.widget.Toolbar</span><br><span class=\"line\">        android:id=&quot;@+id/demo_toolbar&quot;</span><br><span class=\"line\">        android:layout_width=&quot;fill_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:background=&quot;?attr/colorPrimary&quot;</span><br><span class=\"line\">        android:minHeight=&quot;?attr/actionBarSize&quot;</span><br><span class=\"line\">        app:title=&quot;@string/hello_world&quot; /&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &lt;com.xwh.toolbardemo.view.SlidingTabLayout</span><br><span class=\"line\">        android:id=&quot;@+id/demo_tab&quot;</span><br><span class=\"line\">        android:layout_width=&quot;fill_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">        android:layout_below=&quot;@+id/demo_toolbar&quot; /&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &lt;android.support.v4.view.ViewPager</span><br><span class=\"line\">        android:id=&quot;@+id/demo_vp&quot;</span><br><span class=\"line\">        android:layout_width=&quot;fill_parent&quot;</span><br><span class=\"line\">        android:layout_height=&quot;fill_parent&quot;</span><br><span class=\"line\">        android:layout_below=&quot;@+id/demo_tab&quot; /&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure>\n\n<p>ToolBar不用多说，SlidingTabLayout实际上是上方的Tab视图，而ViewPager是页卡的容器，而页卡是稍后添加的多个Fragment。<br>下面我们来写三个Layout的xml文件和相关的三个Fragment的Java代码，分别代表三个页卡。  </p>\n<p>第一个页卡随意放置一个图片，代码如下：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;ImageView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">    android:contentDescription=&quot;@string/app_name&quot;</span><br><span class=\"line\">    android:src=&quot;@drawable/ic_launcher&quot; &gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">&lt;/ImageView&gt;</span><br></pre></td></tr></table></figure>\n\n<p>第二个页卡放置一个模拟时钟，代码如下：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;AnalogClock xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;match_parent&quot; &gt;</span><br><span class=\"line\">&lt;/AnalogClock&gt;</span><br></pre></td></tr></table></figure>\n\n<p>第三个页卡放置一个数字时钟，代码如下：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;DigitalClock xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;match_parent&quot;</span><br><span class=\"line\">    android:gravity=&quot;center&quot;</span><br><span class=\"line\">    android:textSize=&quot;40sp&quot; &gt;</span><br><span class=\"line\">&lt;/DigitalClock&gt;</span><br></pre></td></tr></table></figure>\n\n<p>相应的，创建三个Fragment的Java代码文件，这里只列出其中一个文件的程序清单，另外两个按此自行编写：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.xwh.toolbardemo.fragment;</span><br><span class=\"line\"> </span><br><span class=\"line\">import com.xwh.toolbardemo.R;</span><br><span class=\"line\">import android.os.Bundle;</span><br><span class=\"line\">import android.support.v4.app.Fragment;</span><br><span class=\"line\">import android.view.LayoutInflater;</span><br><span class=\"line\">import android.view.View;</span><br><span class=\"line\">import android.view.ViewGroup;</span><br><span class=\"line\"> </span><br><span class=\"line\">public class Fragment_Tab_1 extends Fragment &#123;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic View onCreateView(LayoutInflater inflater, ViewGroup container,</span><br><span class=\"line\">\t\t\tBundle savedInstanceState) &#123;</span><br><span class=\"line\">\t\treturn inflater.inflate(R.layout.fragment_tab_1, container, false);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面我们还需一个适配器（Adapter），用于将这三个Fragment适配到ViewPager之上，下面列出适配器的Java程序代码清单：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.xwh.toolbardemo.adapter;</span><br><span class=\"line\"> </span><br><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\">import android.support.v4.app.Fragment;</span><br><span class=\"line\">import android.support.v4.app.FragmentManager;</span><br><span class=\"line\">import android.support.v4.app.FragmentPagerAdapter;</span><br><span class=\"line\"> </span><br><span class=\"line\">public class ViewPager_Adapter extends FragmentPagerAdapter &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate ArrayList&lt;Fragment&gt; fragments;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tpublic ViewPager_Adapter(FragmentManager fm, ArrayList&lt;Fragment&gt; fragments) &#123;</span><br><span class=\"line\">\t\tsuper(fm);</span><br><span class=\"line\">\t\tthis.fragments = fragments;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic Fragment getItem(int pos) &#123;</span><br><span class=\"line\">\t\treturn fragments.get(pos);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic int getCount() &#123;</span><br><span class=\"line\">\t\treturn fragments.size();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic CharSequence getPageTitle(int position) &#123;</span><br><span class=\"line\">\t\treturn &quot;Tab_&quot; + position;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>这里需要注意：下方的getPageTitle()方法是必要的，他用于相应Tab名称的显示。</strong><br>到此，我的程序架构如下图所示：   </p>\n<p><img src=\"https://img-blog.csdn.net/20141031164441484?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"程序架构图\"></p>\n<p>接下来，我们将三个Fragment通过Adapter适配到ViewPager上，这一过程，我们只对MainActivity做操作。完整代码如下所示：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.xwh.toolbardemo;</span><br><span class=\"line\"> </span><br><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\"> </span><br><span class=\"line\">import com.xwh.toolbardemo.adapter.ViewPager_Adapter;</span><br><span class=\"line\">import com.xwh.toolbardemo.fragment.Fragment_Tab_1;</span><br><span class=\"line\">import com.xwh.toolbardemo.fragment.Fragment_Tab_2;</span><br><span class=\"line\">import com.xwh.toolbardemo.fragment.Fragment_Tab_3;</span><br><span class=\"line\">import com.xwh.toolbardemo.view.SlidingTabLayout;</span><br><span class=\"line\"> </span><br><span class=\"line\">import android.support.v4.app.Fragment;</span><br><span class=\"line\">import android.support.v4.view.ViewPager;</span><br><span class=\"line\">import android.support.v7.app.ActionBarActivity;</span><br><span class=\"line\">import android.support.v7.widget.Toolbar;</span><br><span class=\"line\">import android.os.Bundle;</span><br><span class=\"line\"> </span><br><span class=\"line\">public class MainActivity extends ActionBarActivity &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate Toolbar toolbar;</span><br><span class=\"line\">\tprivate SlidingTabLayout slidingTabLayout;</span><br><span class=\"line\">\tprivate ViewPager viewPager;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate ArrayList&lt;Fragment&gt; fragments;</span><br><span class=\"line\">\tprivate ViewPager_Adapter viewPager_Adapter;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tprotected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">\t\tsuper.onCreate(savedInstanceState);</span><br><span class=\"line\">\t\tsetContentView(R.layout.activity_main);</span><br><span class=\"line\">\t\tfindView();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t// 初始化控件</span><br><span class=\"line\">\tprivate void findView() &#123;</span><br><span class=\"line\">\t\t// 实例化控件</span><br><span class=\"line\">\t\ttoolbar = (Toolbar) findViewById(R.id.demo_toolbar);</span><br><span class=\"line\">\t\tslidingTabLayout = (SlidingTabLayout) findViewById(R.id.demo_tab);</span><br><span class=\"line\">\t\tviewPager = (ViewPager) findViewById(R.id.demo_vp);</span><br><span class=\"line\">\t\t// 设置ViewPager</span><br><span class=\"line\">\t\tfragments = new ArrayList&lt;Fragment&gt;();</span><br><span class=\"line\">\t\tfragments.add(new Fragment_Tab_1());</span><br><span class=\"line\">\t\tfragments.add(new Fragment_Tab_2());</span><br><span class=\"line\">\t\tfragments.add(new Fragment_Tab_3());</span><br><span class=\"line\">\t\tviewPager_Adapter = new ViewPager_Adapter(getSupportFragmentManager(),</span><br><span class=\"line\">\t\t\t\tfragments);</span><br><span class=\"line\">\t\tviewPager.setOffscreenPageLimit(fragments.size());</span><br><span class=\"line\">\t\tviewPager.setAdapter(viewPager_Adapter);</span><br><span class=\"line\">\t\t// 设置SlidingTab</span><br><span class=\"line\">\t\tslidingTabLayout.setViewPager(viewPager);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到此，我们可以Ctrl+F11运行看效果了。如果不出意外的话，会是下面的效果：   </p>\n<p><img src=\"https://img-blog.csdn.net/20141031171242013?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"运行效果图 Tab1\"></p>\n<p><img src=\"https://img-blog.csdn.net/20141031171311996?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"运行效果图 Tab2\"></p>\n<p><img src=\"https://img-blog.csdn.net/20141031171337268?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"运行效果图 Tab3\"></p>\n<p>仔细观察可以发现，ToolBar比ActionBar更好的一点在于上方Tab的选中状态，是根据滑动程度来的，而传统的ActionBar略显生硬。<br>第二篇Toolbar文章到此为止，在下一篇里，我们将集中介绍Menu的使用以及关于Toolbar的更多功能，欢迎关注！   </p>\n"},{"title":"Android 6.0 运行时权限简明处理","date":"2016-12-19T09:15:00.000Z","_content":"\n今天来跟大家聊这样一个话题——权限。  \n正如各位所知，传统意义上的权限是在用户安装APP时被许可的。尽管在使用过程中，某些第三方Rom或者安全软件会再次提示权限，但从系统本身来说，就是被放行了。  \n在Google推出6.0之后，引入了新的权限机制，叫做运行时权限（Runtime Permission）。该机制限制某些敏感的权限，比如读写外置存储，访问隐私数据等等。对用户的数据保护提供良好的保障，但同时也为开发者提供了一些绊脚石。  \n那么作为一名开发者，应该如何做呢？  \n首先就是端正心态，这样做确实是对用户有好处的。  \n然后就是学习了，也就是本篇文章的正题。  \n我们按照Android studio的新建项目向导建立新的空项目后，按照原先的方法在Androidmanifest.xml做权限声明，如下：  \n\n```\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n<uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n```\n\n然后在Activity中尝试新建一个文件，如下：  \n\n```\nFile newFile = new File(Environment.getExternalStorageDirectory() + File.separator + \"test.txt\");\nif (newFile.exists() && newFile.isFile()) {\n    newFile.delete();\n}\ntry {\n    newFile.createNewFile();\n    Toast.makeText(this, \"文件创建成功\", Toast.LENGTH_SHORT).show();\n} catch (IOException e) {\n    e.printStackTrace();\n    Toast.makeText(this, \"文件创建失败\", Toast.LENGTH_SHORT).show();\n}\n```\n\n然后运行，如果你的手机是基于Android 6.0，你就会发现，文件根本没有办法被创建。会报Permission denied 错误，意思就是权限禁止。  \n解决的方法也很简单，分两步走，第一步先授权，第二步就是在授权响应的回调接口中获取到授权是否成功的值。  \n授权的方法可参考如下代码片： \n\n```\nprivate void checkStoragePermission() {\n    if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {\n        //未授权，请求授权\n        ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, REQ_PERMISSION_STORAGE);\n    }\n}\n```\n\n此处有检查，如果未经授权，则去授权。  \n授权响应回调中的处理可参考如下代码片：  \n\n```\nif (requestCode == REQ_PERMISSION_STORAGE) {\n    if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n        Toast.makeText(this, \"得到授权\", Toast.LENGTH_SHORT).show();\n    } else {\n        Toast.makeText(this, \"授权取消\", Toast.LENGTH_SHORT).show();\n    }\n}\n```    \n\n各位可在Toast处按照项目需求做出具体的适合自己项目的处理。  \n上述完整的代码已经放到Github上面，有兴趣的朋友可以下载查看，网址：https://github.com/XiaoWenHan/AndroidRunTimePermissionDemo/  \n下面附上需要做类似处理的权限列表： \n\n - 身体传感器\n - 日历\n - 摄像头\n - 通讯录\n - 地理位置\n - 麦克风\n - 电话\n - 短信\n - 存储空间 \n\n给大家提个醒，如果你项目中的targetSdk<23，是无需做上述处理的。  \n目前，针对运行时授权处理的框架已经有一些了，感兴趣的朋友可以去看看。下面放上几个：  \n\n - PermissionsDispatcher\n使用标注的方式，动态生成类处理运行时权限，目前还不支持嵌套Fragment。\n\n - RxPermissions\n基于RxJava的运行时权限检测框架\n\n - Grant\n简化运行时权限的处理，比较灵活\n\n - android-RuntimePermissions\nGoogle官方的例子  \n\n最后，放上一个无需权限处理即可使用的权限：  \n\n> android.permission.ACCESS_LOCATION_EXTRA_COMMANDS\nandroid.permission.ACCESS_NETWORK_STATE\nandroid.permission.ACCESS_NOTIFICATION_POLICY\nandroid.permission.ACCESS_WIFI_STATE\nandroid.permission.ACCESS_WIMAX_STATE\nandroid.permission.BLUETOOTH\nandroid.permission.BLUETOOTH_ADMIN\nandroid.permission.BROADCAST_STICKY\nandroid.permission.CHANGE_NETWORK_STATE\nandroid.permission.CHANGE_WIFI_MULTICAST_STATE\nandroid.permission.CHANGE_WIFI_STATE\nandroid.permission.CHANGE_WIMAX_STATE\nandroid.permission.DISABLE_KEYGUARD\nandroid.permission.EXPAND_STATUS_BAR\nandroid.permission.FLASHLIGHT\nandroid.permission.GET_ACCOUNTS\nandroid.permission.GET_PACKAGE_SIZE\nandroid.permission.INTERNET\nandroid.permission.KILL_BACKGROUND_PROCESSES\nandroid.permission.MODIFY_AUDIO_SETTINGS\nandroid.permission.NFC\nandroid.permission.READ_SYNC_SETTINGS\nandroid.permission.READ_SYNC_STATS\nandroid.permission.RECEIVE_BOOT_COMPLETED\nandroid.permission.REORDER_TASKS\nandroid.permission.REQUEST_INSTALL_PACKAGES\nandroid.permission.SET_TIME_ZONE\nandroid.permission.SET_WALLPAPER\nandroid.permission.SET_WALLPAPER_HINTS\nandroid.permission.SUBSCRIBED_FEEDS_READ\nandroid.permission.TRANSMIT_IR\nandroid.permission.USE_FINGERPRINT\nandroid.permission.VIBRATE\nandroid.permission.WAKE_LOCK\nandroid.permission.WRITE_SYNC_SETTINGS\ncom.android.alarm.permission.SET_ALARM\ncom.android.launcher.permission.INSTALL_SHORTCUT\ncom.android.launcher.permission.UNINSTALL_SHORTCUT","source":"_posts/Android 6.0 运行时权限简明处理.md","raw":"---\ntitle: Android 6.0 运行时权限简明处理\ndate: 2016-12-19 17:15:00\ntags: Android\ncategories: 编程世界\n---\n\n今天来跟大家聊这样一个话题——权限。  \n正如各位所知，传统意义上的权限是在用户安装APP时被许可的。尽管在使用过程中，某些第三方Rom或者安全软件会再次提示权限，但从系统本身来说，就是被放行了。  \n在Google推出6.0之后，引入了新的权限机制，叫做运行时权限（Runtime Permission）。该机制限制某些敏感的权限，比如读写外置存储，访问隐私数据等等。对用户的数据保护提供良好的保障，但同时也为开发者提供了一些绊脚石。  \n那么作为一名开发者，应该如何做呢？  \n首先就是端正心态，这样做确实是对用户有好处的。  \n然后就是学习了，也就是本篇文章的正题。  \n我们按照Android studio的新建项目向导建立新的空项目后，按照原先的方法在Androidmanifest.xml做权限声明，如下：  \n\n```\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n<uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n```\n\n然后在Activity中尝试新建一个文件，如下：  \n\n```\nFile newFile = new File(Environment.getExternalStorageDirectory() + File.separator + \"test.txt\");\nif (newFile.exists() && newFile.isFile()) {\n    newFile.delete();\n}\ntry {\n    newFile.createNewFile();\n    Toast.makeText(this, \"文件创建成功\", Toast.LENGTH_SHORT).show();\n} catch (IOException e) {\n    e.printStackTrace();\n    Toast.makeText(this, \"文件创建失败\", Toast.LENGTH_SHORT).show();\n}\n```\n\n然后运行，如果你的手机是基于Android 6.0，你就会发现，文件根本没有办法被创建。会报Permission denied 错误，意思就是权限禁止。  \n解决的方法也很简单，分两步走，第一步先授权，第二步就是在授权响应的回调接口中获取到授权是否成功的值。  \n授权的方法可参考如下代码片： \n\n```\nprivate void checkStoragePermission() {\n    if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {\n        //未授权，请求授权\n        ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, REQ_PERMISSION_STORAGE);\n    }\n}\n```\n\n此处有检查，如果未经授权，则去授权。  \n授权响应回调中的处理可参考如下代码片：  \n\n```\nif (requestCode == REQ_PERMISSION_STORAGE) {\n    if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n        Toast.makeText(this, \"得到授权\", Toast.LENGTH_SHORT).show();\n    } else {\n        Toast.makeText(this, \"授权取消\", Toast.LENGTH_SHORT).show();\n    }\n}\n```    \n\n各位可在Toast处按照项目需求做出具体的适合自己项目的处理。  \n上述完整的代码已经放到Github上面，有兴趣的朋友可以下载查看，网址：https://github.com/XiaoWenHan/AndroidRunTimePermissionDemo/  \n下面附上需要做类似处理的权限列表： \n\n - 身体传感器\n - 日历\n - 摄像头\n - 通讯录\n - 地理位置\n - 麦克风\n - 电话\n - 短信\n - 存储空间 \n\n给大家提个醒，如果你项目中的targetSdk<23，是无需做上述处理的。  \n目前，针对运行时授权处理的框架已经有一些了，感兴趣的朋友可以去看看。下面放上几个：  \n\n - PermissionsDispatcher\n使用标注的方式，动态生成类处理运行时权限，目前还不支持嵌套Fragment。\n\n - RxPermissions\n基于RxJava的运行时权限检测框架\n\n - Grant\n简化运行时权限的处理，比较灵活\n\n - android-RuntimePermissions\nGoogle官方的例子  \n\n最后，放上一个无需权限处理即可使用的权限：  \n\n> android.permission.ACCESS_LOCATION_EXTRA_COMMANDS\nandroid.permission.ACCESS_NETWORK_STATE\nandroid.permission.ACCESS_NOTIFICATION_POLICY\nandroid.permission.ACCESS_WIFI_STATE\nandroid.permission.ACCESS_WIMAX_STATE\nandroid.permission.BLUETOOTH\nandroid.permission.BLUETOOTH_ADMIN\nandroid.permission.BROADCAST_STICKY\nandroid.permission.CHANGE_NETWORK_STATE\nandroid.permission.CHANGE_WIFI_MULTICAST_STATE\nandroid.permission.CHANGE_WIFI_STATE\nandroid.permission.CHANGE_WIMAX_STATE\nandroid.permission.DISABLE_KEYGUARD\nandroid.permission.EXPAND_STATUS_BAR\nandroid.permission.FLASHLIGHT\nandroid.permission.GET_ACCOUNTS\nandroid.permission.GET_PACKAGE_SIZE\nandroid.permission.INTERNET\nandroid.permission.KILL_BACKGROUND_PROCESSES\nandroid.permission.MODIFY_AUDIO_SETTINGS\nandroid.permission.NFC\nandroid.permission.READ_SYNC_SETTINGS\nandroid.permission.READ_SYNC_STATS\nandroid.permission.RECEIVE_BOOT_COMPLETED\nandroid.permission.REORDER_TASKS\nandroid.permission.REQUEST_INSTALL_PACKAGES\nandroid.permission.SET_TIME_ZONE\nandroid.permission.SET_WALLPAPER\nandroid.permission.SET_WALLPAPER_HINTS\nandroid.permission.SUBSCRIBED_FEEDS_READ\nandroid.permission.TRANSMIT_IR\nandroid.permission.USE_FINGERPRINT\nandroid.permission.VIBRATE\nandroid.permission.WAKE_LOCK\nandroid.permission.WRITE_SYNC_SETTINGS\ncom.android.alarm.permission.SET_ALARM\ncom.android.launcher.permission.INSTALL_SHORTCUT\ncom.android.launcher.permission.UNINSTALL_SHORTCUT","slug":"Android 6.0 运行时权限简明处理","published":1,"updated":"2019-07-31T04:10:02.751Z","_id":"cjyqq3tj70006fkqdd43o6d6q","comments":1,"layout":"post","photos":[],"link":"","content":"<p>今天来跟大家聊这样一个话题——权限。<br>正如各位所知，传统意义上的权限是在用户安装APP时被许可的。尽管在使用过程中，某些第三方Rom或者安全软件会再次提示权限，但从系统本身来说，就是被放行了。<br>在Google推出6.0之后，引入了新的权限机制，叫做运行时权限（Runtime Permission）。该机制限制某些敏感的权限，比如读写外置存储，访问隐私数据等等。对用户的数据保护提供良好的保障，但同时也为开发者提供了一些绊脚石。<br>那么作为一名开发者，应该如何做呢？<br>首先就是端正心态，这样做确实是对用户有好处的。<br>然后就是学习了，也就是本篇文章的正题。<br>我们按照Android studio的新建项目向导建立新的空项目后，按照原先的方法在Androidmanifest.xml做权限声明，如下：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</span><br><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>然后在Activity中尝试新建一个文件，如下：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File newFile = new File(Environment.getExternalStorageDirectory() + File.separator + &quot;test.txt&quot;);</span><br><span class=\"line\">if (newFile.exists() &amp;&amp; newFile.isFile()) &#123;</span><br><span class=\"line\">    newFile.delete();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">    newFile.createNewFile();</span><br><span class=\"line\">    Toast.makeText(this, &quot;文件创建成功&quot;, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">&#125; catch (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">    Toast.makeText(this, &quot;文件创建失败&quot;, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后运行，如果你的手机是基于Android 6.0，你就会发现，文件根本没有办法被创建。会报Permission denied 错误，意思就是权限禁止。<br>解决的方法也很简单，分两步走，第一步先授权，第二步就是在授权响应的回调接口中获取到授权是否成功的值。<br>授权的方法可参考如下代码片： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void checkStoragePermission() &#123;</span><br><span class=\"line\">    if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class=\"line\">        //未授权，请求授权</span><br><span class=\"line\">        ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, REQ_PERMISSION_STORAGE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此处有检查，如果未经授权，则去授权。<br>授权响应回调中的处理可参考如下代码片：  </p>\n<pre><code>if (requestCode == REQ_PERMISSION_STORAGE) {\n    if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n        Toast.makeText(this, &quot;得到授权&quot;, Toast.LENGTH_SHORT).show();\n    } else {\n        Toast.makeText(this, &quot;授权取消&quot;, Toast.LENGTH_SHORT).show();\n    }\n}</code></pre><p>各位可在Toast处按照项目需求做出具体的适合自己项目的处理。<br>上述完整的代码已经放到Github上面，有兴趣的朋友可以下载查看，网址：<a href=\"https://github.com/XiaoWenHan/AndroidRunTimePermissionDemo/\" target=\"_blank\" rel=\"noopener\">https://github.com/XiaoWenHan/AndroidRunTimePermissionDemo/</a><br>下面附上需要做类似处理的权限列表： </p>\n<ul>\n<li>身体传感器</li>\n<li>日历</li>\n<li>摄像头</li>\n<li>通讯录</li>\n<li>地理位置</li>\n<li>麦克风</li>\n<li>电话</li>\n<li>短信</li>\n<li>存储空间 </li>\n</ul>\n<p>给大家提个醒，如果你项目中的targetSdk&lt;23，是无需做上述处理的。<br>目前，针对运行时授权处理的框架已经有一些了，感兴趣的朋友可以去看看。下面放上几个：  </p>\n<ul>\n<li><p>PermissionsDispatcher<br>使用标注的方式，动态生成类处理运行时权限，目前还不支持嵌套Fragment。</p>\n</li>\n<li><p>RxPermissions<br>基于RxJava的运行时权限检测框架</p>\n</li>\n<li><p>Grant<br>简化运行时权限的处理，比较灵活</p>\n</li>\n<li><p>android-RuntimePermissions<br>Google官方的例子  </p>\n</li>\n</ul>\n<p>最后，放上一个无需权限处理即可使用的权限：  </p>\n<blockquote>\n<p>android.permission.ACCESS_LOCATION_EXTRA_COMMANDS<br>android.permission.ACCESS_NETWORK_STATE<br>android.permission.ACCESS_NOTIFICATION_POLICY<br>android.permission.ACCESS_WIFI_STATE<br>android.permission.ACCESS_WIMAX_STATE<br>android.permission.BLUETOOTH<br>android.permission.BLUETOOTH_ADMIN<br>android.permission.BROADCAST_STICKY<br>android.permission.CHANGE_NETWORK_STATE<br>android.permission.CHANGE_WIFI_MULTICAST_STATE<br>android.permission.CHANGE_WIFI_STATE<br>android.permission.CHANGE_WIMAX_STATE<br>android.permission.DISABLE_KEYGUARD<br>android.permission.EXPAND_STATUS_BAR<br>android.permission.FLASHLIGHT<br>android.permission.GET_ACCOUNTS<br>android.permission.GET_PACKAGE_SIZE<br>android.permission.INTERNET<br>android.permission.KILL_BACKGROUND_PROCESSES<br>android.permission.MODIFY_AUDIO_SETTINGS<br>android.permission.NFC<br>android.permission.READ_SYNC_SETTINGS<br>android.permission.READ_SYNC_STATS<br>android.permission.RECEIVE_BOOT_COMPLETED<br>android.permission.REORDER_TASKS<br>android.permission.REQUEST_INSTALL_PACKAGES<br>android.permission.SET_TIME_ZONE<br>android.permission.SET_WALLPAPER<br>android.permission.SET_WALLPAPER_HINTS<br>android.permission.SUBSCRIBED_FEEDS_READ<br>android.permission.TRANSMIT_IR<br>android.permission.USE_FINGERPRINT<br>android.permission.VIBRATE<br>android.permission.WAKE_LOCK<br>android.permission.WRITE_SYNC_SETTINGS<br>com.android.alarm.permission.SET_ALARM<br>com.android.launcher.permission.INSTALL_SHORTCUT<br>com.android.launcher.permission.UNINSTALL_SHORTCUT</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>今天来跟大家聊这样一个话题——权限。<br>正如各位所知，传统意义上的权限是在用户安装APP时被许可的。尽管在使用过程中，某些第三方Rom或者安全软件会再次提示权限，但从系统本身来说，就是被放行了。<br>在Google推出6.0之后，引入了新的权限机制，叫做运行时权限（Runtime Permission）。该机制限制某些敏感的权限，比如读写外置存储，访问隐私数据等等。对用户的数据保护提供良好的保障，但同时也为开发者提供了一些绊脚石。<br>那么作为一名开发者，应该如何做呢？<br>首先就是端正心态，这样做确实是对用户有好处的。<br>然后就是学习了，也就是本篇文章的正题。<br>我们按照Android studio的新建项目向导建立新的空项目后，按照原先的方法在Androidmanifest.xml做权限声明，如下：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</span><br><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>然后在Activity中尝试新建一个文件，如下：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File newFile = new File(Environment.getExternalStorageDirectory() + File.separator + &quot;test.txt&quot;);</span><br><span class=\"line\">if (newFile.exists() &amp;&amp; newFile.isFile()) &#123;</span><br><span class=\"line\">    newFile.delete();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">    newFile.createNewFile();</span><br><span class=\"line\">    Toast.makeText(this, &quot;文件创建成功&quot;, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">&#125; catch (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">    Toast.makeText(this, &quot;文件创建失败&quot;, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后运行，如果你的手机是基于Android 6.0，你就会发现，文件根本没有办法被创建。会报Permission denied 错误，意思就是权限禁止。<br>解决的方法也很简单，分两步走，第一步先授权，第二步就是在授权响应的回调接口中获取到授权是否成功的值。<br>授权的方法可参考如下代码片： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void checkStoragePermission() &#123;</span><br><span class=\"line\">    if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class=\"line\">        //未授权，请求授权</span><br><span class=\"line\">        ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, REQ_PERMISSION_STORAGE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此处有检查，如果未经授权，则去授权。<br>授权响应回调中的处理可参考如下代码片：  </p>\n<pre><code>if (requestCode == REQ_PERMISSION_STORAGE) {\n    if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n        Toast.makeText(this, &quot;得到授权&quot;, Toast.LENGTH_SHORT).show();\n    } else {\n        Toast.makeText(this, &quot;授权取消&quot;, Toast.LENGTH_SHORT).show();\n    }\n}</code></pre><p>各位可在Toast处按照项目需求做出具体的适合自己项目的处理。<br>上述完整的代码已经放到Github上面，有兴趣的朋友可以下载查看，网址：<a href=\"https://github.com/XiaoWenHan/AndroidRunTimePermissionDemo/\" target=\"_blank\" rel=\"noopener\">https://github.com/XiaoWenHan/AndroidRunTimePermissionDemo/</a><br>下面附上需要做类似处理的权限列表： </p>\n<ul>\n<li>身体传感器</li>\n<li>日历</li>\n<li>摄像头</li>\n<li>通讯录</li>\n<li>地理位置</li>\n<li>麦克风</li>\n<li>电话</li>\n<li>短信</li>\n<li>存储空间 </li>\n</ul>\n<p>给大家提个醒，如果你项目中的targetSdk&lt;23，是无需做上述处理的。<br>目前，针对运行时授权处理的框架已经有一些了，感兴趣的朋友可以去看看。下面放上几个：  </p>\n<ul>\n<li><p>PermissionsDispatcher<br>使用标注的方式，动态生成类处理运行时权限，目前还不支持嵌套Fragment。</p>\n</li>\n<li><p>RxPermissions<br>基于RxJava的运行时权限检测框架</p>\n</li>\n<li><p>Grant<br>简化运行时权限的处理，比较灵活</p>\n</li>\n<li><p>android-RuntimePermissions<br>Google官方的例子  </p>\n</li>\n</ul>\n<p>最后，放上一个无需权限处理即可使用的权限：  </p>\n<blockquote>\n<p>android.permission.ACCESS_LOCATION_EXTRA_COMMANDS<br>android.permission.ACCESS_NETWORK_STATE<br>android.permission.ACCESS_NOTIFICATION_POLICY<br>android.permission.ACCESS_WIFI_STATE<br>android.permission.ACCESS_WIMAX_STATE<br>android.permission.BLUETOOTH<br>android.permission.BLUETOOTH_ADMIN<br>android.permission.BROADCAST_STICKY<br>android.permission.CHANGE_NETWORK_STATE<br>android.permission.CHANGE_WIFI_MULTICAST_STATE<br>android.permission.CHANGE_WIFI_STATE<br>android.permission.CHANGE_WIMAX_STATE<br>android.permission.DISABLE_KEYGUARD<br>android.permission.EXPAND_STATUS_BAR<br>android.permission.FLASHLIGHT<br>android.permission.GET_ACCOUNTS<br>android.permission.GET_PACKAGE_SIZE<br>android.permission.INTERNET<br>android.permission.KILL_BACKGROUND_PROCESSES<br>android.permission.MODIFY_AUDIO_SETTINGS<br>android.permission.NFC<br>android.permission.READ_SYNC_SETTINGS<br>android.permission.READ_SYNC_STATS<br>android.permission.RECEIVE_BOOT_COMPLETED<br>android.permission.REORDER_TASKS<br>android.permission.REQUEST_INSTALL_PACKAGES<br>android.permission.SET_TIME_ZONE<br>android.permission.SET_WALLPAPER<br>android.permission.SET_WALLPAPER_HINTS<br>android.permission.SUBSCRIBED_FEEDS_READ<br>android.permission.TRANSMIT_IR<br>android.permission.USE_FINGERPRINT<br>android.permission.VIBRATE<br>android.permission.WAKE_LOCK<br>android.permission.WRITE_SYNC_SETTINGS<br>com.android.alarm.permission.SET_ALARM<br>com.android.launcher.permission.INSTALL_SHORTCUT<br>com.android.launcher.permission.UNINSTALL_SHORTCUT</p>\n</blockquote>\n"},{"title":"Android GridView 点击效果（可能是最快捷的实现，另有福利）","date":"2015-08-12T00:50:04.000Z","_content":"\n\n好久没有发过文章了，今天给朋友们分享的是：给GirdView添加点击效果， **点击时改变背景** 。  \n这其实也是我在项目开发中遇到的问题，习惯性的百度了一圈，又Google了一圈。解决方案大致可归为两类：  \n1. 代码实现，逻辑处理，监听点击时间，改变相应控件的BackGround；\n2. Selector实现，用XML定义，Layout中赋予相应属性。\n\n首先第1个解决办法，怎么说呢，虽然逻辑不是很复杂，但也无形中增加了Bug出现的可能。第二个我试了好久，都达不到理想效果。于是我做了一件自认为聪明的做法，没想到居然管用。  \n很简单，首先还是 **写一个Selector** ，预先定义按下去是用什么素材，普通状态时什么素材；然后 **GridView本身没有进行任何selector的赋值** ，只是有一个Background和horizontalSpacing，用来显示分割线（哈，不小心又透露了一招）。然后在每个item的布局的根节点， **把Selector作为Background赋值** ，就可以了。\n","source":"_posts/Android GridView 点击效果（可能是最快捷的实现，另有福利）.md","raw":"---\ntitle: Android GridView 点击效果（可能是最快捷的实现，另有福利）\ndate: 2015-08-12 08:50:04\ntags: Android\ncategories: 编程世界\n---\n\n\n好久没有发过文章了，今天给朋友们分享的是：给GirdView添加点击效果， **点击时改变背景** 。  \n这其实也是我在项目开发中遇到的问题，习惯性的百度了一圈，又Google了一圈。解决方案大致可归为两类：  \n1. 代码实现，逻辑处理，监听点击时间，改变相应控件的BackGround；\n2. Selector实现，用XML定义，Layout中赋予相应属性。\n\n首先第1个解决办法，怎么说呢，虽然逻辑不是很复杂，但也无形中增加了Bug出现的可能。第二个我试了好久，都达不到理想效果。于是我做了一件自认为聪明的做法，没想到居然管用。  \n很简单，首先还是 **写一个Selector** ，预先定义按下去是用什么素材，普通状态时什么素材；然后 **GridView本身没有进行任何selector的赋值** ，只是有一个Background和horizontalSpacing，用来显示分割线（哈，不小心又透露了一招）。然后在每个item的布局的根节点， **把Selector作为Background赋值** ，就可以了。\n","slug":"Android GridView 点击效果（可能是最快捷的实现，另有福利）","published":1,"updated":"2019-07-31T04:10:07.890Z","_id":"cjyqq3tja0009fkqdg0we9mof","comments":1,"layout":"post","photos":[],"link":"","content":"<p>好久没有发过文章了，今天给朋友们分享的是：给GirdView添加点击效果， <strong>点击时改变背景</strong> 。<br>这其实也是我在项目开发中遇到的问题，习惯性的百度了一圈，又Google了一圈。解决方案大致可归为两类：  </p>\n<ol>\n<li>代码实现，逻辑处理，监听点击时间，改变相应控件的BackGround；</li>\n<li>Selector实现，用XML定义，Layout中赋予相应属性。</li>\n</ol>\n<p>首先第1个解决办法，怎么说呢，虽然逻辑不是很复杂，但也无形中增加了Bug出现的可能。第二个我试了好久，都达不到理想效果。于是我做了一件自认为聪明的做法，没想到居然管用。<br>很简单，首先还是 <strong>写一个Selector</strong> ，预先定义按下去是用什么素材，普通状态时什么素材；然后 <strong>GridView本身没有进行任何selector的赋值</strong> ，只是有一个Background和horizontalSpacing，用来显示分割线（哈，不小心又透露了一招）。然后在每个item的布局的根节点， <strong>把Selector作为Background赋值</strong> ，就可以了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>好久没有发过文章了，今天给朋友们分享的是：给GirdView添加点击效果， <strong>点击时改变背景</strong> 。<br>这其实也是我在项目开发中遇到的问题，习惯性的百度了一圈，又Google了一圈。解决方案大致可归为两类：  </p>\n<ol>\n<li>代码实现，逻辑处理，监听点击时间，改变相应控件的BackGround；</li>\n<li>Selector实现，用XML定义，Layout中赋予相应属性。</li>\n</ol>\n<p>首先第1个解决办法，怎么说呢，虽然逻辑不是很复杂，但也无形中增加了Bug出现的可能。第二个我试了好久，都达不到理想效果。于是我做了一件自认为聪明的做法，没想到居然管用。<br>很简单，首先还是 <strong>写一个Selector</strong> ，预先定义按下去是用什么素材，普通状态时什么素材；然后 <strong>GridView本身没有进行任何selector的赋值</strong> ，只是有一个Background和horizontalSpacing，用来显示分割线（哈，不小心又透露了一招）。然后在每个item的布局的根节点， <strong>把Selector作为Background赋值</strong> ，就可以了。</p>\n"},{"title":"Android 重写ImageView实现图片手势功能","date":"2014-08-05T05:22:43.000Z","_content":"\n通过这个XImageView.java类，可实现单点触摸移动，以及双指缩放图片功能。   \n使用时，只要在布局文件中引入，并在Java代码中按照原生ImageView设置要现实的图片即可。代码如下（仅供参考）：   \n\n```\nimport android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.Canvas;\nimport android.graphics.Matrix;\nimport android.util.AttributeSet;\nimport android.view.MotionEvent;\nimport android.widget.ImageView;\n \npublic class XImageView extends ImageView {\n \n\tpublic static Bitmap gintama;\n\tprivate Matrix matrix;\n \n\tprivate float point1_old_x, point1_old_y, point1_new_x, point1_new_y,\n\t\t\tpoint2_old_x, point2_old_y, point2_new_x, point2_new_y,\n\t\t\tdistance_old, distance_new;\n\tprivate float point_old_x, point_old_y, point_new_x, point_new_y;\n\tprivate boolean isMultiTouch = false;\n \n\tpublic XImageView(Context context, AttributeSet attrs) {\n\t\tsuper(context, attrs);\n\t\tgintama = BitmapFactory.decodeResource(getResources(),\n\t\t\t\tR.drawable.ic_launcher);\n\t\tmatrix = new Matrix();\n\t}\n \n\tpublic XImageView(Context context) {\n\t\tsuper(context);\n\t\tgintama = BitmapFactory.decodeResource(getResources(),\n\t\t\t\tR.drawable.ic_launcher);\n\t\tmatrix = new Matrix();\n\t}\n \n\t// 回调方法，用于画控件上的图片\n\t@Override\n\tprotected void onDraw(Canvas canvas) {\n\t\tcanvas.save();\n\t\tcanvas.drawBitmap(gintama, matrix, null);\n\t\tcanvas.restore();\n\t}\n \n\t@SuppressLint(\"ClickableViewAccessibility\")\n\t@Override\n\tpublic boolean onTouchEvent(MotionEvent event) {\n\t\tswitch (event.getAction() & MotionEvent.ACTION_MASK) {\n\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t// 单点移动 按下\n\t\t\tif (event.getPointerCount() == 1) {\n\t\t\t\tisMultiTouch = false;\n\t\t\t\tpoint_old_x = event.getX();\n\t\t\t\tpoint_old_y = event.getY();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MotionEvent.ACTION_UP:\n\t\t\t// 单点移动 抬起\n\t\t\tif (event.getPointerCount() == 1) {\n\t\t\t\tisMultiTouch = false;\n\t\t\t\tpoint_old_x = point_new_x;\n\t\t\t\tpoint_old_y = point_new_y;\n\t\t\t}\n \n\t\t\tbreak;\n\t\tcase MotionEvent.ACTION_POINTER_UP:\n\t\t\t// 双点操作 抬起\n\t\t\tif (event.getPointerCount() == 2) {\n\t\t\t\tisMultiTouch = true;\n\t\t\t\tpoint1_old_x = point1_new_x;\n\t\t\t\tpoint1_old_y = point1_new_y;\n\t\t\t\tpoint2_old_x = point2_new_x;\n\t\t\t\tpoint2_old_y = point2_new_y;\n \n\t\t\t}\n\t\t\tbreak;\n\t\tcase MotionEvent.ACTION_POINTER_DOWN:\n\t\t\t// 双点操作 按下\n\t\t\tif (event.getPointerCount() == 2) {\n\t\t\t\tisMultiTouch = true;\n\t\t\t\tpoint1_old_x = event.getX(0);\n\t\t\t\tpoint1_old_y = event.getY(0);\n\t\t\t\tpoint2_old_x = event.getX(1);\n\t\t\t\tpoint2_old_y = event.getY(1);\n\t\t\t\tdistance_old = (float) Math\n\t\t\t\t\t\t.sqrt(((point1_old_x - point2_old_x)\n\t\t\t\t\t\t\t\t* (point1_old_x - point2_old_x) + (point1_old_y - point2_old_y)\n\t\t\t\t\t\t\t\t* (point1_old_y - point2_old_y)));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t// 双点操作 移动\n\t\t\tif (event.getPointerCount() == 2) {\n\t\t\t\tisMultiTouch = true;\n\t\t\t\tpoint1_new_x = event.getX(0);\n\t\t\t\tpoint1_new_y = event.getY(0);\n\t\t\t\tpoint2_new_x = event.getX(1);\n\t\t\t\tpoint2_new_y = event.getY(1);\n\t\t\t\tpinch();\n\t\t\t} else {\n\t\t\t\t// 单点移动 移动\n\t\t\t\tif (event.getPointerCount() == 1) {\n\t\t\t\t\tif (!isMultiTouch) {\n\t\t\t\t\t\tpoint_new_x = event.getX();\n\t\t\t\t\t\tpoint_new_y = event.getY();\n\t\t\t\t\t\tmatrix.postTranslate((point_new_x - point_old_x),\n\t\t\t\t\t\t\t\t(point_new_y - point_old_y));\n\t\t\t\t\t\tpoint_old_x = point_new_x;\n\t\t\t\t\t\tpoint_old_y = point_new_y;\n\t\t\t\t\t\tinvalidate();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn true;\n\t}\n \n\t// 缩放图片方法\n\tprivate void pinch() {\n\t\tdistance_new = (float) Math.sqrt(((point1_new_x - point2_new_x)\n\t\t\t\t* (point1_new_x - point2_new_x) + (point1_new_y - point2_new_y)\n\t\t\t\t* (point1_new_y - point2_new_y)));\n\t\tmatrix.postScale((distance_new / distance_old),\n\t\t\t\t(distance_new / distance_old), this.getWidth() / 2,\n\t\t\t\tthis.getTop() / 2);\n \n\t\tinvalidate();\n\t\tdistance_old = distance_new;\n\t}\n \n}\n```","source":"_posts/Android 重写ImageView实现图片手势功能.md","raw":"---\ntitle: Android 重写ImageView实现图片手势功能\ndate: 2014-08-05 13:22:43\ntags: Android\ncategories: 编程世界\n---\n\n通过这个XImageView.java类，可实现单点触摸移动，以及双指缩放图片功能。   \n使用时，只要在布局文件中引入，并在Java代码中按照原生ImageView设置要现实的图片即可。代码如下（仅供参考）：   \n\n```\nimport android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.Canvas;\nimport android.graphics.Matrix;\nimport android.util.AttributeSet;\nimport android.view.MotionEvent;\nimport android.widget.ImageView;\n \npublic class XImageView extends ImageView {\n \n\tpublic static Bitmap gintama;\n\tprivate Matrix matrix;\n \n\tprivate float point1_old_x, point1_old_y, point1_new_x, point1_new_y,\n\t\t\tpoint2_old_x, point2_old_y, point2_new_x, point2_new_y,\n\t\t\tdistance_old, distance_new;\n\tprivate float point_old_x, point_old_y, point_new_x, point_new_y;\n\tprivate boolean isMultiTouch = false;\n \n\tpublic XImageView(Context context, AttributeSet attrs) {\n\t\tsuper(context, attrs);\n\t\tgintama = BitmapFactory.decodeResource(getResources(),\n\t\t\t\tR.drawable.ic_launcher);\n\t\tmatrix = new Matrix();\n\t}\n \n\tpublic XImageView(Context context) {\n\t\tsuper(context);\n\t\tgintama = BitmapFactory.decodeResource(getResources(),\n\t\t\t\tR.drawable.ic_launcher);\n\t\tmatrix = new Matrix();\n\t}\n \n\t// 回调方法，用于画控件上的图片\n\t@Override\n\tprotected void onDraw(Canvas canvas) {\n\t\tcanvas.save();\n\t\tcanvas.drawBitmap(gintama, matrix, null);\n\t\tcanvas.restore();\n\t}\n \n\t@SuppressLint(\"ClickableViewAccessibility\")\n\t@Override\n\tpublic boolean onTouchEvent(MotionEvent event) {\n\t\tswitch (event.getAction() & MotionEvent.ACTION_MASK) {\n\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t// 单点移动 按下\n\t\t\tif (event.getPointerCount() == 1) {\n\t\t\t\tisMultiTouch = false;\n\t\t\t\tpoint_old_x = event.getX();\n\t\t\t\tpoint_old_y = event.getY();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MotionEvent.ACTION_UP:\n\t\t\t// 单点移动 抬起\n\t\t\tif (event.getPointerCount() == 1) {\n\t\t\t\tisMultiTouch = false;\n\t\t\t\tpoint_old_x = point_new_x;\n\t\t\t\tpoint_old_y = point_new_y;\n\t\t\t}\n \n\t\t\tbreak;\n\t\tcase MotionEvent.ACTION_POINTER_UP:\n\t\t\t// 双点操作 抬起\n\t\t\tif (event.getPointerCount() == 2) {\n\t\t\t\tisMultiTouch = true;\n\t\t\t\tpoint1_old_x = point1_new_x;\n\t\t\t\tpoint1_old_y = point1_new_y;\n\t\t\t\tpoint2_old_x = point2_new_x;\n\t\t\t\tpoint2_old_y = point2_new_y;\n \n\t\t\t}\n\t\t\tbreak;\n\t\tcase MotionEvent.ACTION_POINTER_DOWN:\n\t\t\t// 双点操作 按下\n\t\t\tif (event.getPointerCount() == 2) {\n\t\t\t\tisMultiTouch = true;\n\t\t\t\tpoint1_old_x = event.getX(0);\n\t\t\t\tpoint1_old_y = event.getY(0);\n\t\t\t\tpoint2_old_x = event.getX(1);\n\t\t\t\tpoint2_old_y = event.getY(1);\n\t\t\t\tdistance_old = (float) Math\n\t\t\t\t\t\t.sqrt(((point1_old_x - point2_old_x)\n\t\t\t\t\t\t\t\t* (point1_old_x - point2_old_x) + (point1_old_y - point2_old_y)\n\t\t\t\t\t\t\t\t* (point1_old_y - point2_old_y)));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t// 双点操作 移动\n\t\t\tif (event.getPointerCount() == 2) {\n\t\t\t\tisMultiTouch = true;\n\t\t\t\tpoint1_new_x = event.getX(0);\n\t\t\t\tpoint1_new_y = event.getY(0);\n\t\t\t\tpoint2_new_x = event.getX(1);\n\t\t\t\tpoint2_new_y = event.getY(1);\n\t\t\t\tpinch();\n\t\t\t} else {\n\t\t\t\t// 单点移动 移动\n\t\t\t\tif (event.getPointerCount() == 1) {\n\t\t\t\t\tif (!isMultiTouch) {\n\t\t\t\t\t\tpoint_new_x = event.getX();\n\t\t\t\t\t\tpoint_new_y = event.getY();\n\t\t\t\t\t\tmatrix.postTranslate((point_new_x - point_old_x),\n\t\t\t\t\t\t\t\t(point_new_y - point_old_y));\n\t\t\t\t\t\tpoint_old_x = point_new_x;\n\t\t\t\t\t\tpoint_old_y = point_new_y;\n\t\t\t\t\t\tinvalidate();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn true;\n\t}\n \n\t// 缩放图片方法\n\tprivate void pinch() {\n\t\tdistance_new = (float) Math.sqrt(((point1_new_x - point2_new_x)\n\t\t\t\t* (point1_new_x - point2_new_x) + (point1_new_y - point2_new_y)\n\t\t\t\t* (point1_new_y - point2_new_y)));\n\t\tmatrix.postScale((distance_new / distance_old),\n\t\t\t\t(distance_new / distance_old), this.getWidth() / 2,\n\t\t\t\tthis.getTop() / 2);\n \n\t\tinvalidate();\n\t\tdistance_old = distance_new;\n\t}\n \n}\n```","slug":"Android 重写ImageView实现图片手势功能","published":1,"updated":"2019-07-31T04:10:21.566Z","_id":"cjyqq3tjb000bfkqd1tto2sfy","comments":1,"layout":"post","photos":[],"link":"","content":"<p>通过这个XImageView.java类，可实现单点触摸移动，以及双指缩放图片功能。<br>使用时，只要在布局文件中引入，并在Java代码中按照原生ImageView设置要现实的图片即可。代码如下（仅供参考）：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import android.annotation.SuppressLint;</span><br><span class=\"line\">import android.content.Context;</span><br><span class=\"line\">import android.graphics.Bitmap;</span><br><span class=\"line\">import android.graphics.BitmapFactory;</span><br><span class=\"line\">import android.graphics.Canvas;</span><br><span class=\"line\">import android.graphics.Matrix;</span><br><span class=\"line\">import android.util.AttributeSet;</span><br><span class=\"line\">import android.view.MotionEvent;</span><br><span class=\"line\">import android.widget.ImageView;</span><br><span class=\"line\"> </span><br><span class=\"line\">public class XImageView extends ImageView &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tpublic static Bitmap gintama;</span><br><span class=\"line\">\tprivate Matrix matrix;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate float point1_old_x, point1_old_y, point1_new_x, point1_new_y,</span><br><span class=\"line\">\t\t\tpoint2_old_x, point2_old_y, point2_new_x, point2_new_y,</span><br><span class=\"line\">\t\t\tdistance_old, distance_new;</span><br><span class=\"line\">\tprivate float point_old_x, point_old_y, point_new_x, point_new_y;</span><br><span class=\"line\">\tprivate boolean isMultiTouch = false;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tpublic XImageView(Context context, AttributeSet attrs) &#123;</span><br><span class=\"line\">\t\tsuper(context, attrs);</span><br><span class=\"line\">\t\tgintama = BitmapFactory.decodeResource(getResources(),</span><br><span class=\"line\">\t\t\t\tR.drawable.ic_launcher);</span><br><span class=\"line\">\t\tmatrix = new Matrix();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tpublic XImageView(Context context) &#123;</span><br><span class=\"line\">\t\tsuper(context);</span><br><span class=\"line\">\t\tgintama = BitmapFactory.decodeResource(getResources(),</span><br><span class=\"line\">\t\t\t\tR.drawable.ic_launcher);</span><br><span class=\"line\">\t\tmatrix = new Matrix();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t// 回调方法，用于画控件上的图片</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tprotected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\">\t\tcanvas.save();</span><br><span class=\"line\">\t\tcanvas.drawBitmap(gintama, matrix, null);</span><br><span class=\"line\">\t\tcanvas.restore();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t@SuppressLint(&quot;ClickableViewAccessibility&quot;)</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class=\"line\">\t\tswitch (event.getAction() &amp; MotionEvent.ACTION_MASK) &#123;</span><br><span class=\"line\">\t\tcase MotionEvent.ACTION_DOWN:</span><br><span class=\"line\">\t\t\t// 单点移动 按下</span><br><span class=\"line\">\t\t\tif (event.getPointerCount() == 1) &#123;</span><br><span class=\"line\">\t\t\t\tisMultiTouch = false;</span><br><span class=\"line\">\t\t\t\tpoint_old_x = event.getX();</span><br><span class=\"line\">\t\t\t\tpoint_old_y = event.getY();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase MotionEvent.ACTION_UP:</span><br><span class=\"line\">\t\t\t// 单点移动 抬起</span><br><span class=\"line\">\t\t\tif (event.getPointerCount() == 1) &#123;</span><br><span class=\"line\">\t\t\t\tisMultiTouch = false;</span><br><span class=\"line\">\t\t\t\tpoint_old_x = point_new_x;</span><br><span class=\"line\">\t\t\t\tpoint_old_y = point_new_y;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase MotionEvent.ACTION_POINTER_UP:</span><br><span class=\"line\">\t\t\t// 双点操作 抬起</span><br><span class=\"line\">\t\t\tif (event.getPointerCount() == 2) &#123;</span><br><span class=\"line\">\t\t\t\tisMultiTouch = true;</span><br><span class=\"line\">\t\t\t\tpoint1_old_x = point1_new_x;</span><br><span class=\"line\">\t\t\t\tpoint1_old_y = point1_new_y;</span><br><span class=\"line\">\t\t\t\tpoint2_old_x = point2_new_x;</span><br><span class=\"line\">\t\t\t\tpoint2_old_y = point2_new_y;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase MotionEvent.ACTION_POINTER_DOWN:</span><br><span class=\"line\">\t\t\t// 双点操作 按下</span><br><span class=\"line\">\t\t\tif (event.getPointerCount() == 2) &#123;</span><br><span class=\"line\">\t\t\t\tisMultiTouch = true;</span><br><span class=\"line\">\t\t\t\tpoint1_old_x = event.getX(0);</span><br><span class=\"line\">\t\t\t\tpoint1_old_y = event.getY(0);</span><br><span class=\"line\">\t\t\t\tpoint2_old_x = event.getX(1);</span><br><span class=\"line\">\t\t\t\tpoint2_old_y = event.getY(1);</span><br><span class=\"line\">\t\t\t\tdistance_old = (float) Math</span><br><span class=\"line\">\t\t\t\t\t\t.sqrt(((point1_old_x - point2_old_x)</span><br><span class=\"line\">\t\t\t\t\t\t\t\t* (point1_old_x - point2_old_x) + (point1_old_y - point2_old_y)</span><br><span class=\"line\">\t\t\t\t\t\t\t\t* (point1_old_y - point2_old_y)));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase MotionEvent.ACTION_MOVE:</span><br><span class=\"line\">\t\t\t// 双点操作 移动</span><br><span class=\"line\">\t\t\tif (event.getPointerCount() == 2) &#123;</span><br><span class=\"line\">\t\t\t\tisMultiTouch = true;</span><br><span class=\"line\">\t\t\t\tpoint1_new_x = event.getX(0);</span><br><span class=\"line\">\t\t\t\tpoint1_new_y = event.getY(0);</span><br><span class=\"line\">\t\t\t\tpoint2_new_x = event.getX(1);</span><br><span class=\"line\">\t\t\t\tpoint2_new_y = event.getY(1);</span><br><span class=\"line\">\t\t\t\tpinch();</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t// 单点移动 移动</span><br><span class=\"line\">\t\t\t\tif (event.getPointerCount() == 1) &#123;</span><br><span class=\"line\">\t\t\t\t\tif (!isMultiTouch) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tpoint_new_x = event.getX();</span><br><span class=\"line\">\t\t\t\t\t\tpoint_new_y = event.getY();</span><br><span class=\"line\">\t\t\t\t\t\tmatrix.postTranslate((point_new_x - point_old_x),</span><br><span class=\"line\">\t\t\t\t\t\t\t\t(point_new_y - point_old_y));</span><br><span class=\"line\">\t\t\t\t\t\tpoint_old_x = point_new_x;</span><br><span class=\"line\">\t\t\t\t\t\tpoint_old_y = point_new_y;</span><br><span class=\"line\">\t\t\t\t\t\tinvalidate();</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn true;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t// 缩放图片方法</span><br><span class=\"line\">\tprivate void pinch() &#123;</span><br><span class=\"line\">\t\tdistance_new = (float) Math.sqrt(((point1_new_x - point2_new_x)</span><br><span class=\"line\">\t\t\t\t* (point1_new_x - point2_new_x) + (point1_new_y - point2_new_y)</span><br><span class=\"line\">\t\t\t\t* (point1_new_y - point2_new_y)));</span><br><span class=\"line\">\t\tmatrix.postScale((distance_new / distance_old),</span><br><span class=\"line\">\t\t\t\t(distance_new / distance_old), this.getWidth() / 2,</span><br><span class=\"line\">\t\t\t\tthis.getTop() / 2);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\tinvalidate();</span><br><span class=\"line\">\t\tdistance_old = distance_new;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>通过这个XImageView.java类，可实现单点触摸移动，以及双指缩放图片功能。<br>使用时，只要在布局文件中引入，并在Java代码中按照原生ImageView设置要现实的图片即可。代码如下（仅供参考）：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import android.annotation.SuppressLint;</span><br><span class=\"line\">import android.content.Context;</span><br><span class=\"line\">import android.graphics.Bitmap;</span><br><span class=\"line\">import android.graphics.BitmapFactory;</span><br><span class=\"line\">import android.graphics.Canvas;</span><br><span class=\"line\">import android.graphics.Matrix;</span><br><span class=\"line\">import android.util.AttributeSet;</span><br><span class=\"line\">import android.view.MotionEvent;</span><br><span class=\"line\">import android.widget.ImageView;</span><br><span class=\"line\"> </span><br><span class=\"line\">public class XImageView extends ImageView &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tpublic static Bitmap gintama;</span><br><span class=\"line\">\tprivate Matrix matrix;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate float point1_old_x, point1_old_y, point1_new_x, point1_new_y,</span><br><span class=\"line\">\t\t\tpoint2_old_x, point2_old_y, point2_new_x, point2_new_y,</span><br><span class=\"line\">\t\t\tdistance_old, distance_new;</span><br><span class=\"line\">\tprivate float point_old_x, point_old_y, point_new_x, point_new_y;</span><br><span class=\"line\">\tprivate boolean isMultiTouch = false;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tpublic XImageView(Context context, AttributeSet attrs) &#123;</span><br><span class=\"line\">\t\tsuper(context, attrs);</span><br><span class=\"line\">\t\tgintama = BitmapFactory.decodeResource(getResources(),</span><br><span class=\"line\">\t\t\t\tR.drawable.ic_launcher);</span><br><span class=\"line\">\t\tmatrix = new Matrix();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tpublic XImageView(Context context) &#123;</span><br><span class=\"line\">\t\tsuper(context);</span><br><span class=\"line\">\t\tgintama = BitmapFactory.decodeResource(getResources(),</span><br><span class=\"line\">\t\t\t\tR.drawable.ic_launcher);</span><br><span class=\"line\">\t\tmatrix = new Matrix();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t// 回调方法，用于画控件上的图片</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tprotected void onDraw(Canvas canvas) &#123;</span><br><span class=\"line\">\t\tcanvas.save();</span><br><span class=\"line\">\t\tcanvas.drawBitmap(gintama, matrix, null);</span><br><span class=\"line\">\t\tcanvas.restore();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t@SuppressLint(&quot;ClickableViewAccessibility&quot;)</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class=\"line\">\t\tswitch (event.getAction() &amp; MotionEvent.ACTION_MASK) &#123;</span><br><span class=\"line\">\t\tcase MotionEvent.ACTION_DOWN:</span><br><span class=\"line\">\t\t\t// 单点移动 按下</span><br><span class=\"line\">\t\t\tif (event.getPointerCount() == 1) &#123;</span><br><span class=\"line\">\t\t\t\tisMultiTouch = false;</span><br><span class=\"line\">\t\t\t\tpoint_old_x = event.getX();</span><br><span class=\"line\">\t\t\t\tpoint_old_y = event.getY();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase MotionEvent.ACTION_UP:</span><br><span class=\"line\">\t\t\t// 单点移动 抬起</span><br><span class=\"line\">\t\t\tif (event.getPointerCount() == 1) &#123;</span><br><span class=\"line\">\t\t\t\tisMultiTouch = false;</span><br><span class=\"line\">\t\t\t\tpoint_old_x = point_new_x;</span><br><span class=\"line\">\t\t\t\tpoint_old_y = point_new_y;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase MotionEvent.ACTION_POINTER_UP:</span><br><span class=\"line\">\t\t\t// 双点操作 抬起</span><br><span class=\"line\">\t\t\tif (event.getPointerCount() == 2) &#123;</span><br><span class=\"line\">\t\t\t\tisMultiTouch = true;</span><br><span class=\"line\">\t\t\t\tpoint1_old_x = point1_new_x;</span><br><span class=\"line\">\t\t\t\tpoint1_old_y = point1_new_y;</span><br><span class=\"line\">\t\t\t\tpoint2_old_x = point2_new_x;</span><br><span class=\"line\">\t\t\t\tpoint2_old_y = point2_new_y;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase MotionEvent.ACTION_POINTER_DOWN:</span><br><span class=\"line\">\t\t\t// 双点操作 按下</span><br><span class=\"line\">\t\t\tif (event.getPointerCount() == 2) &#123;</span><br><span class=\"line\">\t\t\t\tisMultiTouch = true;</span><br><span class=\"line\">\t\t\t\tpoint1_old_x = event.getX(0);</span><br><span class=\"line\">\t\t\t\tpoint1_old_y = event.getY(0);</span><br><span class=\"line\">\t\t\t\tpoint2_old_x = event.getX(1);</span><br><span class=\"line\">\t\t\t\tpoint2_old_y = event.getY(1);</span><br><span class=\"line\">\t\t\t\tdistance_old = (float) Math</span><br><span class=\"line\">\t\t\t\t\t\t.sqrt(((point1_old_x - point2_old_x)</span><br><span class=\"line\">\t\t\t\t\t\t\t\t* (point1_old_x - point2_old_x) + (point1_old_y - point2_old_y)</span><br><span class=\"line\">\t\t\t\t\t\t\t\t* (point1_old_y - point2_old_y)));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase MotionEvent.ACTION_MOVE:</span><br><span class=\"line\">\t\t\t// 双点操作 移动</span><br><span class=\"line\">\t\t\tif (event.getPointerCount() == 2) &#123;</span><br><span class=\"line\">\t\t\t\tisMultiTouch = true;</span><br><span class=\"line\">\t\t\t\tpoint1_new_x = event.getX(0);</span><br><span class=\"line\">\t\t\t\tpoint1_new_y = event.getY(0);</span><br><span class=\"line\">\t\t\t\tpoint2_new_x = event.getX(1);</span><br><span class=\"line\">\t\t\t\tpoint2_new_y = event.getY(1);</span><br><span class=\"line\">\t\t\t\tpinch();</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t// 单点移动 移动</span><br><span class=\"line\">\t\t\t\tif (event.getPointerCount() == 1) &#123;</span><br><span class=\"line\">\t\t\t\t\tif (!isMultiTouch) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tpoint_new_x = event.getX();</span><br><span class=\"line\">\t\t\t\t\t\tpoint_new_y = event.getY();</span><br><span class=\"line\">\t\t\t\t\t\tmatrix.postTranslate((point_new_x - point_old_x),</span><br><span class=\"line\">\t\t\t\t\t\t\t\t(point_new_y - point_old_y));</span><br><span class=\"line\">\t\t\t\t\t\tpoint_old_x = point_new_x;</span><br><span class=\"line\">\t\t\t\t\t\tpoint_old_y = point_new_y;</span><br><span class=\"line\">\t\t\t\t\t\tinvalidate();</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn true;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t// 缩放图片方法</span><br><span class=\"line\">\tprivate void pinch() &#123;</span><br><span class=\"line\">\t\tdistance_new = (float) Math.sqrt(((point1_new_x - point2_new_x)</span><br><span class=\"line\">\t\t\t\t* (point1_new_x - point2_new_x) + (point1_new_y - point2_new_y)</span><br><span class=\"line\">\t\t\t\t* (point1_new_y - point2_new_y)));</span><br><span class=\"line\">\t\tmatrix.postScale((distance_new / distance_old),</span><br><span class=\"line\">\t\t\t\t(distance_new / distance_old), this.getWidth() / 2,</span><br><span class=\"line\">\t\t\t\tthis.getTop() / 2);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\tinvalidate();</span><br><span class=\"line\">\t\tdistance_old = distance_new;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Android平台录音音量计的实现","date":"2015-07-08T05:31:50.000Z","_content":"\n今天博主要给大家分享的是如何在Android平台上实现录音时的音量指示计。开门见山，先来看一张Demo的效果图：   \n![Demo样例](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTUwNzA4MTMyNTE5NzY3)\n如上图所示，两个按钮分别是开始录音和停止录音，中间的两个数字前后分别代表音量档位（目前是8档）和原始音量值（0-32767），下方是音量计，由ProgressBar负责显示。   \n完整的源码可以在下面的网址找到：   \nhttps://github.com/XiaoWenHan/AndroidMircrophoneVolumeDemo     \n欢迎各位读者批评指正，谢谢！","source":"_posts/Android平台录音音量计的实现.md","raw":"---\ntitle: Android平台录音音量计的实现\ndate: 2015-07-08 13:31:50\ntags: Android\ncategories: 编程世界\n---\n\n今天博主要给大家分享的是如何在Android平台上实现录音时的音量指示计。开门见山，先来看一张Demo的效果图：   \n![Demo样例](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTUwNzA4MTMyNTE5NzY3)\n如上图所示，两个按钮分别是开始录音和停止录音，中间的两个数字前后分别代表音量档位（目前是8档）和原始音量值（0-32767），下方是音量计，由ProgressBar负责显示。   \n完整的源码可以在下面的网址找到：   \nhttps://github.com/XiaoWenHan/AndroidMircrophoneVolumeDemo     \n欢迎各位读者批评指正，谢谢！","slug":"Android平台录音音量计的实现","published":1,"updated":"2019-07-31T04:10:27.444Z","_id":"cjyqq3tje000efkqd22g1zsbi","comments":1,"layout":"post","photos":[],"link":"","content":"<p>今天博主要给大家分享的是如何在Android平台上实现录音时的音量指示计。开门见山，先来看一张Demo的效果图：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTUwNzA4MTMyNTE5NzY3\" alt=\"Demo样例\"><br>如上图所示，两个按钮分别是开始录音和停止录音，中间的两个数字前后分别代表音量档位（目前是8档）和原始音量值（0-32767），下方是音量计，由ProgressBar负责显示。<br>完整的源码可以在下面的网址找到：<br><a href=\"https://github.com/XiaoWenHan/AndroidMircrophoneVolumeDemo\" target=\"_blank\" rel=\"noopener\">https://github.com/XiaoWenHan/AndroidMircrophoneVolumeDemo</a><br>欢迎各位读者批评指正，谢谢！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天博主要给大家分享的是如何在Android平台上实现录音时的音量指示计。开门见山，先来看一张Demo的效果图：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTUwNzA4MTMyNTE5NzY3\" alt=\"Demo样例\"><br>如上图所示，两个按钮分别是开始录音和停止录音，中间的两个数字前后分别代表音量档位（目前是8档）和原始音量值（0-32767），下方是音量计，由ProgressBar负责显示。<br>完整的源码可以在下面的网址找到：<br><a href=\"https://github.com/XiaoWenHan/AndroidMircrophoneVolumeDemo\" target=\"_blank\" rel=\"noopener\">https://github.com/XiaoWenHan/AndroidMircrophoneVolumeDemo</a><br>欢迎各位读者批评指正，谢谢！</p>\n"},{"title":"Java 文件操作工具类（Android 适用）","date":"2014-07-31T06:59:06.000Z","_content":"\n该文件操作包含了文件/文件夹的创建、复制、剪切和删除操作。具体调用方法参见类方法注释：   \n\n```\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\n \npublic class FileUtil {\n \n\t/**\n\t * 在指定的位置创建指定的文件\n\t * \n\t * @param filePath\n\t *            完整的文件路径\n\t * @param mkdir\n\t *            是否创建相关的文件夹\n\t * @throws Exception\n\t */\n\tpublic static void mkFile(String filePath, boolean mkdir) throws Exception {\n\t\tFile file = new File(filePath);\n\t\tfile.getParentFile().mkdirs();\n\t\tfile.createNewFile();\n\t\tfile = null;\n\t}\n \n\t/**\n\t * 在指定的位置创建文件夹\n\t * \n\t * @param dirPath\n\t *            文件夹路径\n\t * @return 若创建成功，则返回True；反之，则返回False\n\t */\n\tpublic static boolean mkDir(String dirPath) {\n\t\treturn new File(dirPath).mkdirs();\n\t}\n \n\t/**\n\t * 删除指定的文件\n\t * \n\t * @param filePath\n\t *            文件路径\n\t * \n\t * @return 若删除成功，则返回True；反之，则返回False\n\t * \n\t */\n\tpublic static boolean delFile(String filePath) {\n\t\treturn new File(filePath).delete();\n\t}\n \n\t/**\n\t * 删除指定的文件夹\n\t * \n\t * @param dirPath\n\t *            文件夹路径\n\t * @param delFile\n\t *            文件夹中是否包含文件\n\t * \n\t * @return 若删除成功，则返回True；反之，则返回False\n\t * \n\t */\n\tpublic static boolean delDir(String dirPath, boolean delFile) {\n\t\tif (delFile) {\n\t\t\tFile file = new File(dirPath);\n\t\t\tif (file.isFile()) {\n\t\t\t\treturn file.delete();\n\t\t\t} else if (file.isDirectory()) {\n\t\t\t\tif (file.listFiles().length == 0) {\n\t\t\t\t\treturn file.delete();\n\t\t\t\t} else {\n\t\t\t\t\tint zfiles = file.listFiles().length;\n\t\t\t\t\tFile[] delfile = file.listFiles();\n\t\t\t\t\tfor (int i = 0; i < zfiles; i++) {\n\t\t\t\t\t\tif (delfile[i].isDirectory()) {\n\t\t\t\t\t\t\tdelDir(delfile[i].getAbsolutePath(), true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdelfile[i].delete();\n\t\t\t\t\t}\n\t\t\t\t\treturn file.delete();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\treturn new File(dirPath).delete();\n\t\t}\n\t}\n \n\t/**\n\t * 复制文件/文件夹 若要进行文件夹复制，请勿将目标文件夹置于源文件夹中\n\t * \n\t * @param source\n\t *            源文件（夹）\n\t * @param target\n\t *            目标文件（夹）\n\t * @param isFolder\n\t *            若进行文件夹复制，则为True；反之为False\n\t * @throws Exception\n\t */\n\tpublic static void copy(String source, String target, boolean isFolder)\n\t\t\tthrows Exception {\n\t\tif (isFolder) {\n\t\t\t(new File(target)).mkdirs();\n\t\t\tFile a = new File(source);\n\t\t\tString[] file = a.list();\n\t\t\tFile temp = null;\n\t\t\tfor (int i = 0; i < file.length; i++) {\n\t\t\t\tif (source.endsWith(File.separator)) {\n\t\t\t\t\ttemp = new File(source + file[i]);\n\t\t\t\t} else {\n\t\t\t\t\ttemp = new File(source + File.separator + file[i]);\n\t\t\t\t}\n\t\t\t\tif (temp.isFile()) {\n\t\t\t\t\tFileInputStream input = new FileInputStream(temp);\n\t\t\t\t\tFileOutputStream output = new FileOutputStream(target + \"/\"\n\t\t\t\t\t\t\t+ (temp.getName()).toString());\n\t\t\t\t\tbyte[] b = new byte[1024];\n\t\t\t\t\tint len;\n\t\t\t\t\twhile ((len = input.read(b)) != -1) {\n\t\t\t\t\t\toutput.write(b, 0, len);\n\t\t\t\t\t}\n\t\t\t\t\toutput.flush();\n\t\t\t\t\toutput.close();\n\t\t\t\t\tinput.close();\n\t\t\t\t}\n\t\t\t\tif (temp.isDirectory()) {\n\t\t\t\t\tcopy(source + \"/\" + file[i], target + \"/\" + file[i], true);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tint byteread = 0;\n\t\t\tFile oldfile = new File(source);\n\t\t\tif (oldfile.exists()) {\n\t\t\t\tInputStream inStream = new FileInputStream(source);\n\t\t\t\tFile file = new File(target);\n\t\t\t\tfile.getParentFile().mkdirs();\n\t\t\t\tfile.createNewFile();\n\t\t\t\tFileOutputStream fs = new FileOutputStream(file);\n\t\t\t\tbyte[] buffer = new byte[1024];\n\t\t\t\twhile ((byteread = inStream.read(buffer)) != -1) {\n\t\t\t\t\tfs.write(buffer, 0, byteread);\n\t\t\t\t}\n\t\t\t\tinStream.close();\n\t\t\t\tfs.close();\n\t\t\t}\n\t\t}\n\t}\n \n\t/**\n\t * 移动指定的文件（夹）到目标文件（夹）\n\t * \n\t * @param source\n\t *            源文件（夹）\n\t * @param target\n\t *            目标文件（夹）\n\t * @param isFolder\n\t *            若为文件夹，则为True；反之为False\n\t * @return\n\t * @throws Exception\n\t */\n\tpublic static boolean move(String source, String target, boolean isFolder)\n\t\t\tthrows Exception {\n\t\tcopy(source, target, isFolder);\n\t\tif (isFolder) {\n\t\t\treturn delDir(source, true);\n\t\t} else {\n\t\t\treturn delFile(source);\n\t\t}\n\t}\n \n}\n```","source":"_posts/Java 文件操作工具类（Android 适用）.md","raw":"---\ntitle: Java 文件操作工具类（Android 适用）\ndate: 2014-07-31 14:59:06\ntags: Java\ncategories: 编程世界\n---\n\n该文件操作包含了文件/文件夹的创建、复制、剪切和删除操作。具体调用方法参见类方法注释：   \n\n```\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\n \npublic class FileUtil {\n \n\t/**\n\t * 在指定的位置创建指定的文件\n\t * \n\t * @param filePath\n\t *            完整的文件路径\n\t * @param mkdir\n\t *            是否创建相关的文件夹\n\t * @throws Exception\n\t */\n\tpublic static void mkFile(String filePath, boolean mkdir) throws Exception {\n\t\tFile file = new File(filePath);\n\t\tfile.getParentFile().mkdirs();\n\t\tfile.createNewFile();\n\t\tfile = null;\n\t}\n \n\t/**\n\t * 在指定的位置创建文件夹\n\t * \n\t * @param dirPath\n\t *            文件夹路径\n\t * @return 若创建成功，则返回True；反之，则返回False\n\t */\n\tpublic static boolean mkDir(String dirPath) {\n\t\treturn new File(dirPath).mkdirs();\n\t}\n \n\t/**\n\t * 删除指定的文件\n\t * \n\t * @param filePath\n\t *            文件路径\n\t * \n\t * @return 若删除成功，则返回True；反之，则返回False\n\t * \n\t */\n\tpublic static boolean delFile(String filePath) {\n\t\treturn new File(filePath).delete();\n\t}\n \n\t/**\n\t * 删除指定的文件夹\n\t * \n\t * @param dirPath\n\t *            文件夹路径\n\t * @param delFile\n\t *            文件夹中是否包含文件\n\t * \n\t * @return 若删除成功，则返回True；反之，则返回False\n\t * \n\t */\n\tpublic static boolean delDir(String dirPath, boolean delFile) {\n\t\tif (delFile) {\n\t\t\tFile file = new File(dirPath);\n\t\t\tif (file.isFile()) {\n\t\t\t\treturn file.delete();\n\t\t\t} else if (file.isDirectory()) {\n\t\t\t\tif (file.listFiles().length == 0) {\n\t\t\t\t\treturn file.delete();\n\t\t\t\t} else {\n\t\t\t\t\tint zfiles = file.listFiles().length;\n\t\t\t\t\tFile[] delfile = file.listFiles();\n\t\t\t\t\tfor (int i = 0; i < zfiles; i++) {\n\t\t\t\t\t\tif (delfile[i].isDirectory()) {\n\t\t\t\t\t\t\tdelDir(delfile[i].getAbsolutePath(), true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdelfile[i].delete();\n\t\t\t\t\t}\n\t\t\t\t\treturn file.delete();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\treturn new File(dirPath).delete();\n\t\t}\n\t}\n \n\t/**\n\t * 复制文件/文件夹 若要进行文件夹复制，请勿将目标文件夹置于源文件夹中\n\t * \n\t * @param source\n\t *            源文件（夹）\n\t * @param target\n\t *            目标文件（夹）\n\t * @param isFolder\n\t *            若进行文件夹复制，则为True；反之为False\n\t * @throws Exception\n\t */\n\tpublic static void copy(String source, String target, boolean isFolder)\n\t\t\tthrows Exception {\n\t\tif (isFolder) {\n\t\t\t(new File(target)).mkdirs();\n\t\t\tFile a = new File(source);\n\t\t\tString[] file = a.list();\n\t\t\tFile temp = null;\n\t\t\tfor (int i = 0; i < file.length; i++) {\n\t\t\t\tif (source.endsWith(File.separator)) {\n\t\t\t\t\ttemp = new File(source + file[i]);\n\t\t\t\t} else {\n\t\t\t\t\ttemp = new File(source + File.separator + file[i]);\n\t\t\t\t}\n\t\t\t\tif (temp.isFile()) {\n\t\t\t\t\tFileInputStream input = new FileInputStream(temp);\n\t\t\t\t\tFileOutputStream output = new FileOutputStream(target + \"/\"\n\t\t\t\t\t\t\t+ (temp.getName()).toString());\n\t\t\t\t\tbyte[] b = new byte[1024];\n\t\t\t\t\tint len;\n\t\t\t\t\twhile ((len = input.read(b)) != -1) {\n\t\t\t\t\t\toutput.write(b, 0, len);\n\t\t\t\t\t}\n\t\t\t\t\toutput.flush();\n\t\t\t\t\toutput.close();\n\t\t\t\t\tinput.close();\n\t\t\t\t}\n\t\t\t\tif (temp.isDirectory()) {\n\t\t\t\t\tcopy(source + \"/\" + file[i], target + \"/\" + file[i], true);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tint byteread = 0;\n\t\t\tFile oldfile = new File(source);\n\t\t\tif (oldfile.exists()) {\n\t\t\t\tInputStream inStream = new FileInputStream(source);\n\t\t\t\tFile file = new File(target);\n\t\t\t\tfile.getParentFile().mkdirs();\n\t\t\t\tfile.createNewFile();\n\t\t\t\tFileOutputStream fs = new FileOutputStream(file);\n\t\t\t\tbyte[] buffer = new byte[1024];\n\t\t\t\twhile ((byteread = inStream.read(buffer)) != -1) {\n\t\t\t\t\tfs.write(buffer, 0, byteread);\n\t\t\t\t}\n\t\t\t\tinStream.close();\n\t\t\t\tfs.close();\n\t\t\t}\n\t\t}\n\t}\n \n\t/**\n\t * 移动指定的文件（夹）到目标文件（夹）\n\t * \n\t * @param source\n\t *            源文件（夹）\n\t * @param target\n\t *            目标文件（夹）\n\t * @param isFolder\n\t *            若为文件夹，则为True；反之为False\n\t * @return\n\t * @throws Exception\n\t */\n\tpublic static boolean move(String source, String target, boolean isFolder)\n\t\t\tthrows Exception {\n\t\tcopy(source, target, isFolder);\n\t\tif (isFolder) {\n\t\t\treturn delDir(source, true);\n\t\t} else {\n\t\t\treturn delFile(source);\n\t\t}\n\t}\n \n}\n```","slug":"Java 文件操作工具类（Android 适用）","published":1,"updated":"2019-07-31T04:10:55.450Z","_id":"cjyqq3tjg000gfkqdnbtxg07k","comments":1,"layout":"post","photos":[],"link":"","content":"<p>该文件操作包含了文件/文件夹的创建、复制、剪切和删除操作。具体调用方法参见类方法注释：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.File;</span><br><span class=\"line\">import java.io.FileInputStream;</span><br><span class=\"line\">import java.io.FileOutputStream;</span><br><span class=\"line\">import java.io.InputStream;</span><br><span class=\"line\"> </span><br><span class=\"line\">public class FileUtil &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 在指定的位置创建指定的文件</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t * @param filePath</span><br><span class=\"line\">\t *            完整的文件路径</span><br><span class=\"line\">\t * @param mkdir</span><br><span class=\"line\">\t *            是否创建相关的文件夹</span><br><span class=\"line\">\t * @throws Exception</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic static void mkFile(String filePath, boolean mkdir) throws Exception &#123;</span><br><span class=\"line\">\t\tFile file = new File(filePath);</span><br><span class=\"line\">\t\tfile.getParentFile().mkdirs();</span><br><span class=\"line\">\t\tfile.createNewFile();</span><br><span class=\"line\">\t\tfile = null;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 在指定的位置创建文件夹</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t * @param dirPath</span><br><span class=\"line\">\t *            文件夹路径</span><br><span class=\"line\">\t * @return 若创建成功，则返回True；反之，则返回False</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic static boolean mkDir(String dirPath) &#123;</span><br><span class=\"line\">\t\treturn new File(dirPath).mkdirs();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 删除指定的文件</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t * @param filePath</span><br><span class=\"line\">\t *            文件路径</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t * @return 若删除成功，则返回True；反之，则返回False</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic static boolean delFile(String filePath) &#123;</span><br><span class=\"line\">\t\treturn new File(filePath).delete();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 删除指定的文件夹</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t * @param dirPath</span><br><span class=\"line\">\t *            文件夹路径</span><br><span class=\"line\">\t * @param delFile</span><br><span class=\"line\">\t *            文件夹中是否包含文件</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t * @return 若删除成功，则返回True；反之，则返回False</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic static boolean delDir(String dirPath, boolean delFile) &#123;</span><br><span class=\"line\">\t\tif (delFile) &#123;</span><br><span class=\"line\">\t\t\tFile file = new File(dirPath);</span><br><span class=\"line\">\t\t\tif (file.isFile()) &#123;</span><br><span class=\"line\">\t\t\t\treturn file.delete();</span><br><span class=\"line\">\t\t\t&#125; else if (file.isDirectory()) &#123;</span><br><span class=\"line\">\t\t\t\tif (file.listFiles().length == 0) &#123;</span><br><span class=\"line\">\t\t\t\t\treturn file.delete();</span><br><span class=\"line\">\t\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t\tint zfiles = file.listFiles().length;</span><br><span class=\"line\">\t\t\t\t\tFile[] delfile = file.listFiles();</span><br><span class=\"line\">\t\t\t\t\tfor (int i = 0; i &lt; zfiles; i++) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tif (delfile[i].isDirectory()) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tdelDir(delfile[i].getAbsolutePath(), true);</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\tdelfile[i].delete();</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\treturn file.delete();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\treturn false;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\treturn new File(dirPath).delete();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 复制文件/文件夹 若要进行文件夹复制，请勿将目标文件夹置于源文件夹中</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t * @param source</span><br><span class=\"line\">\t *            源文件（夹）</span><br><span class=\"line\">\t * @param target</span><br><span class=\"line\">\t *            目标文件（夹）</span><br><span class=\"line\">\t * @param isFolder</span><br><span class=\"line\">\t *            若进行文件夹复制，则为True；反之为False</span><br><span class=\"line\">\t * @throws Exception</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic static void copy(String source, String target, boolean isFolder)</span><br><span class=\"line\">\t\t\tthrows Exception &#123;</span><br><span class=\"line\">\t\tif (isFolder) &#123;</span><br><span class=\"line\">\t\t\t(new File(target)).mkdirs();</span><br><span class=\"line\">\t\t\tFile a = new File(source);</span><br><span class=\"line\">\t\t\tString[] file = a.list();</span><br><span class=\"line\">\t\t\tFile temp = null;</span><br><span class=\"line\">\t\t\tfor (int i = 0; i &lt; file.length; i++) &#123;</span><br><span class=\"line\">\t\t\t\tif (source.endsWith(File.separator)) &#123;</span><br><span class=\"line\">\t\t\t\t\ttemp = new File(source + file[i]);</span><br><span class=\"line\">\t\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t\ttemp = new File(source + File.separator + file[i]);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tif (temp.isFile()) &#123;</span><br><span class=\"line\">\t\t\t\t\tFileInputStream input = new FileInputStream(temp);</span><br><span class=\"line\">\t\t\t\t\tFileOutputStream output = new FileOutputStream(target + &quot;/&quot;</span><br><span class=\"line\">\t\t\t\t\t\t\t+ (temp.getName()).toString());</span><br><span class=\"line\">\t\t\t\t\tbyte[] b = new byte[1024];</span><br><span class=\"line\">\t\t\t\t\tint len;</span><br><span class=\"line\">\t\t\t\t\twhile ((len = input.read(b)) != -1) &#123;</span><br><span class=\"line\">\t\t\t\t\t\toutput.write(b, 0, len);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\toutput.flush();</span><br><span class=\"line\">\t\t\t\t\toutput.close();</span><br><span class=\"line\">\t\t\t\t\tinput.close();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tif (temp.isDirectory()) &#123;</span><br><span class=\"line\">\t\t\t\t\tcopy(source + &quot;/&quot; + file[i], target + &quot;/&quot; + file[i], true);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\tint byteread = 0;</span><br><span class=\"line\">\t\t\tFile oldfile = new File(source);</span><br><span class=\"line\">\t\t\tif (oldfile.exists()) &#123;</span><br><span class=\"line\">\t\t\t\tInputStream inStream = new FileInputStream(source);</span><br><span class=\"line\">\t\t\t\tFile file = new File(target);</span><br><span class=\"line\">\t\t\t\tfile.getParentFile().mkdirs();</span><br><span class=\"line\">\t\t\t\tfile.createNewFile();</span><br><span class=\"line\">\t\t\t\tFileOutputStream fs = new FileOutputStream(file);</span><br><span class=\"line\">\t\t\t\tbyte[] buffer = new byte[1024];</span><br><span class=\"line\">\t\t\t\twhile ((byteread = inStream.read(buffer)) != -1) &#123;</span><br><span class=\"line\">\t\t\t\t\tfs.write(buffer, 0, byteread);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tinStream.close();</span><br><span class=\"line\">\t\t\t\tfs.close();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 移动指定的文件（夹）到目标文件（夹）</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t * @param source</span><br><span class=\"line\">\t *            源文件（夹）</span><br><span class=\"line\">\t * @param target</span><br><span class=\"line\">\t *            目标文件（夹）</span><br><span class=\"line\">\t * @param isFolder</span><br><span class=\"line\">\t *            若为文件夹，则为True；反之为False</span><br><span class=\"line\">\t * @return</span><br><span class=\"line\">\t * @throws Exception</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic static boolean move(String source, String target, boolean isFolder)</span><br><span class=\"line\">\t\t\tthrows Exception &#123;</span><br><span class=\"line\">\t\tcopy(source, target, isFolder);</span><br><span class=\"line\">\t\tif (isFolder) &#123;</span><br><span class=\"line\">\t\t\treturn delDir(source, true);</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\treturn delFile(source);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>该文件操作包含了文件/文件夹的创建、复制、剪切和删除操作。具体调用方法参见类方法注释：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.File;</span><br><span class=\"line\">import java.io.FileInputStream;</span><br><span class=\"line\">import java.io.FileOutputStream;</span><br><span class=\"line\">import java.io.InputStream;</span><br><span class=\"line\"> </span><br><span class=\"line\">public class FileUtil &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 在指定的位置创建指定的文件</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t * @param filePath</span><br><span class=\"line\">\t *            完整的文件路径</span><br><span class=\"line\">\t * @param mkdir</span><br><span class=\"line\">\t *            是否创建相关的文件夹</span><br><span class=\"line\">\t * @throws Exception</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic static void mkFile(String filePath, boolean mkdir) throws Exception &#123;</span><br><span class=\"line\">\t\tFile file = new File(filePath);</span><br><span class=\"line\">\t\tfile.getParentFile().mkdirs();</span><br><span class=\"line\">\t\tfile.createNewFile();</span><br><span class=\"line\">\t\tfile = null;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 在指定的位置创建文件夹</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t * @param dirPath</span><br><span class=\"line\">\t *            文件夹路径</span><br><span class=\"line\">\t * @return 若创建成功，则返回True；反之，则返回False</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic static boolean mkDir(String dirPath) &#123;</span><br><span class=\"line\">\t\treturn new File(dirPath).mkdirs();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 删除指定的文件</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t * @param filePath</span><br><span class=\"line\">\t *            文件路径</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t * @return 若删除成功，则返回True；反之，则返回False</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic static boolean delFile(String filePath) &#123;</span><br><span class=\"line\">\t\treturn new File(filePath).delete();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 删除指定的文件夹</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t * @param dirPath</span><br><span class=\"line\">\t *            文件夹路径</span><br><span class=\"line\">\t * @param delFile</span><br><span class=\"line\">\t *            文件夹中是否包含文件</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t * @return 若删除成功，则返回True；反之，则返回False</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic static boolean delDir(String dirPath, boolean delFile) &#123;</span><br><span class=\"line\">\t\tif (delFile) &#123;</span><br><span class=\"line\">\t\t\tFile file = new File(dirPath);</span><br><span class=\"line\">\t\t\tif (file.isFile()) &#123;</span><br><span class=\"line\">\t\t\t\treturn file.delete();</span><br><span class=\"line\">\t\t\t&#125; else if (file.isDirectory()) &#123;</span><br><span class=\"line\">\t\t\t\tif (file.listFiles().length == 0) &#123;</span><br><span class=\"line\">\t\t\t\t\treturn file.delete();</span><br><span class=\"line\">\t\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t\tint zfiles = file.listFiles().length;</span><br><span class=\"line\">\t\t\t\t\tFile[] delfile = file.listFiles();</span><br><span class=\"line\">\t\t\t\t\tfor (int i = 0; i &lt; zfiles; i++) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tif (delfile[i].isDirectory()) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tdelDir(delfile[i].getAbsolutePath(), true);</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\tdelfile[i].delete();</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\treturn file.delete();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\treturn false;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\treturn new File(dirPath).delete();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 复制文件/文件夹 若要进行文件夹复制，请勿将目标文件夹置于源文件夹中</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t * @param source</span><br><span class=\"line\">\t *            源文件（夹）</span><br><span class=\"line\">\t * @param target</span><br><span class=\"line\">\t *            目标文件（夹）</span><br><span class=\"line\">\t * @param isFolder</span><br><span class=\"line\">\t *            若进行文件夹复制，则为True；反之为False</span><br><span class=\"line\">\t * @throws Exception</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic static void copy(String source, String target, boolean isFolder)</span><br><span class=\"line\">\t\t\tthrows Exception &#123;</span><br><span class=\"line\">\t\tif (isFolder) &#123;</span><br><span class=\"line\">\t\t\t(new File(target)).mkdirs();</span><br><span class=\"line\">\t\t\tFile a = new File(source);</span><br><span class=\"line\">\t\t\tString[] file = a.list();</span><br><span class=\"line\">\t\t\tFile temp = null;</span><br><span class=\"line\">\t\t\tfor (int i = 0; i &lt; file.length; i++) &#123;</span><br><span class=\"line\">\t\t\t\tif (source.endsWith(File.separator)) &#123;</span><br><span class=\"line\">\t\t\t\t\ttemp = new File(source + file[i]);</span><br><span class=\"line\">\t\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t\ttemp = new File(source + File.separator + file[i]);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tif (temp.isFile()) &#123;</span><br><span class=\"line\">\t\t\t\t\tFileInputStream input = new FileInputStream(temp);</span><br><span class=\"line\">\t\t\t\t\tFileOutputStream output = new FileOutputStream(target + &quot;/&quot;</span><br><span class=\"line\">\t\t\t\t\t\t\t+ (temp.getName()).toString());</span><br><span class=\"line\">\t\t\t\t\tbyte[] b = new byte[1024];</span><br><span class=\"line\">\t\t\t\t\tint len;</span><br><span class=\"line\">\t\t\t\t\twhile ((len = input.read(b)) != -1) &#123;</span><br><span class=\"line\">\t\t\t\t\t\toutput.write(b, 0, len);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\toutput.flush();</span><br><span class=\"line\">\t\t\t\t\toutput.close();</span><br><span class=\"line\">\t\t\t\t\tinput.close();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tif (temp.isDirectory()) &#123;</span><br><span class=\"line\">\t\t\t\t\tcopy(source + &quot;/&quot; + file[i], target + &quot;/&quot; + file[i], true);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\tint byteread = 0;</span><br><span class=\"line\">\t\t\tFile oldfile = new File(source);</span><br><span class=\"line\">\t\t\tif (oldfile.exists()) &#123;</span><br><span class=\"line\">\t\t\t\tInputStream inStream = new FileInputStream(source);</span><br><span class=\"line\">\t\t\t\tFile file = new File(target);</span><br><span class=\"line\">\t\t\t\tfile.getParentFile().mkdirs();</span><br><span class=\"line\">\t\t\t\tfile.createNewFile();</span><br><span class=\"line\">\t\t\t\tFileOutputStream fs = new FileOutputStream(file);</span><br><span class=\"line\">\t\t\t\tbyte[] buffer = new byte[1024];</span><br><span class=\"line\">\t\t\t\twhile ((byteread = inStream.read(buffer)) != -1) &#123;</span><br><span class=\"line\">\t\t\t\t\tfs.write(buffer, 0, byteread);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tinStream.close();</span><br><span class=\"line\">\t\t\t\tfs.close();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 移动指定的文件（夹）到目标文件（夹）</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t * @param source</span><br><span class=\"line\">\t *            源文件（夹）</span><br><span class=\"line\">\t * @param target</span><br><span class=\"line\">\t *            目标文件（夹）</span><br><span class=\"line\">\t * @param isFolder</span><br><span class=\"line\">\t *            若为文件夹，则为True；反之为False</span><br><span class=\"line\">\t * @return</span><br><span class=\"line\">\t * @throws Exception</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic static boolean move(String source, String target, boolean isFolder)</span><br><span class=\"line\">\t\t\tthrows Exception &#123;</span><br><span class=\"line\">\t\tcopy(source, target, isFolder);</span><br><span class=\"line\">\t\tif (isFolder) &#123;</span><br><span class=\"line\">\t\t\treturn delDir(source, true);</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\treturn delFile(source);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Android平台下使用ormLite的一个小Tip","date":"2017-04-06T02:19:10.000Z","_content":"\n相信不少人在实际开发中使用一些框架，在数据库这方面，有一些成熟的框架。比如greenDao，ormLite之类。   \n最近我在实际开发中，使用了ormLite。使用方法就不在赘述了，这个诸位去谷歌、百度一下就可发现，或者去官网也可。   \n这里给大家一个小提醒，在使用ormLite进行数据库存取访问时，dao类尽量使用单例。  \n我之前的写法如下：    \n\n```\npublic AvatarStoreDao(Context context) {\n    this.context = context;\n    try {\n        dbHelper = DatabaseHelper\n            .getHelper(context, number, true);\n        avatarStoresDao = dbHelper.getDao(AvatarStore.class);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n```\n\n这种写法会在每次使用前都new一个新的AvatarStoreDao对象，因此上面的构造方法也会跟着跑一次。当数据访问过于频繁的时候，某些机器容易被卡黑屏。    \n解决方法如下： \n\n```\npublic AvatarStoreDao(Context context, String number) {\n    this.context = context;\n    try {\n        dbHelper = DatabaseHelper.getHelper(context, number, true);\n        avatarStoresDao = dbHelper.getDao(AvatarStore.class);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n\npublic static AvatarStoreDao getInstance(Context context, String number) {\n    if (instance == null) {\n        instance = new AvatarStoreDao(context, number);\n    }\n    return instance;\n}\n```\n\n这样在使用前，需要调用getInstance方法，这样一来，仅当instance为null的时候才会走构造方法，可以提升一下使用的流畅性。","source":"_posts/Android平台下使用ormLite的一个小Tip.md","raw":"---\ntitle: Android平台下使用ormLite的一个小Tip\ndate: 2017-04-06 10:19:10\ntags: Android\ncategories: 编程世界\n---\n\n相信不少人在实际开发中使用一些框架，在数据库这方面，有一些成熟的框架。比如greenDao，ormLite之类。   \n最近我在实际开发中，使用了ormLite。使用方法就不在赘述了，这个诸位去谷歌、百度一下就可发现，或者去官网也可。   \n这里给大家一个小提醒，在使用ormLite进行数据库存取访问时，dao类尽量使用单例。  \n我之前的写法如下：    \n\n```\npublic AvatarStoreDao(Context context) {\n    this.context = context;\n    try {\n        dbHelper = DatabaseHelper\n            .getHelper(context, number, true);\n        avatarStoresDao = dbHelper.getDao(AvatarStore.class);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n```\n\n这种写法会在每次使用前都new一个新的AvatarStoreDao对象，因此上面的构造方法也会跟着跑一次。当数据访问过于频繁的时候，某些机器容易被卡黑屏。    \n解决方法如下： \n\n```\npublic AvatarStoreDao(Context context, String number) {\n    this.context = context;\n    try {\n        dbHelper = DatabaseHelper.getHelper(context, number, true);\n        avatarStoresDao = dbHelper.getDao(AvatarStore.class);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n\npublic static AvatarStoreDao getInstance(Context context, String number) {\n    if (instance == null) {\n        instance = new AvatarStoreDao(context, number);\n    }\n    return instance;\n}\n```\n\n这样在使用前，需要调用getInstance方法，这样一来，仅当instance为null的时候才会走构造方法，可以提升一下使用的流畅性。","slug":"Android平台下使用ormLite的一个小Tip","published":1,"updated":"2019-07-31T04:10:24.687Z","_id":"cjyqq3tji000ifkqdmmfzwkev","comments":1,"layout":"post","photos":[],"link":"","content":"<p>相信不少人在实际开发中使用一些框架，在数据库这方面，有一些成熟的框架。比如greenDao，ormLite之类。<br>最近我在实际开发中，使用了ormLite。使用方法就不在赘述了，这个诸位去谷歌、百度一下就可发现，或者去官网也可。<br>这里给大家一个小提醒，在使用ormLite进行数据库存取访问时，dao类尽量使用单例。<br>我之前的写法如下：    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public AvatarStoreDao(Context context) &#123;</span><br><span class=\"line\">    this.context = context;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        dbHelper = DatabaseHelper</span><br><span class=\"line\">            .getHelper(context, number, true);</span><br><span class=\"line\">        avatarStoresDao = dbHelper.getDao(AvatarStore.class);</span><br><span class=\"line\">    &#125; catch (Exception e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种写法会在每次使用前都new一个新的AvatarStoreDao对象，因此上面的构造方法也会跟着跑一次。当数据访问过于频繁的时候，某些机器容易被卡黑屏。<br>解决方法如下： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public AvatarStoreDao(Context context, String number) &#123;</span><br><span class=\"line\">    this.context = context;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        dbHelper = DatabaseHelper.getHelper(context, number, true);</span><br><span class=\"line\">        avatarStoresDao = dbHelper.getDao(AvatarStore.class);</span><br><span class=\"line\">    &#125; catch (Exception e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static AvatarStoreDao getInstance(Context context, String number) &#123;</span><br><span class=\"line\">    if (instance == null) &#123;</span><br><span class=\"line\">        instance = new AvatarStoreDao(context, number);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样在使用前，需要调用getInstance方法，这样一来，仅当instance为null的时候才会走构造方法，可以提升一下使用的流畅性。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>相信不少人在实际开发中使用一些框架，在数据库这方面，有一些成熟的框架。比如greenDao，ormLite之类。<br>最近我在实际开发中，使用了ormLite。使用方法就不在赘述了，这个诸位去谷歌、百度一下就可发现，或者去官网也可。<br>这里给大家一个小提醒，在使用ormLite进行数据库存取访问时，dao类尽量使用单例。<br>我之前的写法如下：    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public AvatarStoreDao(Context context) &#123;</span><br><span class=\"line\">    this.context = context;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        dbHelper = DatabaseHelper</span><br><span class=\"line\">            .getHelper(context, number, true);</span><br><span class=\"line\">        avatarStoresDao = dbHelper.getDao(AvatarStore.class);</span><br><span class=\"line\">    &#125; catch (Exception e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种写法会在每次使用前都new一个新的AvatarStoreDao对象，因此上面的构造方法也会跟着跑一次。当数据访问过于频繁的时候，某些机器容易被卡黑屏。<br>解决方法如下： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public AvatarStoreDao(Context context, String number) &#123;</span><br><span class=\"line\">    this.context = context;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        dbHelper = DatabaseHelper.getHelper(context, number, true);</span><br><span class=\"line\">        avatarStoresDao = dbHelper.getDao(AvatarStore.class);</span><br><span class=\"line\">    &#125; catch (Exception e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static AvatarStoreDao getInstance(Context context, String number) &#123;</span><br><span class=\"line\">    if (instance == null) &#123;</span><br><span class=\"line\">        instance = new AvatarStoreDao(context, number);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样在使用前，需要调用getInstance方法，这样一来，仅当instance为null的时候才会走构造方法，可以提升一下使用的流畅性。</p>\n"},{"title":"CSDN 开博寄语","date":"2014-06-27T08:08:18.000Z","_content":"\n终于有个时间能让自己安静一下了。   \n2014年已经过半，下周就是7月份了。自从新浪博客转战到CSDN之后就没怎么发过博文，说的实在一点，连博客也很少上了。   \n发几句牢骚的话，现在的人们，内心比较浮躁，能踏实下来阅读博客的人越来越少，更别提写博文了。其实这样的情况也发生在我身上，写代码的时候经常是百度谷歌，然后复制粘贴，能用了就行了，虽然很多时候很想总结一些东西，可就是懒得去写，懒得去弄。工作了也有两年了差不多，能拿出来和别人Share的东西屈指可数。   \n另外还有对技术的选择。今天看别人在博客里面说，现在的技术门类很多，当我们看到那一扇扇敞开的技术大门时，我们不知所措；当我们踏进其中的一个的时候，又发现一眼望不到头。而且有一种被技术所束缚的感觉，觉得自己的命运会随着某一项或者某几项技术所牵连。一旦这项技术大热，自己也会变得抢手；反之，则会担心自己的未来，悔恨当初的选择。这无疑体现了面对选择的迷茫和对自己能力的不自信，尽管从理论上讲，高级程序语言是有共性的，但还是会有这种担心。  \n自从年初进了一家比较有年头的国企之后，人就变得更懒了。总想学点什么跟上时代，却总也是浅尝辄止。尽管最近事务繁多，可这也不能成为理由，总之这样的状态真的很不好。  \nCSDN是我很少涉足的地界，希望在这里能够养成知识总结的好习惯，从现在开始。  \n\nPS：结尾一句颇有中“常立志”而非“立长志”的意味，不管如何，这篇文章虽是发在网上，但也是对自我的激励，其中的轻重唯有自己最清楚。","source":"_posts/CSDN 开博寄语.md","raw":"---\ntitle: CSDN 开博寄语\ndate: 2014-06-27 16:08:18\ntags: 其他\ncategories: 聊聊人生\n---\n\n终于有个时间能让自己安静一下了。   \n2014年已经过半，下周就是7月份了。自从新浪博客转战到CSDN之后就没怎么发过博文，说的实在一点，连博客也很少上了。   \n发几句牢骚的话，现在的人们，内心比较浮躁，能踏实下来阅读博客的人越来越少，更别提写博文了。其实这样的情况也发生在我身上，写代码的时候经常是百度谷歌，然后复制粘贴，能用了就行了，虽然很多时候很想总结一些东西，可就是懒得去写，懒得去弄。工作了也有两年了差不多，能拿出来和别人Share的东西屈指可数。   \n另外还有对技术的选择。今天看别人在博客里面说，现在的技术门类很多，当我们看到那一扇扇敞开的技术大门时，我们不知所措；当我们踏进其中的一个的时候，又发现一眼望不到头。而且有一种被技术所束缚的感觉，觉得自己的命运会随着某一项或者某几项技术所牵连。一旦这项技术大热，自己也会变得抢手；反之，则会担心自己的未来，悔恨当初的选择。这无疑体现了面对选择的迷茫和对自己能力的不自信，尽管从理论上讲，高级程序语言是有共性的，但还是会有这种担心。  \n自从年初进了一家比较有年头的国企之后，人就变得更懒了。总想学点什么跟上时代，却总也是浅尝辄止。尽管最近事务繁多，可这也不能成为理由，总之这样的状态真的很不好。  \nCSDN是我很少涉足的地界，希望在这里能够养成知识总结的好习惯，从现在开始。  \n\nPS：结尾一句颇有中“常立志”而非“立长志”的意味，不管如何，这篇文章虽是发在网上，但也是对自我的激励，其中的轻重唯有自己最清楚。","slug":"CSDN 开博寄语","published":1,"updated":"2019-07-31T04:10:45.967Z","_id":"cjyqq3tjk000lfkqdirpzt33s","comments":1,"layout":"post","photos":[],"link":"","content":"<p>终于有个时间能让自己安静一下了。<br>2014年已经过半，下周就是7月份了。自从新浪博客转战到CSDN之后就没怎么发过博文，说的实在一点，连博客也很少上了。<br>发几句牢骚的话，现在的人们，内心比较浮躁，能踏实下来阅读博客的人越来越少，更别提写博文了。其实这样的情况也发生在我身上，写代码的时候经常是百度谷歌，然后复制粘贴，能用了就行了，虽然很多时候很想总结一些东西，可就是懒得去写，懒得去弄。工作了也有两年了差不多，能拿出来和别人Share的东西屈指可数。<br>另外还有对技术的选择。今天看别人在博客里面说，现在的技术门类很多，当我们看到那一扇扇敞开的技术大门时，我们不知所措；当我们踏进其中的一个的时候，又发现一眼望不到头。而且有一种被技术所束缚的感觉，觉得自己的命运会随着某一项或者某几项技术所牵连。一旦这项技术大热，自己也会变得抢手；反之，则会担心自己的未来，悔恨当初的选择。这无疑体现了面对选择的迷茫和对自己能力的不自信，尽管从理论上讲，高级程序语言是有共性的，但还是会有这种担心。<br>自从年初进了一家比较有年头的国企之后，人就变得更懒了。总想学点什么跟上时代，却总也是浅尝辄止。尽管最近事务繁多，可这也不能成为理由，总之这样的状态真的很不好。<br>CSDN是我很少涉足的地界，希望在这里能够养成知识总结的好习惯，从现在开始。  </p>\n<p>PS：结尾一句颇有中“常立志”而非“立长志”的意味，不管如何，这篇文章虽是发在网上，但也是对自我的激励，其中的轻重唯有自己最清楚。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>终于有个时间能让自己安静一下了。<br>2014年已经过半，下周就是7月份了。自从新浪博客转战到CSDN之后就没怎么发过博文，说的实在一点，连博客也很少上了。<br>发几句牢骚的话，现在的人们，内心比较浮躁，能踏实下来阅读博客的人越来越少，更别提写博文了。其实这样的情况也发生在我身上，写代码的时候经常是百度谷歌，然后复制粘贴，能用了就行了，虽然很多时候很想总结一些东西，可就是懒得去写，懒得去弄。工作了也有两年了差不多，能拿出来和别人Share的东西屈指可数。<br>另外还有对技术的选择。今天看别人在博客里面说，现在的技术门类很多，当我们看到那一扇扇敞开的技术大门时，我们不知所措；当我们踏进其中的一个的时候，又发现一眼望不到头。而且有一种被技术所束缚的感觉，觉得自己的命运会随着某一项或者某几项技术所牵连。一旦这项技术大热，自己也会变得抢手；反之，则会担心自己的未来，悔恨当初的选择。这无疑体现了面对选择的迷茫和对自己能力的不自信，尽管从理论上讲，高级程序语言是有共性的，但还是会有这种担心。<br>自从年初进了一家比较有年头的国企之后，人就变得更懒了。总想学点什么跟上时代，却总也是浅尝辄止。尽管最近事务繁多，可这也不能成为理由，总之这样的状态真的很不好。<br>CSDN是我很少涉足的地界，希望在这里能够养成知识总结的好习惯，从现在开始。  </p>\n<p>PS：结尾一句颇有中“常立志”而非“立长志”的意味，不管如何，这篇文章虽是发在网上，但也是对自我的激励，其中的轻重唯有自己最清楚。</p>\n"},{"title":"个性化个人主站——使用Hexo框架","date":"2015-07-02T05:55:23.000Z","_content":"\n开门见山，之前我们有谈过使用Github来搭建免费的个人博客站点，从而摆脱现有博客提供商的限制，实现对博客内容的完全自定义。今天我们借用Hexo的框架来搭建站点。\n\n关于搭建的过程，可以参考这位仁兄的博文：  \n[http://ibruce.info/2013/11/22/hexo-your-blog/](http://ibruce.info/2013/11/22/hexo-your-blog/)   \n还有Hexo框架的网站（下载安装Hexo会用到）：  \n[http://hexo.io/](http://hexo.io/)   \n我在这里依旧是给大家的建站过程提供一些提示。  \n\n\n**Node.js**   \n关于Node.js呢，如果大家使用Windows，而且是下载的exe安装程序安装的话，即使在安装程序里面选中了加入环境变量，在命令提示符中敲npm指令依旧不起作用。起码在单位的Windows 7和我自己电脑的Windows 8.1平台上是这样。解决之道是打开系统的环境变量设置，输入一个空格，再去掉这个空格，确定生效一下即可。~囧~  \n\n\n**关于本地化和个性化**  \n其实，Hexo官方给出了多语言的解决方案，在框架根目录的\\_config.yml中进行配置就好。但是当我一旦在language字段写入CN之后就会在生成过程中报错，不知为何。   \n因此我就绕道而行，直接去改themes中的主题文件了。这里列举一些（以默认landscape为例）：  \n在themes\\landscape目录下，也有一个叫做\\_config.yml文件。打开它，在menu组下有几对对应的关系，前面的\"Home\"之类的英文，这些对应与网站左上角的栏目，把它改成中文的吧。比如：首页、归档……此外，这里支持扩展，比如你可以加上：  \n博客: http://blog.csdn.net/xwhnew  \n当访客点击博客时，就会自动跳转到上面的网页了。  \nContent注释下的excerpt_link是博文的概览后的“Read more”文字内容，将其改为“阅读更多”即完成汉化。  \nMiscellaneous注释下的favicon是网站的图标，不多说了，个性化必须改的！  \n在themes\\landscape\\layout\\_widget下各个文件中，widget-title记得改为中文，比如archive是归档。  \nthemes\\landscape\\source\\css\\images路径下的banner.jpg，是网站上方的背景图，换成自己喜欢的吧！  \n\n**有关博文移植**  \n相信不少朋友希望把自己的所有博文都移植到个人站点中。想法不错，实现起来呢，基本掌握Markdown语法是必须的；其次，要有一个比较好的编辑器，网上有在线版，也有软件。这里比较推荐MarkdownPad，是一个PC端软件，无需购买付费版即完全够用，我现在也在用。最后，Hexo是根据.md文件的头部信息来读取日期信息的，如果我们是移植之前的博文，只需在date后将当前的时间改为旧博文发布的时间即可。","source":"_posts/个性化个人主站——使用Hexo框架.md","raw":"---\ntitle: 个性化个人主站——使用Hexo框架\ndate: 2015-07-02 13:55:23\ntags: Web\ncategories: 编程世界\n---\n\n开门见山，之前我们有谈过使用Github来搭建免费的个人博客站点，从而摆脱现有博客提供商的限制，实现对博客内容的完全自定义。今天我们借用Hexo的框架来搭建站点。\n\n关于搭建的过程，可以参考这位仁兄的博文：  \n[http://ibruce.info/2013/11/22/hexo-your-blog/](http://ibruce.info/2013/11/22/hexo-your-blog/)   \n还有Hexo框架的网站（下载安装Hexo会用到）：  \n[http://hexo.io/](http://hexo.io/)   \n我在这里依旧是给大家的建站过程提供一些提示。  \n\n\n**Node.js**   \n关于Node.js呢，如果大家使用Windows，而且是下载的exe安装程序安装的话，即使在安装程序里面选中了加入环境变量，在命令提示符中敲npm指令依旧不起作用。起码在单位的Windows 7和我自己电脑的Windows 8.1平台上是这样。解决之道是打开系统的环境变量设置，输入一个空格，再去掉这个空格，确定生效一下即可。~囧~  \n\n\n**关于本地化和个性化**  \n其实，Hexo官方给出了多语言的解决方案，在框架根目录的\\_config.yml中进行配置就好。但是当我一旦在language字段写入CN之后就会在生成过程中报错，不知为何。   \n因此我就绕道而行，直接去改themes中的主题文件了。这里列举一些（以默认landscape为例）：  \n在themes\\landscape目录下，也有一个叫做\\_config.yml文件。打开它，在menu组下有几对对应的关系，前面的\"Home\"之类的英文，这些对应与网站左上角的栏目，把它改成中文的吧。比如：首页、归档……此外，这里支持扩展，比如你可以加上：  \n博客: http://blog.csdn.net/xwhnew  \n当访客点击博客时，就会自动跳转到上面的网页了。  \nContent注释下的excerpt_link是博文的概览后的“Read more”文字内容，将其改为“阅读更多”即完成汉化。  \nMiscellaneous注释下的favicon是网站的图标，不多说了，个性化必须改的！  \n在themes\\landscape\\layout\\_widget下各个文件中，widget-title记得改为中文，比如archive是归档。  \nthemes\\landscape\\source\\css\\images路径下的banner.jpg，是网站上方的背景图，换成自己喜欢的吧！  \n\n**有关博文移植**  \n相信不少朋友希望把自己的所有博文都移植到个人站点中。想法不错，实现起来呢，基本掌握Markdown语法是必须的；其次，要有一个比较好的编辑器，网上有在线版，也有软件。这里比较推荐MarkdownPad，是一个PC端软件，无需购买付费版即完全够用，我现在也在用。最后，Hexo是根据.md文件的头部信息来读取日期信息的，如果我们是移植之前的博文，只需在date后将当前的时间改为旧博文发布的时间即可。","slug":"个性化个人主站——使用Hexo框架","published":1,"updated":"2019-07-31T04:11:01.782Z","_id":"cjyqq3tjm000nfkqdxf2im5r3","comments":1,"layout":"post","photos":[],"link":"","content":"<p>开门见山，之前我们有谈过使用Github来搭建免费的个人博客站点，从而摆脱现有博客提供商的限制，实现对博客内容的完全自定义。今天我们借用Hexo的框架来搭建站点。</p>\n<p>关于搭建的过程，可以参考这位仁兄的博文：<br><a href=\"http://ibruce.info/2013/11/22/hexo-your-blog/\" target=\"_blank\" rel=\"noopener\">http://ibruce.info/2013/11/22/hexo-your-blog/</a><br>还有Hexo框架的网站（下载安装Hexo会用到）：<br><a href=\"http://hexo.io/\" target=\"_blank\" rel=\"noopener\">http://hexo.io/</a><br>我在这里依旧是给大家的建站过程提供一些提示。  </p>\n<p><strong>Node.js</strong><br>关于Node.js呢，如果大家使用Windows，而且是下载的exe安装程序安装的话，即使在安装程序里面选中了加入环境变量，在命令提示符中敲npm指令依旧不起作用。起码在单位的Windows 7和我自己电脑的Windows 8.1平台上是这样。解决之道是打开系统的环境变量设置，输入一个空格，再去掉这个空格，确定生效一下即可。<del>囧</del>  </p>\n<p><strong>关于本地化和个性化</strong><br>其实，Hexo官方给出了多语言的解决方案，在框架根目录的_config.yml中进行配置就好。但是当我一旦在language字段写入CN之后就会在生成过程中报错，不知为何。<br>因此我就绕道而行，直接去改themes中的主题文件了。这里列举一些（以默认landscape为例）：<br>在themes\\landscape目录下，也有一个叫做_config.yml文件。打开它，在menu组下有几对对应的关系，前面的”Home”之类的英文，这些对应与网站左上角的栏目，把它改成中文的吧。比如：首页、归档……此外，这里支持扩展，比如你可以加上：<br>博客: <a href=\"http://blog.csdn.net/xwhnew\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/xwhnew</a><br>当访客点击博客时，就会自动跳转到上面的网页了。<br>Content注释下的excerpt_link是博文的概览后的“Read more”文字内容，将其改为“阅读更多”即完成汉化。<br>Miscellaneous注释下的favicon是网站的图标，不多说了，个性化必须改的！<br>在themes\\landscape\\layout_widget下各个文件中，widget-title记得改为中文，比如archive是归档。<br>themes\\landscape\\source\\css\\images路径下的banner.jpg，是网站上方的背景图，换成自己喜欢的吧！  </p>\n<p><strong>有关博文移植</strong><br>相信不少朋友希望把自己的所有博文都移植到个人站点中。想法不错，实现起来呢，基本掌握Markdown语法是必须的；其次，要有一个比较好的编辑器，网上有在线版，也有软件。这里比较推荐MarkdownPad，是一个PC端软件，无需购买付费版即完全够用，我现在也在用。最后，Hexo是根据.md文件的头部信息来读取日期信息的，如果我们是移植之前的博文，只需在date后将当前的时间改为旧博文发布的时间即可。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>开门见山，之前我们有谈过使用Github来搭建免费的个人博客站点，从而摆脱现有博客提供商的限制，实现对博客内容的完全自定义。今天我们借用Hexo的框架来搭建站点。</p>\n<p>关于搭建的过程，可以参考这位仁兄的博文：<br><a href=\"http://ibruce.info/2013/11/22/hexo-your-blog/\" target=\"_blank\" rel=\"noopener\">http://ibruce.info/2013/11/22/hexo-your-blog/</a><br>还有Hexo框架的网站（下载安装Hexo会用到）：<br><a href=\"http://hexo.io/\" target=\"_blank\" rel=\"noopener\">http://hexo.io/</a><br>我在这里依旧是给大家的建站过程提供一些提示。  </p>\n<p><strong>Node.js</strong><br>关于Node.js呢，如果大家使用Windows，而且是下载的exe安装程序安装的话，即使在安装程序里面选中了加入环境变量，在命令提示符中敲npm指令依旧不起作用。起码在单位的Windows 7和我自己电脑的Windows 8.1平台上是这样。解决之道是打开系统的环境变量设置，输入一个空格，再去掉这个空格，确定生效一下即可。<del>囧</del>  </p>\n<p><strong>关于本地化和个性化</strong><br>其实，Hexo官方给出了多语言的解决方案，在框架根目录的_config.yml中进行配置就好。但是当我一旦在language字段写入CN之后就会在生成过程中报错，不知为何。<br>因此我就绕道而行，直接去改themes中的主题文件了。这里列举一些（以默认landscape为例）：<br>在themes\\landscape目录下，也有一个叫做_config.yml文件。打开它，在menu组下有几对对应的关系，前面的”Home”之类的英文，这些对应与网站左上角的栏目，把它改成中文的吧。比如：首页、归档……此外，这里支持扩展，比如你可以加上：<br>博客: <a href=\"http://blog.csdn.net/xwhnew\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/xwhnew</a><br>当访客点击博客时，就会自动跳转到上面的网页了。<br>Content注释下的excerpt_link是博文的概览后的“Read more”文字内容，将其改为“阅读更多”即完成汉化。<br>Miscellaneous注释下的favicon是网站的图标，不多说了，个性化必须改的！<br>在themes\\landscape\\layout_widget下各个文件中，widget-title记得改为中文，比如archive是归档。<br>themes\\landscape\\source\\css\\images路径下的banner.jpg，是网站上方的背景图，换成自己喜欢的吧！  </p>\n<p><strong>有关博文移植</strong><br>相信不少朋友希望把自己的所有博文都移植到个人站点中。想法不错，实现起来呢，基本掌握Markdown语法是必须的；其次，要有一个比较好的编辑器，网上有在线版，也有软件。这里比较推荐MarkdownPad，是一个PC端软件，无需购买付费版即完全够用，我现在也在用。最后，Hexo是根据.md文件的头部信息来读取日期信息的，如果我们是移植之前的博文，只需在date后将当前的时间改为旧博文发布的时间即可。</p>\n"},{"title":"为了安全——应用锁屏开发实战","date":"2016-03-16T07:49:45.000Z","_content":"\n今天我们来谈一个问题：应用锁屏。  \n说老实话，这种设定目前已经被广泛使用了，多见于支付宝、京东金融、QQ等对安全性和隐私性要求较高的程序使用。  \n关于该功能的实现，有不止一条解决办法。这里就不一一列举了，只对其中一种做详细解释和示例程序的代码分享。  \n这里我声明一下，好像自从写博客到现在，我一直都在用Android Studio为IDE来开发，强烈建议还在使用Eclipse的小伙伴尽快使用它。尽管一上来可能有些许不便，但是上手之后效率会有所提高，不信就去试试！  \n本文介绍的方法解决思路如下：\n\n 1. 监听屏幕变化，即关闭和打开屏幕；\n 2. 设置需要出现锁屏的标志变量，默认值为false。当接收到屏幕被关闭的广播后，将其置为true。\n 3. 在Activity生命周期onResume中，检测上述变量值，若为true，则启动安全校验机制，反之无操作。\n \nDemo代码中包含的锁屏机制提供了多种选项，可自由组合实现不同的应用解锁效果。  \n## 步骤1 设置监听器 ##\n首先我们写一个类，集成BroadcastReceiver，用来接收系统Screen off的Action。这里我才用了Java代码中动态注册监听器的方法，而非xml配置文件，因为这样可以更方便的让我们对监听使能进行控制。由于监听器需要在代码中进行实例化，因此我们可以在监听器相关类中定义布尔变量，来标识是否有了关闭屏幕的操作。代码片段如下所示：  \n\n```\npublic class LockScreenReceiver extends BroadcastReceiver {\n\n    private boolean isNeedCheck;\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        if (intent.getAction().equals(Intent.ACTION_SCREEN_OFF)) {\n        //关闭屏幕\n        isNeedCheck = true;\n        }\n    }\n\n    public void unRegist() {\n        isNeedCheck = false;\n    }\n\n    public boolean isNeedCheck() {\n        return isNeedCheck;\n    }\n}\n```\n\n## 步骤2 动态注册监听器 ##\n这一步骤要求我们对监听器进行动态注册，所谓动态注册就是绑定到指定的控件上，由用户自由选择，进行注册和取消注册。  \n具体代码见Demo。下面放上Github地址：  \nhttps://github.com/XiaoWenHan/Demo_SafeScreen\n","source":"_posts/为了安全——应用锁屏开发实战.md","raw":"---\ntitle: 为了安全——应用锁屏开发实战\ndate: 2016-03-16 15:49:45\ntags: Android\ncategories: 编程世界\n---\n\n今天我们来谈一个问题：应用锁屏。  \n说老实话，这种设定目前已经被广泛使用了，多见于支付宝、京东金融、QQ等对安全性和隐私性要求较高的程序使用。  \n关于该功能的实现，有不止一条解决办法。这里就不一一列举了，只对其中一种做详细解释和示例程序的代码分享。  \n这里我声明一下，好像自从写博客到现在，我一直都在用Android Studio为IDE来开发，强烈建议还在使用Eclipse的小伙伴尽快使用它。尽管一上来可能有些许不便，但是上手之后效率会有所提高，不信就去试试！  \n本文介绍的方法解决思路如下：\n\n 1. 监听屏幕变化，即关闭和打开屏幕；\n 2. 设置需要出现锁屏的标志变量，默认值为false。当接收到屏幕被关闭的广播后，将其置为true。\n 3. 在Activity生命周期onResume中，检测上述变量值，若为true，则启动安全校验机制，反之无操作。\n \nDemo代码中包含的锁屏机制提供了多种选项，可自由组合实现不同的应用解锁效果。  \n## 步骤1 设置监听器 ##\n首先我们写一个类，集成BroadcastReceiver，用来接收系统Screen off的Action。这里我才用了Java代码中动态注册监听器的方法，而非xml配置文件，因为这样可以更方便的让我们对监听使能进行控制。由于监听器需要在代码中进行实例化，因此我们可以在监听器相关类中定义布尔变量，来标识是否有了关闭屏幕的操作。代码片段如下所示：  \n\n```\npublic class LockScreenReceiver extends BroadcastReceiver {\n\n    private boolean isNeedCheck;\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        if (intent.getAction().equals(Intent.ACTION_SCREEN_OFF)) {\n        //关闭屏幕\n        isNeedCheck = true;\n        }\n    }\n\n    public void unRegist() {\n        isNeedCheck = false;\n    }\n\n    public boolean isNeedCheck() {\n        return isNeedCheck;\n    }\n}\n```\n\n## 步骤2 动态注册监听器 ##\n这一步骤要求我们对监听器进行动态注册，所谓动态注册就是绑定到指定的控件上，由用户自由选择，进行注册和取消注册。  \n具体代码见Demo。下面放上Github地址：  \nhttps://github.com/XiaoWenHan/Demo_SafeScreen\n","slug":"为了安全——应用锁屏开发实战","published":1,"updated":"2019-07-31T04:11:05.542Z","_id":"cjyqq3tjn000pfkqd56yjy9y6","comments":1,"layout":"post","photos":[],"link":"","content":"<p>今天我们来谈一个问题：应用锁屏。<br>说老实话，这种设定目前已经被广泛使用了，多见于支付宝、京东金融、QQ等对安全性和隐私性要求较高的程序使用。<br>关于该功能的实现，有不止一条解决办法。这里就不一一列举了，只对其中一种做详细解释和示例程序的代码分享。<br>这里我声明一下，好像自从写博客到现在，我一直都在用Android Studio为IDE来开发，强烈建议还在使用Eclipse的小伙伴尽快使用它。尽管一上来可能有些许不便，但是上手之后效率会有所提高，不信就去试试！<br>本文介绍的方法解决思路如下：</p>\n<ol>\n<li>监听屏幕变化，即关闭和打开屏幕；</li>\n<li>设置需要出现锁屏的标志变量，默认值为false。当接收到屏幕被关闭的广播后，将其置为true。</li>\n<li>在Activity生命周期onResume中，检测上述变量值，若为true，则启动安全校验机制，反之无操作。</li>\n</ol>\n<p>Demo代码中包含的锁屏机制提供了多种选项，可自由组合实现不同的应用解锁效果。  </p>\n<h2 id=\"步骤1-设置监听器\"><a href=\"#步骤1-设置监听器\" class=\"headerlink\" title=\"步骤1 设置监听器\"></a>步骤1 设置监听器</h2><p>首先我们写一个类，集成BroadcastReceiver，用来接收系统Screen off的Action。这里我才用了Java代码中动态注册监听器的方法，而非xml配置文件，因为这样可以更方便的让我们对监听使能进行控制。由于监听器需要在代码中进行实例化，因此我们可以在监听器相关类中定义布尔变量，来标识是否有了关闭屏幕的操作。代码片段如下所示：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class LockScreenReceiver extends BroadcastReceiver &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private boolean isNeedCheck;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class=\"line\">        if (intent.getAction().equals(Intent.ACTION_SCREEN_OFF)) &#123;</span><br><span class=\"line\">        //关闭屏幕</span><br><span class=\"line\">        isNeedCheck = true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void unRegist() &#123;</span><br><span class=\"line\">        isNeedCheck = false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean isNeedCheck() &#123;</span><br><span class=\"line\">        return isNeedCheck;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"步骤2-动态注册监听器\"><a href=\"#步骤2-动态注册监听器\" class=\"headerlink\" title=\"步骤2 动态注册监听器\"></a>步骤2 动态注册监听器</h2><p>这一步骤要求我们对监听器进行动态注册，所谓动态注册就是绑定到指定的控件上，由用户自由选择，进行注册和取消注册。<br>具体代码见Demo。下面放上Github地址：<br><a href=\"https://github.com/XiaoWenHan/Demo_SafeScreen\" target=\"_blank\" rel=\"noopener\">https://github.com/XiaoWenHan/Demo_SafeScreen</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天我们来谈一个问题：应用锁屏。<br>说老实话，这种设定目前已经被广泛使用了，多见于支付宝、京东金融、QQ等对安全性和隐私性要求较高的程序使用。<br>关于该功能的实现，有不止一条解决办法。这里就不一一列举了，只对其中一种做详细解释和示例程序的代码分享。<br>这里我声明一下，好像自从写博客到现在，我一直都在用Android Studio为IDE来开发，强烈建议还在使用Eclipse的小伙伴尽快使用它。尽管一上来可能有些许不便，但是上手之后效率会有所提高，不信就去试试！<br>本文介绍的方法解决思路如下：</p>\n<ol>\n<li>监听屏幕变化，即关闭和打开屏幕；</li>\n<li>设置需要出现锁屏的标志变量，默认值为false。当接收到屏幕被关闭的广播后，将其置为true。</li>\n<li>在Activity生命周期onResume中，检测上述变量值，若为true，则启动安全校验机制，反之无操作。</li>\n</ol>\n<p>Demo代码中包含的锁屏机制提供了多种选项，可自由组合实现不同的应用解锁效果。  </p>\n<h2 id=\"步骤1-设置监听器\"><a href=\"#步骤1-设置监听器\" class=\"headerlink\" title=\"步骤1 设置监听器\"></a>步骤1 设置监听器</h2><p>首先我们写一个类，集成BroadcastReceiver，用来接收系统Screen off的Action。这里我才用了Java代码中动态注册监听器的方法，而非xml配置文件，因为这样可以更方便的让我们对监听使能进行控制。由于监听器需要在代码中进行实例化，因此我们可以在监听器相关类中定义布尔变量，来标识是否有了关闭屏幕的操作。代码片段如下所示：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class LockScreenReceiver extends BroadcastReceiver &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private boolean isNeedCheck;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class=\"line\">        if (intent.getAction().equals(Intent.ACTION_SCREEN_OFF)) &#123;</span><br><span class=\"line\">        //关闭屏幕</span><br><span class=\"line\">        isNeedCheck = true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void unRegist() &#123;</span><br><span class=\"line\">        isNeedCheck = false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean isNeedCheck() &#123;</span><br><span class=\"line\">        return isNeedCheck;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"步骤2-动态注册监听器\"><a href=\"#步骤2-动态注册监听器\" class=\"headerlink\" title=\"步骤2 动态注册监听器\"></a>步骤2 动态注册监听器</h2><p>这一步骤要求我们对监听器进行动态注册，所谓动态注册就是绑定到指定的控件上，由用户自由选择，进行注册和取消注册。<br>具体代码见Demo。下面放上Github地址：<br><a href=\"https://github.com/XiaoWenHan/Demo_SafeScreen\" target=\"_blank\" rel=\"noopener\">https://github.com/XiaoWenHan/Demo_SafeScreen</a></p>\n"},{"title":"IntelliJ IDEA 14 值得你弃用Eclipse的IDE神器","date":"2014-11-06T11:42:33.000Z","_content":"\n今天看新闻，发现IntelliJ IDEA版本出了14，本着生命在于折腾的原则，下载并安装。   \n当然，是开玩笑的啦！作为比较资深的Android开发者，相信朋友们不会不知道Android Studio这个软件。它就是基于IntelliJ IDEA（以下简称IDEA），所以借着新版本的发布，看看最原始的IDEA是个什么模样。   \n注：大家一定要有信心，这款IDE我上手的时间仅仅用了2个小时不到，个人感觉还是比较适合我的。如果花上两个小时能够提高日后的编码效率，还是很值得的。   \nIDEA分为两大版本，Ultimate（付费）和Community（免费）。大家可以搜索一下，他们的差距还是相当大的，主要区别在于对Web开发的支持。虽然我只是在Android平台上面开发，但是谁又说得准会不会写个JSP之类的，万一要写了呢？所以我使用了功能比较全面的Ultimate（收费软件在我国情况……大家了解的，可以去下载相关工具）。   \n不出意外的话，首次运行会让用户选择使用的插件，默认是全开，一路下一步后显示下面的界面：   \n\n![IDEA 14启动界面](https://img-blog.csdn.net/20141106191706001?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n这里大家明确一下概念，往常在Eclipse中，有个“Workspace”的概念，我们会把很多项目放在一个工作空间中。到了idea中，完全不一样了。它的做法是，一个Project对应一个Module，一个Module对应我们的一个项目。但是不推荐一个Project包含多个Module，因为默认情况下输出目录之类的文件会放在一起，这也是官方不建议的。简而言之，就是一个Project对应一个项目，没有Workspace的概念。   \n下面我们创建android应用程序，在此之前要创建一个Project，类型为Android。   \n![新建项目](https://img-blog.csdn.net/20141106192220312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n大家注意看左边的类型，免费版会少很多，真的是很多。所以再次提醒一下，防患于未然，万一要用呢。   \n下一步后和Eclipse里面创建项目大体相当，不再多说。   \n\n![创建项目](https://img-blog.csdn.net/20141106192406968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n下一屏幕我们需要指定一下使用的JDK和SAndroid SDK版本，注意这里需要选择兼容的最低版本。单击“New...”之后，我们依次进行选择：   \n\n![填写必要的信息](https://img-blog.csdn.net/20141106192718692?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n上图中，最后一项是运行选项，我们保持默认（运行时选择要运行该应用的设备）。   \n完成后需要一段时间的等待，然后我们就可以顺利进入工作环境了。   \n\n![工作区](https://img-blog.csdn.net/20141106193148781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n我们可以发现，界面整体感觉还是很清晰、简洁的。   \n要运行HelloWorld，需要Shift+F10即可。    \n此外，对于Android的布局，有了实时预览功能：   \n\n![实时预览](https://img-blog.csdn.net/20141106193436984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)   \n\n这一点在Eclipse上面是不太好实现的，起码我没有找到这个功能，而这一功能可以说是广大Android开发者的福音。   \n不仅如此，对于不建议使用的控件，在设计视图中也有明确的提示：    \n\n![废弃的控件提示](https://img-blog.csdn.net/20141106193535350?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)   \n\n另外，诸位如果使用过最新版本的Eclipse Luna的话，可以发现有全黑主题了，但个人感觉Idea的全黑主题更好一些。这个大家可以从File->Settings->Appearance % Behavior->Appearance中选择Theme为Darcula。另外，还支持全屏显示（View->Enter Full Screen），这样一来，全屏都会是暗色系。   \n\n![Darcula主题的IDEA](https://img-blog.csdn.net/20141106194006140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n以上给广大开发者，尤其是Android开发者一个IDE的介绍，上手不难。用久了Eclipse后，换一个风格迥异的IDE也是一个不错的选择。最后希望上述内容能够提供一些比较实用的参考价值。","source":"_posts/IntelliJ IDEA 14 值得你弃用Eclipse的IDE神器.md","raw":"---\ntitle: IntelliJ IDEA 14 值得你弃用Eclipse的IDE神器\ndate: 2014-11-06 19:42:33\ntags: Java\ncategories: 编程世界\n---\n\n今天看新闻，发现IntelliJ IDEA版本出了14，本着生命在于折腾的原则，下载并安装。   \n当然，是开玩笑的啦！作为比较资深的Android开发者，相信朋友们不会不知道Android Studio这个软件。它就是基于IntelliJ IDEA（以下简称IDEA），所以借着新版本的发布，看看最原始的IDEA是个什么模样。   \n注：大家一定要有信心，这款IDE我上手的时间仅仅用了2个小时不到，个人感觉还是比较适合我的。如果花上两个小时能够提高日后的编码效率，还是很值得的。   \nIDEA分为两大版本，Ultimate（付费）和Community（免费）。大家可以搜索一下，他们的差距还是相当大的，主要区别在于对Web开发的支持。虽然我只是在Android平台上面开发，但是谁又说得准会不会写个JSP之类的，万一要写了呢？所以我使用了功能比较全面的Ultimate（收费软件在我国情况……大家了解的，可以去下载相关工具）。   \n不出意外的话，首次运行会让用户选择使用的插件，默认是全开，一路下一步后显示下面的界面：   \n\n![IDEA 14启动界面](https://img-blog.csdn.net/20141106191706001?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n这里大家明确一下概念，往常在Eclipse中，有个“Workspace”的概念，我们会把很多项目放在一个工作空间中。到了idea中，完全不一样了。它的做法是，一个Project对应一个Module，一个Module对应我们的一个项目。但是不推荐一个Project包含多个Module，因为默认情况下输出目录之类的文件会放在一起，这也是官方不建议的。简而言之，就是一个Project对应一个项目，没有Workspace的概念。   \n下面我们创建android应用程序，在此之前要创建一个Project，类型为Android。   \n![新建项目](https://img-blog.csdn.net/20141106192220312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n大家注意看左边的类型，免费版会少很多，真的是很多。所以再次提醒一下，防患于未然，万一要用呢。   \n下一步后和Eclipse里面创建项目大体相当，不再多说。   \n\n![创建项目](https://img-blog.csdn.net/20141106192406968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n下一屏幕我们需要指定一下使用的JDK和SAndroid SDK版本，注意这里需要选择兼容的最低版本。单击“New...”之后，我们依次进行选择：   \n\n![填写必要的信息](https://img-blog.csdn.net/20141106192718692?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n上图中，最后一项是运行选项，我们保持默认（运行时选择要运行该应用的设备）。   \n完成后需要一段时间的等待，然后我们就可以顺利进入工作环境了。   \n\n![工作区](https://img-blog.csdn.net/20141106193148781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n我们可以发现，界面整体感觉还是很清晰、简洁的。   \n要运行HelloWorld，需要Shift+F10即可。    \n此外，对于Android的布局，有了实时预览功能：   \n\n![实时预览](https://img-blog.csdn.net/20141106193436984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)   \n\n这一点在Eclipse上面是不太好实现的，起码我没有找到这个功能，而这一功能可以说是广大Android开发者的福音。   \n不仅如此，对于不建议使用的控件，在设计视图中也有明确的提示：    \n\n![废弃的控件提示](https://img-blog.csdn.net/20141106193535350?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)   \n\n另外，诸位如果使用过最新版本的Eclipse Luna的话，可以发现有全黑主题了，但个人感觉Idea的全黑主题更好一些。这个大家可以从File->Settings->Appearance % Behavior->Appearance中选择Theme为Darcula。另外，还支持全屏显示（View->Enter Full Screen），这样一来，全屏都会是暗色系。   \n\n![Darcula主题的IDEA](https://img-blog.csdn.net/20141106194006140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n以上给广大开发者，尤其是Android开发者一个IDE的介绍，上手不难。用久了Eclipse后，换一个风格迥异的IDE也是一个不错的选择。最后希望上述内容能够提供一些比较实用的参考价值。","slug":"IntelliJ IDEA 14 值得你弃用Eclipse的IDE神器","published":1,"updated":"2019-07-31T04:10:51.748Z","_id":"cjyqq3tjp000sfkqdbzl33vh3","comments":1,"layout":"post","photos":[],"link":"","content":"<p>今天看新闻，发现IntelliJ IDEA版本出了14，本着生命在于折腾的原则，下载并安装。<br>当然，是开玩笑的啦！作为比较资深的Android开发者，相信朋友们不会不知道Android Studio这个软件。它就是基于IntelliJ IDEA（以下简称IDEA），所以借着新版本的发布，看看最原始的IDEA是个什么模样。<br>注：大家一定要有信心，这款IDE我上手的时间仅仅用了2个小时不到，个人感觉还是比较适合我的。如果花上两个小时能够提高日后的编码效率，还是很值得的。<br>IDEA分为两大版本，Ultimate（付费）和Community（免费）。大家可以搜索一下，他们的差距还是相当大的，主要区别在于对Web开发的支持。虽然我只是在Android平台上面开发，但是谁又说得准会不会写个JSP之类的，万一要写了呢？所以我使用了功能比较全面的Ultimate（收费软件在我国情况……大家了解的，可以去下载相关工具）。<br>不出意外的话，首次运行会让用户选择使用的插件，默认是全开，一路下一步后显示下面的界面：   </p>\n<p><img src=\"https://img-blog.csdn.net/20141106191706001?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"IDEA 14启动界面\"></p>\n<p>这里大家明确一下概念，往常在Eclipse中，有个“Workspace”的概念，我们会把很多项目放在一个工作空间中。到了idea中，完全不一样了。它的做法是，一个Project对应一个Module，一个Module对应我们的一个项目。但是不推荐一个Project包含多个Module，因为默认情况下输出目录之类的文件会放在一起，这也是官方不建议的。简而言之，就是一个Project对应一个项目，没有Workspace的概念。<br>下面我们创建android应用程序，在此之前要创建一个Project，类型为Android。<br><img src=\"https://img-blog.csdn.net/20141106192220312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"新建项目\"></p>\n<p>大家注意看左边的类型，免费版会少很多，真的是很多。所以再次提醒一下，防患于未然，万一要用呢。<br>下一步后和Eclipse里面创建项目大体相当，不再多说。   </p>\n<p><img src=\"https://img-blog.csdn.net/20141106192406968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"创建项目\"></p>\n<p>下一屏幕我们需要指定一下使用的JDK和SAndroid SDK版本，注意这里需要选择兼容的最低版本。单击“New…”之后，我们依次进行选择：   </p>\n<p><img src=\"https://img-blog.csdn.net/20141106192718692?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"填写必要的信息\"></p>\n<p>上图中，最后一项是运行选项，我们保持默认（运行时选择要运行该应用的设备）。<br>完成后需要一段时间的等待，然后我们就可以顺利进入工作环境了。   </p>\n<p><img src=\"https://img-blog.csdn.net/20141106193148781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"工作区\"></p>\n<p>我们可以发现，界面整体感觉还是很清晰、简洁的。<br>要运行HelloWorld，需要Shift+F10即可。<br>此外，对于Android的布局，有了实时预览功能：   </p>\n<p><img src=\"https://img-blog.csdn.net/20141106193436984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"实时预览\">   </p>\n<p>这一点在Eclipse上面是不太好实现的，起码我没有找到这个功能，而这一功能可以说是广大Android开发者的福音。<br>不仅如此，对于不建议使用的控件，在设计视图中也有明确的提示：    </p>\n<p><img src=\"https://img-blog.csdn.net/20141106193535350?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"废弃的控件提示\">   </p>\n<p>另外，诸位如果使用过最新版本的Eclipse Luna的话，可以发现有全黑主题了，但个人感觉Idea的全黑主题更好一些。这个大家可以从File-&gt;Settings-&gt;Appearance % Behavior-&gt;Appearance中选择Theme为Darcula。另外，还支持全屏显示（View-&gt;Enter Full Screen），这样一来，全屏都会是暗色系。   </p>\n<p><img src=\"https://img-blog.csdn.net/20141106194006140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"Darcula主题的IDEA\"></p>\n<p>以上给广大开发者，尤其是Android开发者一个IDE的介绍，上手不难。用久了Eclipse后，换一个风格迥异的IDE也是一个不错的选择。最后希望上述内容能够提供一些比较实用的参考价值。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天看新闻，发现IntelliJ IDEA版本出了14，本着生命在于折腾的原则，下载并安装。<br>当然，是开玩笑的啦！作为比较资深的Android开发者，相信朋友们不会不知道Android Studio这个软件。它就是基于IntelliJ IDEA（以下简称IDEA），所以借着新版本的发布，看看最原始的IDEA是个什么模样。<br>注：大家一定要有信心，这款IDE我上手的时间仅仅用了2个小时不到，个人感觉还是比较适合我的。如果花上两个小时能够提高日后的编码效率，还是很值得的。<br>IDEA分为两大版本，Ultimate（付费）和Community（免费）。大家可以搜索一下，他们的差距还是相当大的，主要区别在于对Web开发的支持。虽然我只是在Android平台上面开发，但是谁又说得准会不会写个JSP之类的，万一要写了呢？所以我使用了功能比较全面的Ultimate（收费软件在我国情况……大家了解的，可以去下载相关工具）。<br>不出意外的话，首次运行会让用户选择使用的插件，默认是全开，一路下一步后显示下面的界面：   </p>\n<p><img src=\"https://img-blog.csdn.net/20141106191706001?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"IDEA 14启动界面\"></p>\n<p>这里大家明确一下概念，往常在Eclipse中，有个“Workspace”的概念，我们会把很多项目放在一个工作空间中。到了idea中，完全不一样了。它的做法是，一个Project对应一个Module，一个Module对应我们的一个项目。但是不推荐一个Project包含多个Module，因为默认情况下输出目录之类的文件会放在一起，这也是官方不建议的。简而言之，就是一个Project对应一个项目，没有Workspace的概念。<br>下面我们创建android应用程序，在此之前要创建一个Project，类型为Android。<br><img src=\"https://img-blog.csdn.net/20141106192220312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"新建项目\"></p>\n<p>大家注意看左边的类型，免费版会少很多，真的是很多。所以再次提醒一下，防患于未然，万一要用呢。<br>下一步后和Eclipse里面创建项目大体相当，不再多说。   </p>\n<p><img src=\"https://img-blog.csdn.net/20141106192406968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"创建项目\"></p>\n<p>下一屏幕我们需要指定一下使用的JDK和SAndroid SDK版本，注意这里需要选择兼容的最低版本。单击“New…”之后，我们依次进行选择：   </p>\n<p><img src=\"https://img-blog.csdn.net/20141106192718692?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"填写必要的信息\"></p>\n<p>上图中，最后一项是运行选项，我们保持默认（运行时选择要运行该应用的设备）。<br>完成后需要一段时间的等待，然后我们就可以顺利进入工作环境了。   </p>\n<p><img src=\"https://img-blog.csdn.net/20141106193148781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"工作区\"></p>\n<p>我们可以发现，界面整体感觉还是很清晰、简洁的。<br>要运行HelloWorld，需要Shift+F10即可。<br>此外，对于Android的布局，有了实时预览功能：   </p>\n<p><img src=\"https://img-blog.csdn.net/20141106193436984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"实时预览\">   </p>\n<p>这一点在Eclipse上面是不太好实现的，起码我没有找到这个功能，而这一功能可以说是广大Android开发者的福音。<br>不仅如此，对于不建议使用的控件，在设计视图中也有明确的提示：    </p>\n<p><img src=\"https://img-blog.csdn.net/20141106193535350?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"废弃的控件提示\">   </p>\n<p>另外，诸位如果使用过最新版本的Eclipse Luna的话，可以发现有全黑主题了，但个人感觉Idea的全黑主题更好一些。这个大家可以从File-&gt;Settings-&gt;Appearance % Behavior-&gt;Appearance中选择Theme为Darcula。另外，还支持全屏显示（View-&gt;Enter Full Screen），这样一来，全屏都会是暗色系。   </p>\n<p><img src=\"https://img-blog.csdn.net/20141106194006140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"Darcula主题的IDEA\"></p>\n<p>以上给广大开发者，尤其是Android开发者一个IDE的介绍，上手不难。用久了Eclipse后，换一个风格迥异的IDE也是一个不错的选择。最后希望上述内容能够提供一些比较实用的参考价值。</p>\n"},{"title":"优化Activity启动速度的另类解法","date":"2018-07-29T04:48:45.000Z","_content":"今天来给大家分享一个性能优化的经验，主要在Activity启动方面。   \n众所周知，给用户即时的响应是增强移动设备用户体验的重要一环，而Activity在启动过程中，又会经历至少onCreate(), onStart(), onResume()这三个回调过程。而在这三个过程中，又会经历绘制界面、载入数据、恢复现场等等实际操作。这对于一个Activity的启动多少都是会产生影响的。  \n通常意义上讲，我们去优化Activity的启动速度都是在上述三个回调中下工夫，觉得只要上述操作优化得足够好，就可以有一个良好的体验。包括我们在百度上面去搜索提升Activity启动速度也是如此。  \n\n完整代码请见 [完整代码][1]   \n\n接下来我们来看这个问题的另一个方面。下面先看一个动画：   \n\n![SecondActivity](https://img-blog.csdnimg.cn/20190716105348545.gif)   \n  \n我们可以注意到，在点击了\"Launch SecondActivity\"后，界面卡住了几秒，才发生跳转。而SecondActivity本身什么都没有做，如下所示：   \n\n```\npublic class SecondActivity extends Activity {\n    \n    private final String TAG = getClass().getSimpleName();\n    \n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_second);\n        Log.d(TAG, \"onCreate end\");\n    }\n    \n    @Override\n    protected void onStart() {\n        super.onStart();\n        Log.d(TAG, \"onStart end\");\n    }\n    \n    @Override\n    protected void onResume() {\n        super.onResume();\n        Log.d(TAG, \"onResume end\");\n    }\n}\n```\n\n这是一个很极端的情况，在启动过程中的各个生命周期，都只做了输出Log的操作，但仍然发生了卡顿的情况。   \n我们看在启动它的Activity中，我们做了什么：   \n\n```\n@Override\nprotected void onPause() {\n    super.onPause();\n    sleep();\n}\n\n// Sleep 5000 ms in main thread.\nprivate void sleep() {\n    if (needSleep) {\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n在onPause()方法中，我们做了一个5000ms的主线程延迟，用来模拟大量的主线程操作，我们发现，一旦在onPause中工作量太大，也会导致接下来启动的Activity启动延迟。这也解释了为什么我们反复优化即将启动的Activity，却收效不大的原因。    \n而一旦onPause()方法中，不进行操作时，或者实际项目中操作不多时，接下来的Activity会启动得很快，参考下面的演示：    \n\n![Launch FirstActivity](https://img-blog.csdnimg.cn/20190716105423384.gif)\n\n希望通过上面的描述，能给各位读者提供另一个性能优化的方案。   \nDemo APK 和源码下载：   \nhttps://github.com/wh1990xiao2005/pfmStartActivity/releases/tag/1.0\n\n\n  [1]: https://github.com/wh1990xiao2005/pfmStartActivity","source":"_posts/优化Activity启动速度的另类解法.md","raw":"---\ntitle: 优化Activity启动速度的另类解法\ndate: 2018-07-29 12:48:45\ntags: Android\ncategories: 编程世界\n---\n今天来给大家分享一个性能优化的经验，主要在Activity启动方面。   \n众所周知，给用户即时的响应是增强移动设备用户体验的重要一环，而Activity在启动过程中，又会经历至少onCreate(), onStart(), onResume()这三个回调过程。而在这三个过程中，又会经历绘制界面、载入数据、恢复现场等等实际操作。这对于一个Activity的启动多少都是会产生影响的。  \n通常意义上讲，我们去优化Activity的启动速度都是在上述三个回调中下工夫，觉得只要上述操作优化得足够好，就可以有一个良好的体验。包括我们在百度上面去搜索提升Activity启动速度也是如此。  \n\n完整代码请见 [完整代码][1]   \n\n接下来我们来看这个问题的另一个方面。下面先看一个动画：   \n\n![SecondActivity](https://img-blog.csdnimg.cn/20190716105348545.gif)   \n  \n我们可以注意到，在点击了\"Launch SecondActivity\"后，界面卡住了几秒，才发生跳转。而SecondActivity本身什么都没有做，如下所示：   \n\n```\npublic class SecondActivity extends Activity {\n    \n    private final String TAG = getClass().getSimpleName();\n    \n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_second);\n        Log.d(TAG, \"onCreate end\");\n    }\n    \n    @Override\n    protected void onStart() {\n        super.onStart();\n        Log.d(TAG, \"onStart end\");\n    }\n    \n    @Override\n    protected void onResume() {\n        super.onResume();\n        Log.d(TAG, \"onResume end\");\n    }\n}\n```\n\n这是一个很极端的情况，在启动过程中的各个生命周期，都只做了输出Log的操作，但仍然发生了卡顿的情况。   \n我们看在启动它的Activity中，我们做了什么：   \n\n```\n@Override\nprotected void onPause() {\n    super.onPause();\n    sleep();\n}\n\n// Sleep 5000 ms in main thread.\nprivate void sleep() {\n    if (needSleep) {\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n在onPause()方法中，我们做了一个5000ms的主线程延迟，用来模拟大量的主线程操作，我们发现，一旦在onPause中工作量太大，也会导致接下来启动的Activity启动延迟。这也解释了为什么我们反复优化即将启动的Activity，却收效不大的原因。    \n而一旦onPause()方法中，不进行操作时，或者实际项目中操作不多时，接下来的Activity会启动得很快，参考下面的演示：    \n\n![Launch FirstActivity](https://img-blog.csdnimg.cn/20190716105423384.gif)\n\n希望通过上面的描述，能给各位读者提供另一个性能优化的方案。   \nDemo APK 和源码下载：   \nhttps://github.com/wh1990xiao2005/pfmStartActivity/releases/tag/1.0\n\n\n  [1]: https://github.com/wh1990xiao2005/pfmStartActivity","slug":"优化Activity启动速度的另类解法","published":1,"updated":"2019-07-31T04:11:08.465Z","_id":"cjyqq3tjq000ufkqdjetqu3bh","comments":1,"layout":"post","photos":[],"link":"","content":"<p>今天来给大家分享一个性能优化的经验，主要在Activity启动方面。<br>众所周知，给用户即时的响应是增强移动设备用户体验的重要一环，而Activity在启动过程中，又会经历至少onCreate(), onStart(), onResume()这三个回调过程。而在这三个过程中，又会经历绘制界面、载入数据、恢复现场等等实际操作。这对于一个Activity的启动多少都是会产生影响的。<br>通常意义上讲，我们去优化Activity的启动速度都是在上述三个回调中下工夫，觉得只要上述操作优化得足够好，就可以有一个良好的体验。包括我们在百度上面去搜索提升Activity启动速度也是如此。  </p>\n<p>完整代码请见 <a href=\"https://github.com/wh1990xiao2005/pfmStartActivity\" target=\"_blank\" rel=\"noopener\">完整代码</a>   </p>\n<p>接下来我们来看这个问题的另一个方面。下面先看一个动画：   </p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190716105348545.gif\" alt=\"SecondActivity\">   </p>\n<p>我们可以注意到，在点击了”Launch SecondActivity”后，界面卡住了几秒，才发生跳转。而SecondActivity本身什么都没有做，如下所示：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SecondActivity extends Activity &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    private final String TAG = getClass().getSimpleName();</span><br><span class=\"line\">    </span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        super.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_second);</span><br><span class=\"line\">        Log.d(TAG, &quot;onCreate end&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onStart() &#123;</span><br><span class=\"line\">        super.onStart();</span><br><span class=\"line\">        Log.d(TAG, &quot;onStart end&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onResume() &#123;</span><br><span class=\"line\">        super.onResume();</span><br><span class=\"line\">        Log.d(TAG, &quot;onResume end&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是一个很极端的情况，在启动过程中的各个生命周期，都只做了输出Log的操作，但仍然发生了卡顿的情况。<br>我们看在启动它的Activity中，我们做了什么：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onPause() &#123;</span><br><span class=\"line\">    super.onPause();</span><br><span class=\"line\">    sleep();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Sleep 5000 ms in main thread.</span><br><span class=\"line\">private void sleep() &#123;</span><br><span class=\"line\">    if (needSleep) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(5000);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在onPause()方法中，我们做了一个5000ms的主线程延迟，用来模拟大量的主线程操作，我们发现，一旦在onPause中工作量太大，也会导致接下来启动的Activity启动延迟。这也解释了为什么我们反复优化即将启动的Activity，却收效不大的原因。<br>而一旦onPause()方法中，不进行操作时，或者实际项目中操作不多时，接下来的Activity会启动得很快，参考下面的演示：    </p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190716105423384.gif\" alt=\"Launch FirstActivity\"></p>\n<p>希望通过上面的描述，能给各位读者提供另一个性能优化的方案。<br>Demo APK 和源码下载：<br><a href=\"https://github.com/wh1990xiao2005/pfmStartActivity/releases/tag/1.0\" target=\"_blank\" rel=\"noopener\">https://github.com/wh1990xiao2005/pfmStartActivity/releases/tag/1.0</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天来给大家分享一个性能优化的经验，主要在Activity启动方面。<br>众所周知，给用户即时的响应是增强移动设备用户体验的重要一环，而Activity在启动过程中，又会经历至少onCreate(), onStart(), onResume()这三个回调过程。而在这三个过程中，又会经历绘制界面、载入数据、恢复现场等等实际操作。这对于一个Activity的启动多少都是会产生影响的。<br>通常意义上讲，我们去优化Activity的启动速度都是在上述三个回调中下工夫，觉得只要上述操作优化得足够好，就可以有一个良好的体验。包括我们在百度上面去搜索提升Activity启动速度也是如此。  </p>\n<p>完整代码请见 <a href=\"https://github.com/wh1990xiao2005/pfmStartActivity\" target=\"_blank\" rel=\"noopener\">完整代码</a>   </p>\n<p>接下来我们来看这个问题的另一个方面。下面先看一个动画：   </p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190716105348545.gif\" alt=\"SecondActivity\">   </p>\n<p>我们可以注意到，在点击了”Launch SecondActivity”后，界面卡住了几秒，才发生跳转。而SecondActivity本身什么都没有做，如下所示：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SecondActivity extends Activity &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    private final String TAG = getClass().getSimpleName();</span><br><span class=\"line\">    </span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        super.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_second);</span><br><span class=\"line\">        Log.d(TAG, &quot;onCreate end&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onStart() &#123;</span><br><span class=\"line\">        super.onStart();</span><br><span class=\"line\">        Log.d(TAG, &quot;onStart end&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onResume() &#123;</span><br><span class=\"line\">        super.onResume();</span><br><span class=\"line\">        Log.d(TAG, &quot;onResume end&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是一个很极端的情况，在启动过程中的各个生命周期，都只做了输出Log的操作，但仍然发生了卡顿的情况。<br>我们看在启动它的Activity中，我们做了什么：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onPause() &#123;</span><br><span class=\"line\">    super.onPause();</span><br><span class=\"line\">    sleep();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Sleep 5000 ms in main thread.</span><br><span class=\"line\">private void sleep() &#123;</span><br><span class=\"line\">    if (needSleep) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(5000);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在onPause()方法中，我们做了一个5000ms的主线程延迟，用来模拟大量的主线程操作，我们发现，一旦在onPause中工作量太大，也会导致接下来启动的Activity启动延迟。这也解释了为什么我们反复优化即将启动的Activity，却收效不大的原因。<br>而一旦onPause()方法中，不进行操作时，或者实际项目中操作不多时，接下来的Activity会启动得很快，参考下面的演示：    </p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190716105423384.gif\" alt=\"Launch FirstActivity\"></p>\n<p>希望通过上面的描述，能给各位读者提供另一个性能优化的方案。<br>Demo APK 和源码下载：<br><a href=\"https://github.com/wh1990xiao2005/pfmStartActivity/releases/tag/1.0\" target=\"_blank\" rel=\"noopener\">https://github.com/wh1990xiao2005/pfmStartActivity/releases/tag/1.0</a></p>\n"},{"title":"博客园 开博寄语","date":"2019-01-29T13:42:00.000Z","_content":"\n**感谢我的父亲、母亲、妻子、同事和朋友们，是你们让我能够有精力全情投入到工作和学习中，感谢你们为我做过的一切事！**   \n依稀记得不到5年前在CSDN写下上面这第一篇文字时的场景和感受，那个时候的我在软件开发领域还是一个懵懵懂懂的新人。其实在浩瀚的知识和未来面前，我们始终都是“新人”。这5年期间，我经历了从软件开发工程师到测试工程师的转变。如果说这5年给我留下了什么，或是说让我学到了什么。从博客的内容上看，回顾了这5年来发表过的文章，真正放到今天仍旧有帮助的只有5篇。剩下的要么就是因为技术过时而失去作用，要么就是有更好的解决方案，又或者就是有错误。  \n为什么今天再次转移战场呢，是觉得博客园是个更加纯粹的地方，和CSDN相比，它更少广告，界面也更朴素，甚至有一点怀旧的感觉。但是也正因为如此，它也能给我一种更加专注的体验，让我更加专注于技术本身，而不是那些花里胡哨的界面风格。  \n在博客园写文章，对我而言是一个既新又旧的事情。“新”是因为全新的平台、全新的内容，“旧”是因为写作风格不会变、坚持的东西不会变。  \n之前在CSDN和简书上发文章，基本都会发那些网上搜不到的，或者是新出的技术，国内还没有翻译更新出来的内容。通过这些内容，成功获得了CSDN认证讲师和博客专家的成就。然而，在获得了这些之后，写作的动力就下降了，或者有时候觉得没什么可写的。有几次想把自己遇到的问题总结归纳一下分享出来，结果网上一搜，已经有人写过了，又由于我自己的那份坚持——坚决不重复别人的成果，最终也导致了没什么文章产出。  \n2018年对我而言是事业生活双丰收的一年，2017年10月换了工作，成功地从开发工程师转向测试岗位，成为三星通信研究院大家庭中的一员。在这一年的工作中，从未离开过代码。从过去的实现功能到如今的优化性能，在我眼里是一种提升。我始终抱有一个目标，就是利用技术的进步驱动生活的有利改变，同时，将其中公开化。除了这些，对于那些刚刚入门的“初学者”，总觉得自己有种使命感，就是要帮助他们快速提升技术水平。我想，这和我自幼的理想是分不开的。我曾经在独处的时光里写过这样一段话：  \n\n> “在编程这条不归路上，即使面对的是没有生命的机器，即使它能任由编程人员指挥做事情。但到头来，还是会让开发人员面临很多挑战。意想不到的崩溃和各种稀奇古怪的异常，会让开发人员忙得焦头烂额，甚至到最后仍然深陷泥潭。但正因为如此，编程可以锻炼人的耐性，培养人的耐心和细心的习惯。也正因为这样，才能让人踏实下来写一些东西。更是因为这样，我才能胜任这项工作。  \n说到“世俗”的一面，我的理想就是提高自己的知名度，让自己在这个世界上留下些许存在过的印记。它或许是一篇文章，或许是一段代码片，或许是一张照片，甚至只存在于某个人或某几个人的记忆中。这和我少年时期想要当一名老师的理想并不冲突。经过成长的洗礼，最初的梦想经过升华变作了某种执念和精神，又化作了条条通往理想之门的大路。我逐渐意识到，自己少年时期的梦想只是一种具象化的结果。在每一次静静的思索之后，在每一次深深的解剖自己之后，慢慢地，知道了自己真正想要的东西；逐渐地，找到了实现它们的途径。能够意识到这些并将其转化为行动，对我而言，已经是莫大的欣喜。”  \n\n在三星通信研究院工作，对我而言是一件幸福的事情。在这里工作强度不是一直都很大，有时间自我学习。我始终认为，在人生的现阶段，投资自己是最重要的，而不是每个月到底能挣几个钱，因为发财没办法靠打工。即使年薪30万，50万又能如何呢？不吃不喝，一年下来，也不能在一线城市买下一套房，也不能买下自己心爱的座驾。更何况，即使买的下来这些，也不能保证自己不去要更多的东西，那样的人生不是我想要的。或许那样真的可以让自己这一生过得很舒服，但是舒服过后依旧会归于尘土。但如果我们真的可以在人间留下来点什么，留在了某些人的记忆中，这意味着这些人将带着我们的精神，带着我们的经验活下去，甚至传承下去。在某种意义上讲，这将是一种永生。  \n写博客对我而言就是实现理想的一种方式，我希望通过文字和图片记录下我在编程路上踩过的各种“坑”和探过的各种路。这对于尚未遇到“坑”和打算走新路的朋友来说，多少都会有一些帮助。虽然到今天，我仍然没有当上老师，没能站上讲台，但只要能够起到帮助和引导的作用，做事情的形式还显得那么重要吗？  \n这里我要感谢我的父母，感谢他们多年来的栽培，正因为有他们才有了今天的我。也感谢他们能够放手让我独立地生活，去距离他们2000公里以外的城市生活。还要感谢我的妻子，生活上她照顾得无微不至，把家里打理得井井有条，让我心无旁骛地追寻理想。最后要感谢陪我走过这5年的同事们，在工作中我们互相合作，互相学习，让我学到了很多东西。另外，还要感谢耐心阅读完本文的你。  ","source":"_posts/博客园 开博寄语.md","raw":"---\ntitle: 博客园 开博寄语\ndate: 2019-01-29 21:42:00\ntags: 其他\ncategories: 聊聊人生\n---\n\n**感谢我的父亲、母亲、妻子、同事和朋友们，是你们让我能够有精力全情投入到工作和学习中，感谢你们为我做过的一切事！**   \n依稀记得不到5年前在CSDN写下上面这第一篇文字时的场景和感受，那个时候的我在软件开发领域还是一个懵懵懂懂的新人。其实在浩瀚的知识和未来面前，我们始终都是“新人”。这5年期间，我经历了从软件开发工程师到测试工程师的转变。如果说这5年给我留下了什么，或是说让我学到了什么。从博客的内容上看，回顾了这5年来发表过的文章，真正放到今天仍旧有帮助的只有5篇。剩下的要么就是因为技术过时而失去作用，要么就是有更好的解决方案，又或者就是有错误。  \n为什么今天再次转移战场呢，是觉得博客园是个更加纯粹的地方，和CSDN相比，它更少广告，界面也更朴素，甚至有一点怀旧的感觉。但是也正因为如此，它也能给我一种更加专注的体验，让我更加专注于技术本身，而不是那些花里胡哨的界面风格。  \n在博客园写文章，对我而言是一个既新又旧的事情。“新”是因为全新的平台、全新的内容，“旧”是因为写作风格不会变、坚持的东西不会变。  \n之前在CSDN和简书上发文章，基本都会发那些网上搜不到的，或者是新出的技术，国内还没有翻译更新出来的内容。通过这些内容，成功获得了CSDN认证讲师和博客专家的成就。然而，在获得了这些之后，写作的动力就下降了，或者有时候觉得没什么可写的。有几次想把自己遇到的问题总结归纳一下分享出来，结果网上一搜，已经有人写过了，又由于我自己的那份坚持——坚决不重复别人的成果，最终也导致了没什么文章产出。  \n2018年对我而言是事业生活双丰收的一年，2017年10月换了工作，成功地从开发工程师转向测试岗位，成为三星通信研究院大家庭中的一员。在这一年的工作中，从未离开过代码。从过去的实现功能到如今的优化性能，在我眼里是一种提升。我始终抱有一个目标，就是利用技术的进步驱动生活的有利改变，同时，将其中公开化。除了这些，对于那些刚刚入门的“初学者”，总觉得自己有种使命感，就是要帮助他们快速提升技术水平。我想，这和我自幼的理想是分不开的。我曾经在独处的时光里写过这样一段话：  \n\n> “在编程这条不归路上，即使面对的是没有生命的机器，即使它能任由编程人员指挥做事情。但到头来，还是会让开发人员面临很多挑战。意想不到的崩溃和各种稀奇古怪的异常，会让开发人员忙得焦头烂额，甚至到最后仍然深陷泥潭。但正因为如此，编程可以锻炼人的耐性，培养人的耐心和细心的习惯。也正因为这样，才能让人踏实下来写一些东西。更是因为这样，我才能胜任这项工作。  \n说到“世俗”的一面，我的理想就是提高自己的知名度，让自己在这个世界上留下些许存在过的印记。它或许是一篇文章，或许是一段代码片，或许是一张照片，甚至只存在于某个人或某几个人的记忆中。这和我少年时期想要当一名老师的理想并不冲突。经过成长的洗礼，最初的梦想经过升华变作了某种执念和精神，又化作了条条通往理想之门的大路。我逐渐意识到，自己少年时期的梦想只是一种具象化的结果。在每一次静静的思索之后，在每一次深深的解剖自己之后，慢慢地，知道了自己真正想要的东西；逐渐地，找到了实现它们的途径。能够意识到这些并将其转化为行动，对我而言，已经是莫大的欣喜。”  \n\n在三星通信研究院工作，对我而言是一件幸福的事情。在这里工作强度不是一直都很大，有时间自我学习。我始终认为，在人生的现阶段，投资自己是最重要的，而不是每个月到底能挣几个钱，因为发财没办法靠打工。即使年薪30万，50万又能如何呢？不吃不喝，一年下来，也不能在一线城市买下一套房，也不能买下自己心爱的座驾。更何况，即使买的下来这些，也不能保证自己不去要更多的东西，那样的人生不是我想要的。或许那样真的可以让自己这一生过得很舒服，但是舒服过后依旧会归于尘土。但如果我们真的可以在人间留下来点什么，留在了某些人的记忆中，这意味着这些人将带着我们的精神，带着我们的经验活下去，甚至传承下去。在某种意义上讲，这将是一种永生。  \n写博客对我而言就是实现理想的一种方式，我希望通过文字和图片记录下我在编程路上踩过的各种“坑”和探过的各种路。这对于尚未遇到“坑”和打算走新路的朋友来说，多少都会有一些帮助。虽然到今天，我仍然没有当上老师，没能站上讲台，但只要能够起到帮助和引导的作用，做事情的形式还显得那么重要吗？  \n这里我要感谢我的父母，感谢他们多年来的栽培，正因为有他们才有了今天的我。也感谢他们能够放手让我独立地生活，去距离他们2000公里以外的城市生活。还要感谢我的妻子，生活上她照顾得无微不至，把家里打理得井井有条，让我心无旁骛地追寻理想。最后要感谢陪我走过这5年的同事们，在工作中我们互相合作，互相学习，让我学到了很多东西。另外，还要感谢耐心阅读完本文的你。  ","slug":"博客园 开博寄语","published":1,"updated":"2019-07-31T04:11:16.743Z","_id":"cjyqq3tjs000xfkqdpmv0lk4v","comments":1,"layout":"post","photos":[],"link":"","content":"<p><strong>感谢我的父亲、母亲、妻子、同事和朋友们，是你们让我能够有精力全情投入到工作和学习中，感谢你们为我做过的一切事！</strong><br>依稀记得不到5年前在CSDN写下上面这第一篇文字时的场景和感受，那个时候的我在软件开发领域还是一个懵懵懂懂的新人。其实在浩瀚的知识和未来面前，我们始终都是“新人”。这5年期间，我经历了从软件开发工程师到测试工程师的转变。如果说这5年给我留下了什么，或是说让我学到了什么。从博客的内容上看，回顾了这5年来发表过的文章，真正放到今天仍旧有帮助的只有5篇。剩下的要么就是因为技术过时而失去作用，要么就是有更好的解决方案，又或者就是有错误。<br>为什么今天再次转移战场呢，是觉得博客园是个更加纯粹的地方，和CSDN相比，它更少广告，界面也更朴素，甚至有一点怀旧的感觉。但是也正因为如此，它也能给我一种更加专注的体验，让我更加专注于技术本身，而不是那些花里胡哨的界面风格。<br>在博客园写文章，对我而言是一个既新又旧的事情。“新”是因为全新的平台、全新的内容，“旧”是因为写作风格不会变、坚持的东西不会变。<br>之前在CSDN和简书上发文章，基本都会发那些网上搜不到的，或者是新出的技术，国内还没有翻译更新出来的内容。通过这些内容，成功获得了CSDN认证讲师和博客专家的成就。然而，在获得了这些之后，写作的动力就下降了，或者有时候觉得没什么可写的。有几次想把自己遇到的问题总结归纳一下分享出来，结果网上一搜，已经有人写过了，又由于我自己的那份坚持——坚决不重复别人的成果，最终也导致了没什么文章产出。<br>2018年对我而言是事业生活双丰收的一年，2017年10月换了工作，成功地从开发工程师转向测试岗位，成为三星通信研究院大家庭中的一员。在这一年的工作中，从未离开过代码。从过去的实现功能到如今的优化性能，在我眼里是一种提升。我始终抱有一个目标，就是利用技术的进步驱动生活的有利改变，同时，将其中公开化。除了这些，对于那些刚刚入门的“初学者”，总觉得自己有种使命感，就是要帮助他们快速提升技术水平。我想，这和我自幼的理想是分不开的。我曾经在独处的时光里写过这样一段话：  </p>\n<blockquote>\n<p>“在编程这条不归路上，即使面对的是没有生命的机器，即使它能任由编程人员指挥做事情。但到头来，还是会让开发人员面临很多挑战。意想不到的崩溃和各种稀奇古怪的异常，会让开发人员忙得焦头烂额，甚至到最后仍然深陷泥潭。但正因为如此，编程可以锻炼人的耐性，培养人的耐心和细心的习惯。也正因为这样，才能让人踏实下来写一些东西。更是因为这样，我才能胜任这项工作。<br>说到“世俗”的一面，我的理想就是提高自己的知名度，让自己在这个世界上留下些许存在过的印记。它或许是一篇文章，或许是一段代码片，或许是一张照片，甚至只存在于某个人或某几个人的记忆中。这和我少年时期想要当一名老师的理想并不冲突。经过成长的洗礼，最初的梦想经过升华变作了某种执念和精神，又化作了条条通往理想之门的大路。我逐渐意识到，自己少年时期的梦想只是一种具象化的结果。在每一次静静的思索之后，在每一次深深的解剖自己之后，慢慢地，知道了自己真正想要的东西；逐渐地，找到了实现它们的途径。能够意识到这些并将其转化为行动，对我而言，已经是莫大的欣喜。”  </p>\n</blockquote>\n<p>在三星通信研究院工作，对我而言是一件幸福的事情。在这里工作强度不是一直都很大，有时间自我学习。我始终认为，在人生的现阶段，投资自己是最重要的，而不是每个月到底能挣几个钱，因为发财没办法靠打工。即使年薪30万，50万又能如何呢？不吃不喝，一年下来，也不能在一线城市买下一套房，也不能买下自己心爱的座驾。更何况，即使买的下来这些，也不能保证自己不去要更多的东西，那样的人生不是我想要的。或许那样真的可以让自己这一生过得很舒服，但是舒服过后依旧会归于尘土。但如果我们真的可以在人间留下来点什么，留在了某些人的记忆中，这意味着这些人将带着我们的精神，带着我们的经验活下去，甚至传承下去。在某种意义上讲，这将是一种永生。<br>写博客对我而言就是实现理想的一种方式，我希望通过文字和图片记录下我在编程路上踩过的各种“坑”和探过的各种路。这对于尚未遇到“坑”和打算走新路的朋友来说，多少都会有一些帮助。虽然到今天，我仍然没有当上老师，没能站上讲台，但只要能够起到帮助和引导的作用，做事情的形式还显得那么重要吗？<br>这里我要感谢我的父母，感谢他们多年来的栽培，正因为有他们才有了今天的我。也感谢他们能够放手让我独立地生活，去距离他们2000公里以外的城市生活。还要感谢我的妻子，生活上她照顾得无微不至，把家里打理得井井有条，让我心无旁骛地追寻理想。最后要感谢陪我走过这5年的同事们，在工作中我们互相合作，互相学习，让我学到了很多东西。另外，还要感谢耐心阅读完本文的你。  </p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>感谢我的父亲、母亲、妻子、同事和朋友们，是你们让我能够有精力全情投入到工作和学习中，感谢你们为我做过的一切事！</strong><br>依稀记得不到5年前在CSDN写下上面这第一篇文字时的场景和感受，那个时候的我在软件开发领域还是一个懵懵懂懂的新人。其实在浩瀚的知识和未来面前，我们始终都是“新人”。这5年期间，我经历了从软件开发工程师到测试工程师的转变。如果说这5年给我留下了什么，或是说让我学到了什么。从博客的内容上看，回顾了这5年来发表过的文章，真正放到今天仍旧有帮助的只有5篇。剩下的要么就是因为技术过时而失去作用，要么就是有更好的解决方案，又或者就是有错误。<br>为什么今天再次转移战场呢，是觉得博客园是个更加纯粹的地方，和CSDN相比，它更少广告，界面也更朴素，甚至有一点怀旧的感觉。但是也正因为如此，它也能给我一种更加专注的体验，让我更加专注于技术本身，而不是那些花里胡哨的界面风格。<br>在博客园写文章，对我而言是一个既新又旧的事情。“新”是因为全新的平台、全新的内容，“旧”是因为写作风格不会变、坚持的东西不会变。<br>之前在CSDN和简书上发文章，基本都会发那些网上搜不到的，或者是新出的技术，国内还没有翻译更新出来的内容。通过这些内容，成功获得了CSDN认证讲师和博客专家的成就。然而，在获得了这些之后，写作的动力就下降了，或者有时候觉得没什么可写的。有几次想把自己遇到的问题总结归纳一下分享出来，结果网上一搜，已经有人写过了，又由于我自己的那份坚持——坚决不重复别人的成果，最终也导致了没什么文章产出。<br>2018年对我而言是事业生活双丰收的一年，2017年10月换了工作，成功地从开发工程师转向测试岗位，成为三星通信研究院大家庭中的一员。在这一年的工作中，从未离开过代码。从过去的实现功能到如今的优化性能，在我眼里是一种提升。我始终抱有一个目标，就是利用技术的进步驱动生活的有利改变，同时，将其中公开化。除了这些，对于那些刚刚入门的“初学者”，总觉得自己有种使命感，就是要帮助他们快速提升技术水平。我想，这和我自幼的理想是分不开的。我曾经在独处的时光里写过这样一段话：  </p>\n<blockquote>\n<p>“在编程这条不归路上，即使面对的是没有生命的机器，即使它能任由编程人员指挥做事情。但到头来，还是会让开发人员面临很多挑战。意想不到的崩溃和各种稀奇古怪的异常，会让开发人员忙得焦头烂额，甚至到最后仍然深陷泥潭。但正因为如此，编程可以锻炼人的耐性，培养人的耐心和细心的习惯。也正因为这样，才能让人踏实下来写一些东西。更是因为这样，我才能胜任这项工作。<br>说到“世俗”的一面，我的理想就是提高自己的知名度，让自己在这个世界上留下些许存在过的印记。它或许是一篇文章，或许是一段代码片，或许是一张照片，甚至只存在于某个人或某几个人的记忆中。这和我少年时期想要当一名老师的理想并不冲突。经过成长的洗礼，最初的梦想经过升华变作了某种执念和精神，又化作了条条通往理想之门的大路。我逐渐意识到，自己少年时期的梦想只是一种具象化的结果。在每一次静静的思索之后，在每一次深深的解剖自己之后，慢慢地，知道了自己真正想要的东西；逐渐地，找到了实现它们的途径。能够意识到这些并将其转化为行动，对我而言，已经是莫大的欣喜。”  </p>\n</blockquote>\n<p>在三星通信研究院工作，对我而言是一件幸福的事情。在这里工作强度不是一直都很大，有时间自我学习。我始终认为，在人生的现阶段，投资自己是最重要的，而不是每个月到底能挣几个钱，因为发财没办法靠打工。即使年薪30万，50万又能如何呢？不吃不喝，一年下来，也不能在一线城市买下一套房，也不能买下自己心爱的座驾。更何况，即使买的下来这些，也不能保证自己不去要更多的东西，那样的人生不是我想要的。或许那样真的可以让自己这一生过得很舒服，但是舒服过后依旧会归于尘土。但如果我们真的可以在人间留下来点什么，留在了某些人的记忆中，这意味着这些人将带着我们的精神，带着我们的经验活下去，甚至传承下去。在某种意义上讲，这将是一种永生。<br>写博客对我而言就是实现理想的一种方式，我希望通过文字和图片记录下我在编程路上踩过的各种“坑”和探过的各种路。这对于尚未遇到“坑”和打算走新路的朋友来说，多少都会有一些帮助。虽然到今天，我仍然没有当上老师，没能站上讲台，但只要能够起到帮助和引导的作用，做事情的形式还显得那么重要吗？<br>这里我要感谢我的父母，感谢他们多年来的栽培，正因为有他们才有了今天的我。也感谢他们能够放手让我独立地生活，去距离他们2000公里以外的城市生活。还要感谢我的妻子，生活上她照顾得无微不至，把家里打理得井井有条，让我心无旁骛地追寻理想。最后要感谢陪我走过这5年的同事们，在工作中我们互相合作，互相学习，让我学到了很多东西。另外，还要感谢耐心阅读完本文的你。  </p>\n"},{"title":"取之有道——巧用Root权限 启动其他APP中的Activity","date":"2016-06-16T06:05:41.000Z","_content":"\n这次博主来分享一个很巧妙的办法来启动其他APP中Activity的方法。   \n首先说一下这样做的目的：最近博主在攻克一个技术难点，就是搞定某些三方系统中，对于应用权限的限制。为此给出用户指导，引导用户启动系统中的权限设置来设置信任。到此，问题就来了：我们不知道权限设定的包名，也不知道权限设置的Activity的名字，如何启动到指定的界面呢？   \n今天我们就来解决这个问题。   \n首先，我们需要一台已经获取Root权限了的手机。当然，模拟器之流也是可以考虑的。还有RE（Root Explorer）文件浏览器，用来浏览AndroidManifest.xml。这里注意的是，不要试图复制到电脑上查看，会是乱码的。   \n然后，我们开始通过包名来查找有可能的程序。由于博主手里用的测试机是华为的机器，因此以华为为例。其他厂商的手机请各位自行查找，方法应该是一致的。   \n使用RE文件浏览器，获取读写权限，依次打开/system/app。在这里，你将会看到好多APK。由于RE文件浏览器能够预览APK的图标，所以我们可以很轻松地通过软件图标，找到权限管理所属的APK文件。以华为最新的EMUI为例，权限管理所属的软件是手机管家，APK的文件名为：“HwSystemManager.apk”。   \n使用RE文件浏览器打开APK，选择查看，即可看到解压后的文件。也就可以直接找到AndroidManifest.xml。继续使用RE文件浏览器打开这个xml文件，其中的Activity的名字便一览无遗了。   \n最后，找到正确的Activity，启动它即可。   \n这样，就能够在用户指导的权限设置页给出正确的启动入口了。当然，此方法也适用于启动任何一个APP中的Activity，只要配置文件中的exported值不为false即可启动。   \n小小技巧，班门弄斧。不足之处，望路过大神多多指教。   ","source":"_posts/取之有道——巧用Root权限 启动其他APP中的Activity.md","raw":"---\ntitle: 取之有道——巧用Root权限 启动其他APP中的Activity\ndate: 2016-06-16 14:05:41\ntags: Android\ncategories: 编程世界\n---\n\n这次博主来分享一个很巧妙的办法来启动其他APP中Activity的方法。   \n首先说一下这样做的目的：最近博主在攻克一个技术难点，就是搞定某些三方系统中，对于应用权限的限制。为此给出用户指导，引导用户启动系统中的权限设置来设置信任。到此，问题就来了：我们不知道权限设定的包名，也不知道权限设置的Activity的名字，如何启动到指定的界面呢？   \n今天我们就来解决这个问题。   \n首先，我们需要一台已经获取Root权限了的手机。当然，模拟器之流也是可以考虑的。还有RE（Root Explorer）文件浏览器，用来浏览AndroidManifest.xml。这里注意的是，不要试图复制到电脑上查看，会是乱码的。   \n然后，我们开始通过包名来查找有可能的程序。由于博主手里用的测试机是华为的机器，因此以华为为例。其他厂商的手机请各位自行查找，方法应该是一致的。   \n使用RE文件浏览器，获取读写权限，依次打开/system/app。在这里，你将会看到好多APK。由于RE文件浏览器能够预览APK的图标，所以我们可以很轻松地通过软件图标，找到权限管理所属的APK文件。以华为最新的EMUI为例，权限管理所属的软件是手机管家，APK的文件名为：“HwSystemManager.apk”。   \n使用RE文件浏览器打开APK，选择查看，即可看到解压后的文件。也就可以直接找到AndroidManifest.xml。继续使用RE文件浏览器打开这个xml文件，其中的Activity的名字便一览无遗了。   \n最后，找到正确的Activity，启动它即可。   \n这样，就能够在用户指导的权限设置页给出正确的启动入口了。当然，此方法也适用于启动任何一个APP中的Activity，只要配置文件中的exported值不为false即可启动。   \n小小技巧，班门弄斧。不足之处，望路过大神多多指教。   ","slug":"取之有道——巧用Root权限 启动其他APP中的Activity","published":1,"updated":"2019-07-31T04:11:20.432Z","_id":"cjyqq3tjt000zfkqd6yxf9mp2","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这次博主来分享一个很巧妙的办法来启动其他APP中Activity的方法。<br>首先说一下这样做的目的：最近博主在攻克一个技术难点，就是搞定某些三方系统中，对于应用权限的限制。为此给出用户指导，引导用户启动系统中的权限设置来设置信任。到此，问题就来了：我们不知道权限设定的包名，也不知道权限设置的Activity的名字，如何启动到指定的界面呢？<br>今天我们就来解决这个问题。<br>首先，我们需要一台已经获取Root权限了的手机。当然，模拟器之流也是可以考虑的。还有RE（Root Explorer）文件浏览器，用来浏览AndroidManifest.xml。这里注意的是，不要试图复制到电脑上查看，会是乱码的。<br>然后，我们开始通过包名来查找有可能的程序。由于博主手里用的测试机是华为的机器，因此以华为为例。其他厂商的手机请各位自行查找，方法应该是一致的。<br>使用RE文件浏览器，获取读写权限，依次打开/system/app。在这里，你将会看到好多APK。由于RE文件浏览器能够预览APK的图标，所以我们可以很轻松地通过软件图标，找到权限管理所属的APK文件。以华为最新的EMUI为例，权限管理所属的软件是手机管家，APK的文件名为：“HwSystemManager.apk”。<br>使用RE文件浏览器打开APK，选择查看，即可看到解压后的文件。也就可以直接找到AndroidManifest.xml。继续使用RE文件浏览器打开这个xml文件，其中的Activity的名字便一览无遗了。<br>最后，找到正确的Activity，启动它即可。<br>这样，就能够在用户指导的权限设置页给出正确的启动入口了。当然，此方法也适用于启动任何一个APP中的Activity，只要配置文件中的exported值不为false即可启动。<br>小小技巧，班门弄斧。不足之处，望路过大神多多指教。   </p>\n","site":{"data":{}},"excerpt":"","more":"<p>这次博主来分享一个很巧妙的办法来启动其他APP中Activity的方法。<br>首先说一下这样做的目的：最近博主在攻克一个技术难点，就是搞定某些三方系统中，对于应用权限的限制。为此给出用户指导，引导用户启动系统中的权限设置来设置信任。到此，问题就来了：我们不知道权限设定的包名，也不知道权限设置的Activity的名字，如何启动到指定的界面呢？<br>今天我们就来解决这个问题。<br>首先，我们需要一台已经获取Root权限了的手机。当然，模拟器之流也是可以考虑的。还有RE（Root Explorer）文件浏览器，用来浏览AndroidManifest.xml。这里注意的是，不要试图复制到电脑上查看，会是乱码的。<br>然后，我们开始通过包名来查找有可能的程序。由于博主手里用的测试机是华为的机器，因此以华为为例。其他厂商的手机请各位自行查找，方法应该是一致的。<br>使用RE文件浏览器，获取读写权限，依次打开/system/app。在这里，你将会看到好多APK。由于RE文件浏览器能够预览APK的图标，所以我们可以很轻松地通过软件图标，找到权限管理所属的APK文件。以华为最新的EMUI为例，权限管理所属的软件是手机管家，APK的文件名为：“HwSystemManager.apk”。<br>使用RE文件浏览器打开APK，选择查看，即可看到解压后的文件。也就可以直接找到AndroidManifest.xml。继续使用RE文件浏览器打开这个xml文件，其中的Activity的名字便一览无遗了。<br>最后，找到正确的Activity，启动它即可。<br>这样，就能够在用户指导的权限设置页给出正确的启动入口了。当然，此方法也适用于启动任何一个APP中的Activity，只要配置文件中的exported值不为false即可启动。<br>小小技巧，班门弄斧。不足之处，望路过大神多多指教。   </p>\n"},{"title":"巧用Handler获取View控件信息","date":"2019-01-14T15:12:09.000Z","_content":"\n众所周知，在Android实际开发中，对于某些复杂多变的情况，控件的位置摆放、大小控制并非是xml类型的layout文件完全可以搞定的。此时，我们通常会使用Java代码来通过动态计算，将指定的控件摆放在相应的位置，并限定其大小。同样地，也需要获取某个控件的大小。\n对于获取控件宽、高的方法，大家可以自行谷歌或者百度，大抵无非一下三种方法：\n\n 1. 给相应的View控件**添加ViewTreeObserver回调**；\n 2. **Override onWindowFocusChange方法**；\n 3. 在需要测量时（而不是onCreate或onResume中），**使用MeasureSpec内部类**获取宽高。\n\n对于上述第三种情况，我们暂且不论。对于前二者而言，有没有更简单的实现呢？\n\n## 为何获取宽高要如此？\n对于初学者，可能会有这样的疑问：为什么我们不能在onCreate()或者onResume()中直接使用上述第三种方案获取宽高呢？\n结论是：那样的话，获取来的值很可能皆为0，即使实际的宽高不是0。那么这是为何呢？\n这其实是由Android的UI绘制流程决定的。大家不妨试着做一下实验，即使是在onResume()方法后，它的意义也仅仅是指Activity进入了可见的**状态**，这**并不意味着界面绘制的结束**。我们可以用一个简单的带有宽高值得View来做实验，观察Activity中各回调方法的调用顺序，得到的结果将是这样的：\n\n> Activity.oncreate() → Activity.onResume() → View.onMeasure() → View.onLayout() → onGlobalLayoutListener() → Activity.onWidnowFocusChanged() → ... → View.onDraw() -> ...\n\n因此，如果我们在onResume()中尝试获取View宽高的话，很大概率是会失败的。\n\n## 巧用Handler获取View控件信息\n这里我们开门见山地先放上代码片：\n\n```\nprivate int[] measureView(final View view) {\n    final int[] returnData = new int[2];\n    view.post(new Runnable() {\n        @Override\n        public void run() {\n            returnData[0] = view.getWidth();\n            returnData[1] = view.getHeight();\n            Log.i(TAG, \"Width: \" + returnData[0] + \", height: \" + returnData[1]);\n        }\n    });\n    return returnData;\n}\n```\n上述代码作为通用的方法将获取任意View的宽高做了封装，其妙处就在‘view.post’处。\n将其置于onCreate()、onResume()方法中调用，均可获取到正确的宽高。\n\n```\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    Log.i(TAG, \"onCreate start!\");\n    setContentView(R.layout.activity_main);\n    testTv = (TextView) findViewById(R.id.testTv);\n    measureView(testTv);\n}\n\n@Override\nprotected void onResume() {\n    super.onResume();\n    Log.i(TAG, \"onResume start!\");\n    measureView(testTv);\n}\n```\n\nLogcat中的运行结果：\n\n> 2019-01-14 22:33:13.874 18355-18355/com.example.wenhan.helloandroid I/MainActivity: Width: 225, height: 57\n2019-01-14 22:33:13.874 18355-18355/com.example.wenhan.helloandroid I/MainActivity: Width: 225, height: 57\n\n## 为何如此就可获取到正确的值了呢？\n其中的玄机在于，我们在View.post()中所写的语句并没有立即执行，而在其真正执行的时候，View的宽高已经被测量完成了，那时我们再去获取宽高时，就会很容易地获取到正确的值了。\n通过断点Debug，可以轻松地发现，在Activity启动过程的调用栈中，存在ActivityThread类被执行了，具体按照：\n\n> main() -> handleResumeActivity() -> addView() -> setView() -> requestLayout() -> scheduleTraversals() -> 执行mTraversalRunnable异步线程 -> doTraversal() -> performTraversals() -> ... -> performMeasure() ->  ...\n\n的执行顺序。\n在我们获取宽高的语句执行前，主线程的Handler正在执行TraversalRunnable（见上述方法具体实现），而performMeasure也被包含其中。又因为我们获取宽高的语句要排队，处于等待状态，直到主线程Handler轮到执行我们的语句，而此时View的宽高的测量已经结束。\n\n完整示例代码：https://github.com/wh1990xiao2005/FetchViewSizeDemo\n","source":"_posts/巧用Handler获取View控件信息.md","raw":"---\ntitle: 巧用Handler获取View控件信息\ndate: 2019-01-14 23:12:09\ntags: Android\ncategories: 编程世界\n---\n\n众所周知，在Android实际开发中，对于某些复杂多变的情况，控件的位置摆放、大小控制并非是xml类型的layout文件完全可以搞定的。此时，我们通常会使用Java代码来通过动态计算，将指定的控件摆放在相应的位置，并限定其大小。同样地，也需要获取某个控件的大小。\n对于获取控件宽、高的方法，大家可以自行谷歌或者百度，大抵无非一下三种方法：\n\n 1. 给相应的View控件**添加ViewTreeObserver回调**；\n 2. **Override onWindowFocusChange方法**；\n 3. 在需要测量时（而不是onCreate或onResume中），**使用MeasureSpec内部类**获取宽高。\n\n对于上述第三种情况，我们暂且不论。对于前二者而言，有没有更简单的实现呢？\n\n## 为何获取宽高要如此？\n对于初学者，可能会有这样的疑问：为什么我们不能在onCreate()或者onResume()中直接使用上述第三种方案获取宽高呢？\n结论是：那样的话，获取来的值很可能皆为0，即使实际的宽高不是0。那么这是为何呢？\n这其实是由Android的UI绘制流程决定的。大家不妨试着做一下实验，即使是在onResume()方法后，它的意义也仅仅是指Activity进入了可见的**状态**，这**并不意味着界面绘制的结束**。我们可以用一个简单的带有宽高值得View来做实验，观察Activity中各回调方法的调用顺序，得到的结果将是这样的：\n\n> Activity.oncreate() → Activity.onResume() → View.onMeasure() → View.onLayout() → onGlobalLayoutListener() → Activity.onWidnowFocusChanged() → ... → View.onDraw() -> ...\n\n因此，如果我们在onResume()中尝试获取View宽高的话，很大概率是会失败的。\n\n## 巧用Handler获取View控件信息\n这里我们开门见山地先放上代码片：\n\n```\nprivate int[] measureView(final View view) {\n    final int[] returnData = new int[2];\n    view.post(new Runnable() {\n        @Override\n        public void run() {\n            returnData[0] = view.getWidth();\n            returnData[1] = view.getHeight();\n            Log.i(TAG, \"Width: \" + returnData[0] + \", height: \" + returnData[1]);\n        }\n    });\n    return returnData;\n}\n```\n上述代码作为通用的方法将获取任意View的宽高做了封装，其妙处就在‘view.post’处。\n将其置于onCreate()、onResume()方法中调用，均可获取到正确的宽高。\n\n```\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    Log.i(TAG, \"onCreate start!\");\n    setContentView(R.layout.activity_main);\n    testTv = (TextView) findViewById(R.id.testTv);\n    measureView(testTv);\n}\n\n@Override\nprotected void onResume() {\n    super.onResume();\n    Log.i(TAG, \"onResume start!\");\n    measureView(testTv);\n}\n```\n\nLogcat中的运行结果：\n\n> 2019-01-14 22:33:13.874 18355-18355/com.example.wenhan.helloandroid I/MainActivity: Width: 225, height: 57\n2019-01-14 22:33:13.874 18355-18355/com.example.wenhan.helloandroid I/MainActivity: Width: 225, height: 57\n\n## 为何如此就可获取到正确的值了呢？\n其中的玄机在于，我们在View.post()中所写的语句并没有立即执行，而在其真正执行的时候，View的宽高已经被测量完成了，那时我们再去获取宽高时，就会很容易地获取到正确的值了。\n通过断点Debug，可以轻松地发现，在Activity启动过程的调用栈中，存在ActivityThread类被执行了，具体按照：\n\n> main() -> handleResumeActivity() -> addView() -> setView() -> requestLayout() -> scheduleTraversals() -> 执行mTraversalRunnable异步线程 -> doTraversal() -> performTraversals() -> ... -> performMeasure() ->  ...\n\n的执行顺序。\n在我们获取宽高的语句执行前，主线程的Handler正在执行TraversalRunnable（见上述方法具体实现），而performMeasure也被包含其中。又因为我们获取宽高的语句要排队，处于等待状态，直到主线程Handler轮到执行我们的语句，而此时View的宽高的测量已经结束。\n\n完整示例代码：https://github.com/wh1990xiao2005/FetchViewSizeDemo\n","slug":"巧用Handler获取View控件信息","published":1,"updated":"2019-07-31T04:11:23.417Z","_id":"cjyqq3tjv0011fkqd9moohwge","comments":1,"layout":"post","photos":[],"link":"","content":"<p>众所周知，在Android实际开发中，对于某些复杂多变的情况，控件的位置摆放、大小控制并非是xml类型的layout文件完全可以搞定的。此时，我们通常会使用Java代码来通过动态计算，将指定的控件摆放在相应的位置，并限定其大小。同样地，也需要获取某个控件的大小。<br>对于获取控件宽、高的方法，大家可以自行谷歌或者百度，大抵无非一下三种方法：</p>\n<ol>\n<li>给相应的View控件<strong>添加ViewTreeObserver回调</strong>；</li>\n<li><strong>Override onWindowFocusChange方法</strong>；</li>\n<li>在需要测量时（而不是onCreate或onResume中），<strong>使用MeasureSpec内部类</strong>获取宽高。</li>\n</ol>\n<p>对于上述第三种情况，我们暂且不论。对于前二者而言，有没有更简单的实现呢？</p>\n<h2 id=\"为何获取宽高要如此？\"><a href=\"#为何获取宽高要如此？\" class=\"headerlink\" title=\"为何获取宽高要如此？\"></a>为何获取宽高要如此？</h2><p>对于初学者，可能会有这样的疑问：为什么我们不能在onCreate()或者onResume()中直接使用上述第三种方案获取宽高呢？<br>结论是：那样的话，获取来的值很可能皆为0，即使实际的宽高不是0。那么这是为何呢？<br>这其实是由Android的UI绘制流程决定的。大家不妨试着做一下实验，即使是在onResume()方法后，它的意义也仅仅是指Activity进入了可见的<strong>状态</strong>，这<strong>并不意味着界面绘制的结束</strong>。我们可以用一个简单的带有宽高值得View来做实验，观察Activity中各回调方法的调用顺序，得到的结果将是这样的：</p>\n<blockquote>\n<p>Activity.oncreate() → Activity.onResume() → View.onMeasure() → View.onLayout() → onGlobalLayoutListener() → Activity.onWidnowFocusChanged() → … → View.onDraw() -&gt; …</p>\n</blockquote>\n<p>因此，如果我们在onResume()中尝试获取View宽高的话，很大概率是会失败的。</p>\n<h2 id=\"巧用Handler获取View控件信息\"><a href=\"#巧用Handler获取View控件信息\" class=\"headerlink\" title=\"巧用Handler获取View控件信息\"></a>巧用Handler获取View控件信息</h2><p>这里我们开门见山地先放上代码片：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int[] measureView(final View view) &#123;</span><br><span class=\"line\">    final int[] returnData = new int[2];</span><br><span class=\"line\">    view.post(new Runnable() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            returnData[0] = view.getWidth();</span><br><span class=\"line\">            returnData[1] = view.getHeight();</span><br><span class=\"line\">            Log.i(TAG, &quot;Width: &quot; + returnData[0] + &quot;, height: &quot; + returnData[1]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return returnData;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码作为通用的方法将获取任意View的宽高做了封装，其妙处就在‘view.post’处。<br>将其置于onCreate()、onResume()方法中调用，均可获取到正确的宽高。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">    super.onCreate(savedInstanceState);</span><br><span class=\"line\">    Log.i(TAG, &quot;onCreate start!&quot;);</span><br><span class=\"line\">    setContentView(R.layout.activity_main);</span><br><span class=\"line\">    testTv = (TextView) findViewById(R.id.testTv);</span><br><span class=\"line\">    measureView(testTv);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onResume() &#123;</span><br><span class=\"line\">    super.onResume();</span><br><span class=\"line\">    Log.i(TAG, &quot;onResume start!&quot;);</span><br><span class=\"line\">    measureView(testTv);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Logcat中的运行结果：</p>\n<blockquote>\n<p>2019-01-14 22:33:13.874 18355-18355/com.example.wenhan.helloandroid I/MainActivity: Width: 225, height: 57<br>2019-01-14 22:33:13.874 18355-18355/com.example.wenhan.helloandroid I/MainActivity: Width: 225, height: 57</p>\n</blockquote>\n<h2 id=\"为何如此就可获取到正确的值了呢？\"><a href=\"#为何如此就可获取到正确的值了呢？\" class=\"headerlink\" title=\"为何如此就可获取到正确的值了呢？\"></a>为何如此就可获取到正确的值了呢？</h2><p>其中的玄机在于，我们在View.post()中所写的语句并没有立即执行，而在其真正执行的时候，View的宽高已经被测量完成了，那时我们再去获取宽高时，就会很容易地获取到正确的值了。<br>通过断点Debug，可以轻松地发现，在Activity启动过程的调用栈中，存在ActivityThread类被执行了，具体按照：</p>\n<blockquote>\n<p>main() -&gt; handleResumeActivity() -&gt; addView() -&gt; setView() -&gt; requestLayout() -&gt; scheduleTraversals() -&gt; 执行mTraversalRunnable异步线程 -&gt; doTraversal() -&gt; performTraversals() -&gt; … -&gt; performMeasure() -&gt;  …</p>\n</blockquote>\n<p>的执行顺序。<br>在我们获取宽高的语句执行前，主线程的Handler正在执行TraversalRunnable（见上述方法具体实现），而performMeasure也被包含其中。又因为我们获取宽高的语句要排队，处于等待状态，直到主线程Handler轮到执行我们的语句，而此时View的宽高的测量已经结束。</p>\n<p>完整示例代码：<a href=\"https://github.com/wh1990xiao2005/FetchViewSizeDemo\" target=\"_blank\" rel=\"noopener\">https://github.com/wh1990xiao2005/FetchViewSizeDemo</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>众所周知，在Android实际开发中，对于某些复杂多变的情况，控件的位置摆放、大小控制并非是xml类型的layout文件完全可以搞定的。此时，我们通常会使用Java代码来通过动态计算，将指定的控件摆放在相应的位置，并限定其大小。同样地，也需要获取某个控件的大小。<br>对于获取控件宽、高的方法，大家可以自行谷歌或者百度，大抵无非一下三种方法：</p>\n<ol>\n<li>给相应的View控件<strong>添加ViewTreeObserver回调</strong>；</li>\n<li><strong>Override onWindowFocusChange方法</strong>；</li>\n<li>在需要测量时（而不是onCreate或onResume中），<strong>使用MeasureSpec内部类</strong>获取宽高。</li>\n</ol>\n<p>对于上述第三种情况，我们暂且不论。对于前二者而言，有没有更简单的实现呢？</p>\n<h2 id=\"为何获取宽高要如此？\"><a href=\"#为何获取宽高要如此？\" class=\"headerlink\" title=\"为何获取宽高要如此？\"></a>为何获取宽高要如此？</h2><p>对于初学者，可能会有这样的疑问：为什么我们不能在onCreate()或者onResume()中直接使用上述第三种方案获取宽高呢？<br>结论是：那样的话，获取来的值很可能皆为0，即使实际的宽高不是0。那么这是为何呢？<br>这其实是由Android的UI绘制流程决定的。大家不妨试着做一下实验，即使是在onResume()方法后，它的意义也仅仅是指Activity进入了可见的<strong>状态</strong>，这<strong>并不意味着界面绘制的结束</strong>。我们可以用一个简单的带有宽高值得View来做实验，观察Activity中各回调方法的调用顺序，得到的结果将是这样的：</p>\n<blockquote>\n<p>Activity.oncreate() → Activity.onResume() → View.onMeasure() → View.onLayout() → onGlobalLayoutListener() → Activity.onWidnowFocusChanged() → … → View.onDraw() -&gt; …</p>\n</blockquote>\n<p>因此，如果我们在onResume()中尝试获取View宽高的话，很大概率是会失败的。</p>\n<h2 id=\"巧用Handler获取View控件信息\"><a href=\"#巧用Handler获取View控件信息\" class=\"headerlink\" title=\"巧用Handler获取View控件信息\"></a>巧用Handler获取View控件信息</h2><p>这里我们开门见山地先放上代码片：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int[] measureView(final View view) &#123;</span><br><span class=\"line\">    final int[] returnData = new int[2];</span><br><span class=\"line\">    view.post(new Runnable() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            returnData[0] = view.getWidth();</span><br><span class=\"line\">            returnData[1] = view.getHeight();</span><br><span class=\"line\">            Log.i(TAG, &quot;Width: &quot; + returnData[0] + &quot;, height: &quot; + returnData[1]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return returnData;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码作为通用的方法将获取任意View的宽高做了封装，其妙处就在‘view.post’处。<br>将其置于onCreate()、onResume()方法中调用，均可获取到正确的宽高。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">    super.onCreate(savedInstanceState);</span><br><span class=\"line\">    Log.i(TAG, &quot;onCreate start!&quot;);</span><br><span class=\"line\">    setContentView(R.layout.activity_main);</span><br><span class=\"line\">    testTv = (TextView) findViewById(R.id.testTv);</span><br><span class=\"line\">    measureView(testTv);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">protected void onResume() &#123;</span><br><span class=\"line\">    super.onResume();</span><br><span class=\"line\">    Log.i(TAG, &quot;onResume start!&quot;);</span><br><span class=\"line\">    measureView(testTv);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Logcat中的运行结果：</p>\n<blockquote>\n<p>2019-01-14 22:33:13.874 18355-18355/com.example.wenhan.helloandroid I/MainActivity: Width: 225, height: 57<br>2019-01-14 22:33:13.874 18355-18355/com.example.wenhan.helloandroid I/MainActivity: Width: 225, height: 57</p>\n</blockquote>\n<h2 id=\"为何如此就可获取到正确的值了呢？\"><a href=\"#为何如此就可获取到正确的值了呢？\" class=\"headerlink\" title=\"为何如此就可获取到正确的值了呢？\"></a>为何如此就可获取到正确的值了呢？</h2><p>其中的玄机在于，我们在View.post()中所写的语句并没有立即执行，而在其真正执行的时候，View的宽高已经被测量完成了，那时我们再去获取宽高时，就会很容易地获取到正确的值了。<br>通过断点Debug，可以轻松地发现，在Activity启动过程的调用栈中，存在ActivityThread类被执行了，具体按照：</p>\n<blockquote>\n<p>main() -&gt; handleResumeActivity() -&gt; addView() -&gt; setView() -&gt; requestLayout() -&gt; scheduleTraversals() -&gt; 执行mTraversalRunnable异步线程 -&gt; doTraversal() -&gt; performTraversals() -&gt; … -&gt; performMeasure() -&gt;  …</p>\n</blockquote>\n<p>的执行顺序。<br>在我们获取宽高的语句执行前，主线程的Handler正在执行TraversalRunnable（见上述方法具体实现），而performMeasure也被包含其中。又因为我们获取宽高的语句要排队，处于等待状态，直到主线程Handler轮到执行我们的语句，而此时View的宽高的测量已经结束。</p>\n<p>完整示例代码：<a href=\"https://github.com/wh1990xiao2005/FetchViewSizeDemo\" target=\"_blank\" rel=\"noopener\">https://github.com/wh1990xiao2005/FetchViewSizeDemo</a></p>\n"},{"title":"抓出卡顿元凶，从分析掉帧开始","date":"2019-02-25T02:23:48.000Z","_content":"\n这次我们依旧来谈谈有关性能优化的话题，这次我们会用到Google给我们提供的分析工具——Systrace。如果你还不了解这个工具，最好先了解一下。Google 官方文档：\nhttps://developer.android.com/studio/command-line/systrace  \n我们还会用到一个Demo，用来对比卡顿和不卡顿的状况。   \n\n问题重现\n----------\nDemo运行起来会是这样的：   \n**流畅运行**   \n\n![流畅运行的录屏](https://img-blog.csdnimg.cn/20190224160306500.gif)\n\n**模拟卡顿**   \n![模拟卡顿的录屏](https://img-blog.csdnimg.cn/20190224160429527.gif)   \n\n这里解释一下，GIF动画表现得不是很完善，流畅运行的效果其实是每秒60帧，实际运行效果非常顺畅。模拟卡顿的效果在每秒60帧的基础上加了随机时长的线程sleep时间。具体实验代码片如下所示：\n\n**流畅运行的代码片**\n\n```\nthreadRun = true;\npbCurrent = 0;\ndemoPb.setProgress(pbCurrent);\nnew Thread(new Runnable() {\n    @Override\n    public void run() {\n        while (threadRun) {\n            try {\n                Thread.sleep(1000 / 60);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            if (pbCurrent > PB_MAX) {\n                pbCurrent = 0;\n            } else {\n                pbCurrent++;\n            }\n            Message msg = new Message();\n            msg.what = UPDATE_HANDLER_KEY;\n            mUiHandler.sendMessage(msg);\n        }\n    }\n}).start();\n```\n**模拟卡顿的代码片**\n\n```\nthread2Run = true;\npbCurrent = 0;\ndemoPb.setProgress(pbCurrent);\nnew Thread(new Runnable() {\n    @Override\n    public void run() {\n        while (thread2Run) {\n            try {\n                Thread.sleep(1000 / 60);\n                Thread.sleep(new Random().nextInt(200));\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            if (pbCurrent > PB_MAX) {\n                pbCurrent = 0;\n            } else {\n                pbCurrent++;\n            }\n            Message msg = new Message();\n            msg.what = UPDATE_HANDLER_KEY;\n            mUiHandler.sendMessage(msg);\n        }\n    }\n}).start();\n```\n**更新UI部分代码片**\n\n```\n@Override\npublic void handleMessage(Message msg) {\n    super.handleMessage(msg);\n    switch (msg.what) {\n        case UPDATE_HANDLER_KEY:\n            demoPb.setProgress(pbCurrent);\n            break;\n    }\n}\n```\n两个按钮分别对应上述两个线程的使能，另外请注意：我们只是模拟卡顿，并非真的发生了卡顿。因此，在Systrace的图表中，没有出现红色或橙色的告警。  \n分别对上述两种情况取Systrace图表，得到如下结果：  \n\n**流畅运行的图表**\n![流畅运行的Systrace图表](https://img-blog.csdnimg.cn/20190225091835606.PNG)\n**模拟卡顿运行的图表**\n![模拟卡顿运行的图表](https://img-blog.csdnimg.cn/20190225092116729.PNG)\n通过对比，我们可以看到上面二者之间的差别。流畅运行的图表中，每一帧的绘制很均匀。差不多16.6ms一帧，也就是1000毫秒除以60帧，得到的16.6ms一帧。而模拟卡顿的图表中，每一帧的绘制则不均匀，有的长达将近200ms。但由于是我们自身模拟的结果，并非实际卡顿，所以图表中均为绿色的显示。下面我们来看一个真实的案例：  \n\n**真实案例**\n![卡顿发生的真实案例](https://img-blog.csdnimg.cn/20190225093033879.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doMTk5MHhpYW8yMDA1,size_16,color_FFFFFF,t_70)\n上图中，一帧本来应该是16ms完成的，然而却花费了近60ms，用1000ms/60ms，我们得到近似16帧。而16帧的帧率已经是肉眼可见的卡顿了。  \n\n揪出凶手\n----------\n我们聚焦到上面真实的案例，放大看发生卡顿的位置：  \n![放大-第一步](https://img-blog.csdnimg.cn/20190225095331215.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doMTk5MHhpYW8yMDA1,size_16,color_FFFFFF,t_70)\n我们发现，Record View 的draw()方法花费了一些时间。\n![不正常的draw()方法](https://img-blog.csdnimg.cn/20190225095558336.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doMTk5MHhpYW8yMDA1,size_16,color_FFFFFF,t_70)\n此外，还有一堆琐碎的小片段，我们进一步放大观察，会发现：\n![放大-第二步](https://img-blog.csdnimg.cn/20190225095920155.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doMTk5MHhpYW8yMDA1,size_16,color_FFFFFF,t_70)\n这里居然还加载了一堆贴图。  \n至此，我们就抓到了导致掉帧的“元凶”，下一步就是结合源代码进行优化了。  \n\n一些疑问和技巧\n-------\n**为什么16ms一帧？**\n16ms是1000ms/60帧得到的结果，60帧对于人眼而言已经是很流畅的体验了。而最低的限度是33ms一帧，也就是1000ms/30帧得到的结果。如果时间再长一点的话，就有可能发生人眼可见的卡顿了。\n延伸一点，也就是说，如果严格要求60帧，但是中间掉了1帧，就相当于33ms画一帧，此时，虽然掉帧，但是人眼还是可接受的。  \n\n**如何快速定位卡顿位置**\n首先是确保发生了卡顿。一般而言，没有发生卡顿的图表，网页的图表会是绿色的，发生卡顿的则是红色的。\n![网页Logo](https://img-blog.csdnimg.cn/2019022510074685.PNG)\n然后我们使用键盘+鼠标的组合来找位置，键盘的快捷键对应W、S、A、D。AD相当于拖拽时间滑块，WS相当于缩放。\n最后我们用鼠标来选取相应的时间范围即可。  \n\n今天的分享到此，希望对你有帮助。","source":"_posts/抓出卡顿元凶，从分析掉帧开始.md","raw":"---\ntitle: 抓出卡顿元凶，从分析掉帧开始\ndate: 2019-02-25 10:23:48\ntags: Android\ncategories: 编程世界\n---\n\n这次我们依旧来谈谈有关性能优化的话题，这次我们会用到Google给我们提供的分析工具——Systrace。如果你还不了解这个工具，最好先了解一下。Google 官方文档：\nhttps://developer.android.com/studio/command-line/systrace  \n我们还会用到一个Demo，用来对比卡顿和不卡顿的状况。   \n\n问题重现\n----------\nDemo运行起来会是这样的：   \n**流畅运行**   \n\n![流畅运行的录屏](https://img-blog.csdnimg.cn/20190224160306500.gif)\n\n**模拟卡顿**   \n![模拟卡顿的录屏](https://img-blog.csdnimg.cn/20190224160429527.gif)   \n\n这里解释一下，GIF动画表现得不是很完善，流畅运行的效果其实是每秒60帧，实际运行效果非常顺畅。模拟卡顿的效果在每秒60帧的基础上加了随机时长的线程sleep时间。具体实验代码片如下所示：\n\n**流畅运行的代码片**\n\n```\nthreadRun = true;\npbCurrent = 0;\ndemoPb.setProgress(pbCurrent);\nnew Thread(new Runnable() {\n    @Override\n    public void run() {\n        while (threadRun) {\n            try {\n                Thread.sleep(1000 / 60);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            if (pbCurrent > PB_MAX) {\n                pbCurrent = 0;\n            } else {\n                pbCurrent++;\n            }\n            Message msg = new Message();\n            msg.what = UPDATE_HANDLER_KEY;\n            mUiHandler.sendMessage(msg);\n        }\n    }\n}).start();\n```\n**模拟卡顿的代码片**\n\n```\nthread2Run = true;\npbCurrent = 0;\ndemoPb.setProgress(pbCurrent);\nnew Thread(new Runnable() {\n    @Override\n    public void run() {\n        while (thread2Run) {\n            try {\n                Thread.sleep(1000 / 60);\n                Thread.sleep(new Random().nextInt(200));\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            if (pbCurrent > PB_MAX) {\n                pbCurrent = 0;\n            } else {\n                pbCurrent++;\n            }\n            Message msg = new Message();\n            msg.what = UPDATE_HANDLER_KEY;\n            mUiHandler.sendMessage(msg);\n        }\n    }\n}).start();\n```\n**更新UI部分代码片**\n\n```\n@Override\npublic void handleMessage(Message msg) {\n    super.handleMessage(msg);\n    switch (msg.what) {\n        case UPDATE_HANDLER_KEY:\n            demoPb.setProgress(pbCurrent);\n            break;\n    }\n}\n```\n两个按钮分别对应上述两个线程的使能，另外请注意：我们只是模拟卡顿，并非真的发生了卡顿。因此，在Systrace的图表中，没有出现红色或橙色的告警。  \n分别对上述两种情况取Systrace图表，得到如下结果：  \n\n**流畅运行的图表**\n![流畅运行的Systrace图表](https://img-blog.csdnimg.cn/20190225091835606.PNG)\n**模拟卡顿运行的图表**\n![模拟卡顿运行的图表](https://img-blog.csdnimg.cn/20190225092116729.PNG)\n通过对比，我们可以看到上面二者之间的差别。流畅运行的图表中，每一帧的绘制很均匀。差不多16.6ms一帧，也就是1000毫秒除以60帧，得到的16.6ms一帧。而模拟卡顿的图表中，每一帧的绘制则不均匀，有的长达将近200ms。但由于是我们自身模拟的结果，并非实际卡顿，所以图表中均为绿色的显示。下面我们来看一个真实的案例：  \n\n**真实案例**\n![卡顿发生的真实案例](https://img-blog.csdnimg.cn/20190225093033879.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doMTk5MHhpYW8yMDA1,size_16,color_FFFFFF,t_70)\n上图中，一帧本来应该是16ms完成的，然而却花费了近60ms，用1000ms/60ms，我们得到近似16帧。而16帧的帧率已经是肉眼可见的卡顿了。  \n\n揪出凶手\n----------\n我们聚焦到上面真实的案例，放大看发生卡顿的位置：  \n![放大-第一步](https://img-blog.csdnimg.cn/20190225095331215.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doMTk5MHhpYW8yMDA1,size_16,color_FFFFFF,t_70)\n我们发现，Record View 的draw()方法花费了一些时间。\n![不正常的draw()方法](https://img-blog.csdnimg.cn/20190225095558336.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doMTk5MHhpYW8yMDA1,size_16,color_FFFFFF,t_70)\n此外，还有一堆琐碎的小片段，我们进一步放大观察，会发现：\n![放大-第二步](https://img-blog.csdnimg.cn/20190225095920155.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doMTk5MHhpYW8yMDA1,size_16,color_FFFFFF,t_70)\n这里居然还加载了一堆贴图。  \n至此，我们就抓到了导致掉帧的“元凶”，下一步就是结合源代码进行优化了。  \n\n一些疑问和技巧\n-------\n**为什么16ms一帧？**\n16ms是1000ms/60帧得到的结果，60帧对于人眼而言已经是很流畅的体验了。而最低的限度是33ms一帧，也就是1000ms/30帧得到的结果。如果时间再长一点的话，就有可能发生人眼可见的卡顿了。\n延伸一点，也就是说，如果严格要求60帧，但是中间掉了1帧，就相当于33ms画一帧，此时，虽然掉帧，但是人眼还是可接受的。  \n\n**如何快速定位卡顿位置**\n首先是确保发生了卡顿。一般而言，没有发生卡顿的图表，网页的图表会是绿色的，发生卡顿的则是红色的。\n![网页Logo](https://img-blog.csdnimg.cn/2019022510074685.PNG)\n然后我们使用键盘+鼠标的组合来找位置，键盘的快捷键对应W、S、A、D。AD相当于拖拽时间滑块，WS相当于缩放。\n最后我们用鼠标来选取相应的时间范围即可。  \n\n今天的分享到此，希望对你有帮助。","slug":"抓出卡顿元凶，从分析掉帧开始","published":1,"updated":"2019-07-31T04:11:32.159Z","_id":"cjyqq3tjw0013fkqdq678rht9","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这次我们依旧来谈谈有关性能优化的话题，这次我们会用到Google给我们提供的分析工具——Systrace。如果你还不了解这个工具，最好先了解一下。Google 官方文档：<br><a href=\"https://developer.android.com/studio/command-line/systrace\" target=\"_blank\" rel=\"noopener\">https://developer.android.com/studio/command-line/systrace</a><br>我们还会用到一个Demo，用来对比卡顿和不卡顿的状况。   </p>\n<h2 id=\"问题重现\"><a href=\"#问题重现\" class=\"headerlink\" title=\"问题重现\"></a>问题重现</h2><p>Demo运行起来会是这样的：<br><strong>流畅运行</strong>   </p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190224160306500.gif\" alt=\"流畅运行的录屏\"></p>\n<p><strong>模拟卡顿</strong><br><img src=\"https://img-blog.csdnimg.cn/20190224160429527.gif\" alt=\"模拟卡顿的录屏\">   </p>\n<p>这里解释一下，GIF动画表现得不是很完善，流畅运行的效果其实是每秒60帧，实际运行效果非常顺畅。模拟卡顿的效果在每秒60帧的基础上加了随机时长的线程sleep时间。具体实验代码片如下所示：</p>\n<p><strong>流畅运行的代码片</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">threadRun = true;</span><br><span class=\"line\">pbCurrent = 0;</span><br><span class=\"line\">demoPb.setProgress(pbCurrent);</span><br><span class=\"line\">new Thread(new Runnable() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        while (threadRun) &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                Thread.sleep(1000 / 60);</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (pbCurrent &gt; PB_MAX) &#123;</span><br><span class=\"line\">                pbCurrent = 0;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                pbCurrent++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Message msg = new Message();</span><br><span class=\"line\">            msg.what = UPDATE_HANDLER_KEY;</span><br><span class=\"line\">            mUiHandler.sendMessage(msg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n\n<p><strong>模拟卡顿的代码片</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">thread2Run = true;</span><br><span class=\"line\">pbCurrent = 0;</span><br><span class=\"line\">demoPb.setProgress(pbCurrent);</span><br><span class=\"line\">new Thread(new Runnable() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        while (thread2Run) &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                Thread.sleep(1000 / 60);</span><br><span class=\"line\">                Thread.sleep(new Random().nextInt(200));</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (pbCurrent &gt; PB_MAX) &#123;</span><br><span class=\"line\">                pbCurrent = 0;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                pbCurrent++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Message msg = new Message();</span><br><span class=\"line\">            msg.what = UPDATE_HANDLER_KEY;</span><br><span class=\"line\">            mUiHandler.sendMessage(msg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n\n<p><strong>更新UI部分代码片</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void handleMessage(Message msg) &#123;</span><br><span class=\"line\">    super.handleMessage(msg);</span><br><span class=\"line\">    switch (msg.what) &#123;</span><br><span class=\"line\">        case UPDATE_HANDLER_KEY:</span><br><span class=\"line\">            demoPb.setProgress(pbCurrent);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>两个按钮分别对应上述两个线程的使能，另外请注意：我们只是模拟卡顿，并非真的发生了卡顿。因此，在Systrace的图表中，没有出现红色或橙色的告警。<br>分别对上述两种情况取Systrace图表，得到如下结果：  </p>\n<p><strong>流畅运行的图表</strong><br><img src=\"https://img-blog.csdnimg.cn/20190225091835606.PNG\" alt=\"流畅运行的Systrace图表\"><br><strong>模拟卡顿运行的图表</strong><br><img src=\"https://img-blog.csdnimg.cn/20190225092116729.PNG\" alt=\"模拟卡顿运行的图表\"><br>通过对比，我们可以看到上面二者之间的差别。流畅运行的图表中，每一帧的绘制很均匀。差不多16.6ms一帧，也就是1000毫秒除以60帧，得到的16.6ms一帧。而模拟卡顿的图表中，每一帧的绘制则不均匀，有的长达将近200ms。但由于是我们自身模拟的结果，并非实际卡顿，所以图表中均为绿色的显示。下面我们来看一个真实的案例：  </p>\n<p><strong>真实案例</strong><br><img src=\"https://img-blog.csdnimg.cn/20190225093033879.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doMTk5MHhpYW8yMDA1,size_16,color_FFFFFF,t_70\" alt=\"卡顿发生的真实案例\"><br>上图中，一帧本来应该是16ms完成的，然而却花费了近60ms，用1000ms/60ms，我们得到近似16帧。而16帧的帧率已经是肉眼可见的卡顿了。  </p>\n<h2 id=\"揪出凶手\"><a href=\"#揪出凶手\" class=\"headerlink\" title=\"揪出凶手\"></a>揪出凶手</h2><p>我们聚焦到上面真实的案例，放大看发生卡顿的位置：<br><img src=\"https://img-blog.csdnimg.cn/20190225095331215.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doMTk5MHhpYW8yMDA1,size_16,color_FFFFFF,t_70\" alt=\"放大-第一步\"><br>我们发现，Record View 的draw()方法花费了一些时间。<br><img src=\"https://img-blog.csdnimg.cn/20190225095558336.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doMTk5MHhpYW8yMDA1,size_16,color_FFFFFF,t_70\" alt=\"不正常的draw()方法\"><br>此外，还有一堆琐碎的小片段，我们进一步放大观察，会发现：<br><img src=\"https://img-blog.csdnimg.cn/20190225095920155.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doMTk5MHhpYW8yMDA1,size_16,color_FFFFFF,t_70\" alt=\"放大-第二步\"><br>这里居然还加载了一堆贴图。<br>至此，我们就抓到了导致掉帧的“元凶”，下一步就是结合源代码进行优化了。  </p>\n<h2 id=\"一些疑问和技巧\"><a href=\"#一些疑问和技巧\" class=\"headerlink\" title=\"一些疑问和技巧\"></a>一些疑问和技巧</h2><p><strong>为什么16ms一帧？</strong><br>16ms是1000ms/60帧得到的结果，60帧对于人眼而言已经是很流畅的体验了。而最低的限度是33ms一帧，也就是1000ms/30帧得到的结果。如果时间再长一点的话，就有可能发生人眼可见的卡顿了。<br>延伸一点，也就是说，如果严格要求60帧，但是中间掉了1帧，就相当于33ms画一帧，此时，虽然掉帧，但是人眼还是可接受的。  </p>\n<p><strong>如何快速定位卡顿位置</strong><br>首先是确保发生了卡顿。一般而言，没有发生卡顿的图表，网页的图表会是绿色的，发生卡顿的则是红色的。<br><img src=\"https://img-blog.csdnimg.cn/2019022510074685.PNG\" alt=\"网页Logo\"><br>然后我们使用键盘+鼠标的组合来找位置，键盘的快捷键对应W、S、A、D。AD相当于拖拽时间滑块，WS相当于缩放。<br>最后我们用鼠标来选取相应的时间范围即可。  </p>\n<p>今天的分享到此，希望对你有帮助。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这次我们依旧来谈谈有关性能优化的话题，这次我们会用到Google给我们提供的分析工具——Systrace。如果你还不了解这个工具，最好先了解一下。Google 官方文档：<br><a href=\"https://developer.android.com/studio/command-line/systrace\" target=\"_blank\" rel=\"noopener\">https://developer.android.com/studio/command-line/systrace</a><br>我们还会用到一个Demo，用来对比卡顿和不卡顿的状况。   </p>\n<h2 id=\"问题重现\"><a href=\"#问题重现\" class=\"headerlink\" title=\"问题重现\"></a>问题重现</h2><p>Demo运行起来会是这样的：<br><strong>流畅运行</strong>   </p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190224160306500.gif\" alt=\"流畅运行的录屏\"></p>\n<p><strong>模拟卡顿</strong><br><img src=\"https://img-blog.csdnimg.cn/20190224160429527.gif\" alt=\"模拟卡顿的录屏\">   </p>\n<p>这里解释一下，GIF动画表现得不是很完善，流畅运行的效果其实是每秒60帧，实际运行效果非常顺畅。模拟卡顿的效果在每秒60帧的基础上加了随机时长的线程sleep时间。具体实验代码片如下所示：</p>\n<p><strong>流畅运行的代码片</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">threadRun = true;</span><br><span class=\"line\">pbCurrent = 0;</span><br><span class=\"line\">demoPb.setProgress(pbCurrent);</span><br><span class=\"line\">new Thread(new Runnable() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        while (threadRun) &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                Thread.sleep(1000 / 60);</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (pbCurrent &gt; PB_MAX) &#123;</span><br><span class=\"line\">                pbCurrent = 0;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                pbCurrent++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Message msg = new Message();</span><br><span class=\"line\">            msg.what = UPDATE_HANDLER_KEY;</span><br><span class=\"line\">            mUiHandler.sendMessage(msg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n\n<p><strong>模拟卡顿的代码片</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">thread2Run = true;</span><br><span class=\"line\">pbCurrent = 0;</span><br><span class=\"line\">demoPb.setProgress(pbCurrent);</span><br><span class=\"line\">new Thread(new Runnable() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        while (thread2Run) &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                Thread.sleep(1000 / 60);</span><br><span class=\"line\">                Thread.sleep(new Random().nextInt(200));</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (pbCurrent &gt; PB_MAX) &#123;</span><br><span class=\"line\">                pbCurrent = 0;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                pbCurrent++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Message msg = new Message();</span><br><span class=\"line\">            msg.what = UPDATE_HANDLER_KEY;</span><br><span class=\"line\">            mUiHandler.sendMessage(msg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n\n<p><strong>更新UI部分代码片</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void handleMessage(Message msg) &#123;</span><br><span class=\"line\">    super.handleMessage(msg);</span><br><span class=\"line\">    switch (msg.what) &#123;</span><br><span class=\"line\">        case UPDATE_HANDLER_KEY:</span><br><span class=\"line\">            demoPb.setProgress(pbCurrent);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>两个按钮分别对应上述两个线程的使能，另外请注意：我们只是模拟卡顿，并非真的发生了卡顿。因此，在Systrace的图表中，没有出现红色或橙色的告警。<br>分别对上述两种情况取Systrace图表，得到如下结果：  </p>\n<p><strong>流畅运行的图表</strong><br><img src=\"https://img-blog.csdnimg.cn/20190225091835606.PNG\" alt=\"流畅运行的Systrace图表\"><br><strong>模拟卡顿运行的图表</strong><br><img src=\"https://img-blog.csdnimg.cn/20190225092116729.PNG\" alt=\"模拟卡顿运行的图表\"><br>通过对比，我们可以看到上面二者之间的差别。流畅运行的图表中，每一帧的绘制很均匀。差不多16.6ms一帧，也就是1000毫秒除以60帧，得到的16.6ms一帧。而模拟卡顿的图表中，每一帧的绘制则不均匀，有的长达将近200ms。但由于是我们自身模拟的结果，并非实际卡顿，所以图表中均为绿色的显示。下面我们来看一个真实的案例：  </p>\n<p><strong>真实案例</strong><br><img src=\"https://img-blog.csdnimg.cn/20190225093033879.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doMTk5MHhpYW8yMDA1,size_16,color_FFFFFF,t_70\" alt=\"卡顿发生的真实案例\"><br>上图中，一帧本来应该是16ms完成的，然而却花费了近60ms，用1000ms/60ms，我们得到近似16帧。而16帧的帧率已经是肉眼可见的卡顿了。  </p>\n<h2 id=\"揪出凶手\"><a href=\"#揪出凶手\" class=\"headerlink\" title=\"揪出凶手\"></a>揪出凶手</h2><p>我们聚焦到上面真实的案例，放大看发生卡顿的位置：<br><img src=\"https://img-blog.csdnimg.cn/20190225095331215.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doMTk5MHhpYW8yMDA1,size_16,color_FFFFFF,t_70\" alt=\"放大-第一步\"><br>我们发现，Record View 的draw()方法花费了一些时间。<br><img src=\"https://img-blog.csdnimg.cn/20190225095558336.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doMTk5MHhpYW8yMDA1,size_16,color_FFFFFF,t_70\" alt=\"不正常的draw()方法\"><br>此外，还有一堆琐碎的小片段，我们进一步放大观察，会发现：<br><img src=\"https://img-blog.csdnimg.cn/20190225095920155.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doMTk5MHhpYW8yMDA1,size_16,color_FFFFFF,t_70\" alt=\"放大-第二步\"><br>这里居然还加载了一堆贴图。<br>至此，我们就抓到了导致掉帧的“元凶”，下一步就是结合源代码进行优化了。  </p>\n<h2 id=\"一些疑问和技巧\"><a href=\"#一些疑问和技巧\" class=\"headerlink\" title=\"一些疑问和技巧\"></a>一些疑问和技巧</h2><p><strong>为什么16ms一帧？</strong><br>16ms是1000ms/60帧得到的结果，60帧对于人眼而言已经是很流畅的体验了。而最低的限度是33ms一帧，也就是1000ms/30帧得到的结果。如果时间再长一点的话，就有可能发生人眼可见的卡顿了。<br>延伸一点，也就是说，如果严格要求60帧，但是中间掉了1帧，就相当于33ms画一帧，此时，虽然掉帧，但是人眼还是可接受的。  </p>\n<p><strong>如何快速定位卡顿位置</strong><br>首先是确保发生了卡顿。一般而言，没有发生卡顿的图表，网页的图表会是绿色的，发生卡顿的则是红色的。<br><img src=\"https://img-blog.csdnimg.cn/2019022510074685.PNG\" alt=\"网页Logo\"><br>然后我们使用键盘+鼠标的组合来找位置，键盘的快捷键对应W、S、A、D。AD相当于拖拽时间滑块，WS相当于缩放。<br>最后我们用鼠标来选取相应的时间范围即可。  </p>\n<p>今天的分享到此，希望对你有帮助。</p>\n"},{"title":"提升应用崩溃时的用户体验——去掉烦人的“很抱歉”提示框","date":"2015-04-21T11:51:37.000Z","_content":"\n好久不见了。  \n最近，博主一直在忙着搞建站的事情，也有一段时间没有更新博客了，很抱歉。同时，希望朋友们访问我的主站，加收藏的就更好了，哈哈！   \n相信很多在用或者用过Android系统的的手机的朋友都有过这样的经历：自己玩着玩着某个程序，突然屏幕一黑，然后出现一个对话框，提示很抱歉，应用程序已经停止工作。这意味着程序已然崩溃了，用户唯一要做的就是接下来重新运行这个程序，或者去干些别的。我个人推测，前者占大多数。   \n当然，一些比较健壮的程序是一般不会出现这种情况的，但是，作为一名对用户负责的开发者，要时刻为用户着想，这就是我们今天要谈的话题——优化程序崩溃时的用户体验。  \n**我们的目标是：程序发生了异常后，自定义异常处理流程，然后自动重新启动程序。**  \n看上去貌似很复杂，其实很容易。**核心在于对Application这个单例的继承。**  \n首先，在应用中写一个类，继承Application，然后在AndroidManifest.xml中注册，注册的代码可如下例：  \n```\n<application\n    android:name=\".environment.BaseApplication\"\n    android:enabled=\"true\"\n    android:icon=\"@drawable/icon64\"\n    android:label=\"@string/app_name\"\n    android:persistent=\"true\" >\n\t......\n</application>\n```\n其中，我把继承了Application的类是【包名】.environment.BaseApplication。  \n**大家可以根据自身的项目需要进行安排，不要忘了在这里注册就好。**  \n之后就是对应用中未捕获的异常做处理了。  \n在BaseApplication中，创建一个名为CrashHandler的子类，该类实现UncaughtExceptionHandler接口，复写uncaughtException方法。在该方法中，进行相应的崩溃处理。这里我们需要重启程序，因此，该子类可以写成如下代码段所示的内容：  \n```\n// 异常处理\nclass CrashHandler implements UncaughtExceptionHandler {\n\n\t@Override\n\tpublic void uncaughtException(Thread thread, final Throwable ex) {\n\t\tex.printStackTrace();\n\t\tIntent restartIntent = new Intent(BaseApplication.this, SplashScreen.class);\n\t\trestartIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\t\tstartActivity(restartIntent);\n\t\tandroid.os.Process.killProcess(android.os.Process.myPid());\n\t}\n}\n```\n这里需要注意的是，**Intent对象的Flag必须包含FLAG\\_ACTIVITY\\_NEW\\_TASK。**  \n最后，在复写的onCreate方法中，指定异常处理的方法：  \n\n```\nThread.setDefaultUncaughtExceptionHandler(crashHandler);\n```\n\n其中，crashHandler为CrashHandler的对象。\n到此，我们的程序在发生崩溃的时候就不会出现“很抱歉。。。”的对话框了，取而代之的是自动重启。  \n当然，这只是一个治标不治本的方法，真正的解决之道依然要找到崩溃的位置，然后除掉这个Bug。  \n最后，关于Application，我这里就不多说了，如果诸位不是很了解的话，可以看下这位兄弟的文章，会大有启发：  \n[http://blog.csdn.net/pi9nc/article/details/11200969 ](http://blog.csdn.net/pi9nc/article/details/11200969) ","source":"_posts/提升应用崩溃时的用户体验——去掉烦人的“很抱歉”提示框.md","raw":"---\ntitle: 提升应用崩溃时的用户体验——去掉烦人的“很抱歉”提示框\ndate: 2015-04-21 19:51:37\ntags: Android\ncategories: 编程世界\n---\n\n好久不见了。  \n最近，博主一直在忙着搞建站的事情，也有一段时间没有更新博客了，很抱歉。同时，希望朋友们访问我的主站，加收藏的就更好了，哈哈！   \n相信很多在用或者用过Android系统的的手机的朋友都有过这样的经历：自己玩着玩着某个程序，突然屏幕一黑，然后出现一个对话框，提示很抱歉，应用程序已经停止工作。这意味着程序已然崩溃了，用户唯一要做的就是接下来重新运行这个程序，或者去干些别的。我个人推测，前者占大多数。   \n当然，一些比较健壮的程序是一般不会出现这种情况的，但是，作为一名对用户负责的开发者，要时刻为用户着想，这就是我们今天要谈的话题——优化程序崩溃时的用户体验。  \n**我们的目标是：程序发生了异常后，自定义异常处理流程，然后自动重新启动程序。**  \n看上去貌似很复杂，其实很容易。**核心在于对Application这个单例的继承。**  \n首先，在应用中写一个类，继承Application，然后在AndroidManifest.xml中注册，注册的代码可如下例：  \n```\n<application\n    android:name=\".environment.BaseApplication\"\n    android:enabled=\"true\"\n    android:icon=\"@drawable/icon64\"\n    android:label=\"@string/app_name\"\n    android:persistent=\"true\" >\n\t......\n</application>\n```\n其中，我把继承了Application的类是【包名】.environment.BaseApplication。  \n**大家可以根据自身的项目需要进行安排，不要忘了在这里注册就好。**  \n之后就是对应用中未捕获的异常做处理了。  \n在BaseApplication中，创建一个名为CrashHandler的子类，该类实现UncaughtExceptionHandler接口，复写uncaughtException方法。在该方法中，进行相应的崩溃处理。这里我们需要重启程序，因此，该子类可以写成如下代码段所示的内容：  \n```\n// 异常处理\nclass CrashHandler implements UncaughtExceptionHandler {\n\n\t@Override\n\tpublic void uncaughtException(Thread thread, final Throwable ex) {\n\t\tex.printStackTrace();\n\t\tIntent restartIntent = new Intent(BaseApplication.this, SplashScreen.class);\n\t\trestartIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\t\tstartActivity(restartIntent);\n\t\tandroid.os.Process.killProcess(android.os.Process.myPid());\n\t}\n}\n```\n这里需要注意的是，**Intent对象的Flag必须包含FLAG\\_ACTIVITY\\_NEW\\_TASK。**  \n最后，在复写的onCreate方法中，指定异常处理的方法：  \n\n```\nThread.setDefaultUncaughtExceptionHandler(crashHandler);\n```\n\n其中，crashHandler为CrashHandler的对象。\n到此，我们的程序在发生崩溃的时候就不会出现“很抱歉。。。”的对话框了，取而代之的是自动重启。  \n当然，这只是一个治标不治本的方法，真正的解决之道依然要找到崩溃的位置，然后除掉这个Bug。  \n最后，关于Application，我这里就不多说了，如果诸位不是很了解的话，可以看下这位兄弟的文章，会大有启发：  \n[http://blog.csdn.net/pi9nc/article/details/11200969 ](http://blog.csdn.net/pi9nc/article/details/11200969) ","slug":"提升应用崩溃时的用户体验——去掉烦人的“很抱歉”提示框","published":1,"updated":"2019-07-31T04:11:35.447Z","_id":"cjyqq3tjz0015fkqdcl4wel6n","comments":1,"layout":"post","photos":[],"link":"","content":"<p>好久不见了。<br>最近，博主一直在忙着搞建站的事情，也有一段时间没有更新博客了，很抱歉。同时，希望朋友们访问我的主站，加收藏的就更好了，哈哈！<br>相信很多在用或者用过Android系统的的手机的朋友都有过这样的经历：自己玩着玩着某个程序，突然屏幕一黑，然后出现一个对话框，提示很抱歉，应用程序已经停止工作。这意味着程序已然崩溃了，用户唯一要做的就是接下来重新运行这个程序，或者去干些别的。我个人推测，前者占大多数。<br>当然，一些比较健壮的程序是一般不会出现这种情况的，但是，作为一名对用户负责的开发者，要时刻为用户着想，这就是我们今天要谈的话题——优化程序崩溃时的用户体验。<br><strong>我们的目标是：程序发生了异常后，自定义异常处理流程，然后自动重新启动程序。</strong><br>看上去貌似很复杂，其实很容易。<strong>核心在于对Application这个单例的继承。</strong><br>首先，在应用中写一个类，继承Application，然后在AndroidManifest.xml中注册，注册的代码可如下例：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;application</span><br><span class=\"line\">    android:name=&quot;.environment.BaseApplication&quot;</span><br><span class=\"line\">    android:enabled=&quot;true&quot;</span><br><span class=\"line\">    android:icon=&quot;@drawable/icon64&quot;</span><br><span class=\"line\">    android:label=&quot;@string/app_name&quot;</span><br><span class=\"line\">    android:persistent=&quot;true&quot; &gt;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&lt;/application&gt;</span><br></pre></td></tr></table></figure>\n\n<p>其中，我把继承了Application的类是【包名】.environment.BaseApplication。<br><strong>大家可以根据自身的项目需要进行安排，不要忘了在这里注册就好。</strong><br>之后就是对应用中未捕获的异常做处理了。<br>在BaseApplication中，创建一个名为CrashHandler的子类，该类实现UncaughtExceptionHandler接口，复写uncaughtException方法。在该方法中，进行相应的崩溃处理。这里我们需要重启程序，因此，该子类可以写成如下代码段所示的内容：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 异常处理</span><br><span class=\"line\">class CrashHandler implements UncaughtExceptionHandler &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void uncaughtException(Thread thread, final Throwable ex) &#123;</span><br><span class=\"line\">\t\tex.printStackTrace();</span><br><span class=\"line\">\t\tIntent restartIntent = new Intent(BaseApplication.this, SplashScreen.class);</span><br><span class=\"line\">\t\trestartIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class=\"line\">\t\tstartActivity(restartIntent);</span><br><span class=\"line\">\t\tandroid.os.Process.killProcess(android.os.Process.myPid());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里需要注意的是，<strong>Intent对象的Flag必须包含FLAG_ACTIVITY_NEW_TASK。</strong><br>最后，在复写的onCreate方法中，指定异常处理的方法：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread.setDefaultUncaughtExceptionHandler(crashHandler);</span><br></pre></td></tr></table></figure>\n\n<p>其中，crashHandler为CrashHandler的对象。<br>到此，我们的程序在发生崩溃的时候就不会出现“很抱歉。。。”的对话框了，取而代之的是自动重启。<br>当然，这只是一个治标不治本的方法，真正的解决之道依然要找到崩溃的位置，然后除掉这个Bug。<br>最后，关于Application，我这里就不多说了，如果诸位不是很了解的话，可以看下这位兄弟的文章，会大有启发：<br><a href=\"http://blog.csdn.net/pi9nc/article/details/11200969\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/pi9nc/article/details/11200969 </a> </p>\n","site":{"data":{}},"excerpt":"","more":"<p>好久不见了。<br>最近，博主一直在忙着搞建站的事情，也有一段时间没有更新博客了，很抱歉。同时，希望朋友们访问我的主站，加收藏的就更好了，哈哈！<br>相信很多在用或者用过Android系统的的手机的朋友都有过这样的经历：自己玩着玩着某个程序，突然屏幕一黑，然后出现一个对话框，提示很抱歉，应用程序已经停止工作。这意味着程序已然崩溃了，用户唯一要做的就是接下来重新运行这个程序，或者去干些别的。我个人推测，前者占大多数。<br>当然，一些比较健壮的程序是一般不会出现这种情况的，但是，作为一名对用户负责的开发者，要时刻为用户着想，这就是我们今天要谈的话题——优化程序崩溃时的用户体验。<br><strong>我们的目标是：程序发生了异常后，自定义异常处理流程，然后自动重新启动程序。</strong><br>看上去貌似很复杂，其实很容易。<strong>核心在于对Application这个单例的继承。</strong><br>首先，在应用中写一个类，继承Application，然后在AndroidManifest.xml中注册，注册的代码可如下例：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;application</span><br><span class=\"line\">    android:name=&quot;.environment.BaseApplication&quot;</span><br><span class=\"line\">    android:enabled=&quot;true&quot;</span><br><span class=\"line\">    android:icon=&quot;@drawable/icon64&quot;</span><br><span class=\"line\">    android:label=&quot;@string/app_name&quot;</span><br><span class=\"line\">    android:persistent=&quot;true&quot; &gt;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&lt;/application&gt;</span><br></pre></td></tr></table></figure>\n\n<p>其中，我把继承了Application的类是【包名】.environment.BaseApplication。<br><strong>大家可以根据自身的项目需要进行安排，不要忘了在这里注册就好。</strong><br>之后就是对应用中未捕获的异常做处理了。<br>在BaseApplication中，创建一个名为CrashHandler的子类，该类实现UncaughtExceptionHandler接口，复写uncaughtException方法。在该方法中，进行相应的崩溃处理。这里我们需要重启程序，因此，该子类可以写成如下代码段所示的内容：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 异常处理</span><br><span class=\"line\">class CrashHandler implements UncaughtExceptionHandler &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void uncaughtException(Thread thread, final Throwable ex) &#123;</span><br><span class=\"line\">\t\tex.printStackTrace();</span><br><span class=\"line\">\t\tIntent restartIntent = new Intent(BaseApplication.this, SplashScreen.class);</span><br><span class=\"line\">\t\trestartIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class=\"line\">\t\tstartActivity(restartIntent);</span><br><span class=\"line\">\t\tandroid.os.Process.killProcess(android.os.Process.myPid());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里需要注意的是，<strong>Intent对象的Flag必须包含FLAG_ACTIVITY_NEW_TASK。</strong><br>最后，在复写的onCreate方法中，指定异常处理的方法：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread.setDefaultUncaughtExceptionHandler(crashHandler);</span><br></pre></td></tr></table></figure>\n\n<p>其中，crashHandler为CrashHandler的对象。<br>到此，我们的程序在发生崩溃的时候就不会出现“很抱歉。。。”的对话框了，取而代之的是自动重启。<br>当然，这只是一个治标不治本的方法，真正的解决之道依然要找到崩溃的位置，然后除掉这个Bug。<br>最后，关于Application，我这里就不多说了，如果诸位不是很了解的话，可以看下这位兄弟的文章，会大有启发：<br><a href=\"http://blog.csdn.net/pi9nc/article/details/11200969\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/pi9nc/article/details/11200969 </a> </p>\n"},{"title":"微信插件开发手记-聊天界面传送任意类型文件","date":"2014-07-03T11:32:42.000Z","_content":"\n项目完整源码请见：https://github.com/XiaoWenHan/Anytransforwechat\n\n## 目的  \n好，这是整篇文章唯一一个看似废话的部分，毕竟它才是整个项目得以完成并分享的源动力。最初的想法是由于目前微信移动客户端无法给好友发送文件，除了图片、语音、视频。当然，询问了很多人之后答案是Web版可以，可是每次传文件都要去Web客户端也太麻烦了一些，于是萌发了要做一个文件传送的微信插件的想法，暂定为《微信随心传 1.0 Beta》。功能很明确，就是向好友分享文件，其他的功能就没有了。虽然功能很单一，但希望它能为更多的人提供方便。  \n\n## 微信审核\n这个是前提，只有通过审核，才能得到APP_ID；只有得到APP_ID，才能进行开发，才能在微信的附件栏里成功调用这个应用。具体方法如下：   \n\n1. 登录微信开放平台：https://open.weixin.qq.com/，注册开发者帐号；   \n2. 创建一个项目，使用微信开放平台提供的签名生成工具，生成此项目的签名信息（就是Debug Key）；   \n3. 在移动应用板块，按照网页上的向导创建移动应用，填上相关信息，等待审核通过（这个过程不会太慢，差不多第三天就会通过，运气好的话几个小时而已）；   \n一旦通过审核，会有通知，在管理中心的已通过审核部分，会看到我们创建好的应用信息，我们可以通过查看详情找到开发所需的APP_ID。   \n\n\n## 搭建项目\n从这个部分开始，就是真正编码的过程了。   \n1. 首先从官方提供的SDK Demo项目中找到libammsdk.jar，复制到我们的项目lib文件夹中，这个Jar包是实现所有功能的核心。   \n2. 修改AndroidManifest.xml文件，添加一个Activity。路径固定为包名后跟\".wxapi.WXEntryActivity\"。具体代码块如下：   \n\n```\n<activity\n            android:name=\".wxapi.WXEntryActivity\"\n            android:exported=\"true\"\n</activity>\n```\n\n上述两个Activity属性固定，不要做任何改变。但不妨碍继续添加属性，比如加一个\"android:label=\"@string/app_name\"\"，是没有关系的；    \n3. 创建第2步中被添加的Activity，该Activity必须实现IWXAPIEventHandler。这时，该类会提示我们要去Override onReq()和onResp()方法，这里我们主要是重写onReq()方法即可；   \n4. 声明一个全局的IWXAPI对象的变量，在onCreate方法中进行初始化。代码块如下：    \n\n```\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n\tsuper.onCreate(savedInstanceState);\n\tiwxapi = WXAPIFactory.createWXAPI(WXEntryActivity.this,MainActivity.APP_ID);\n\tiwxapi.handleIntent(getIntent(), this);\n}\n```\n\n**注意：iwxapi为已声明但尚未初始化的变量；**   \n5. 在onReq回调方法里，根据微信不同的响应类型分别做操作。类型我们可以通过req.getType()得到，具体代码块如下：   \n\n```\n@Override\npublic void onReq(BaseReq req) {\n\tswitch (req.getType()) {\n\tcase ConstantsAPI.COMMAND_GETMESSAGE_FROM_WX:\n\t\t// 选取文件发送\n\tcase ConstantsAPI.COMMAND_SHOWMESSAGE_FROM_WX:\n\t\t// 打开文件\n        }\n}\n```\n\n根据注释信息在相应的位置进行相应的操作即可；   \n6. 获取到文件路径后，使用下面的方法，即可发送指定的文件：\n\n```\nWXAppExtendObject wxAppExtendObject = new WXAppExtendObject();\nwxAppExtendObject.filePath = sendFile.getPath();\nWXMediaMessage msg = new WXMediaMessage();\nmsg.mediaObject = wxAppExtendObject;\nSendMessageToWX.Req req = new SendMessageToWX.Req();\nreq.transaction = getTransaction();\nreq.message = msg;\nreq.scene = SendMessageToWX.Req.WXSceneSession;\niwxapi.sendReq(req);\n```\n\n**注：sendFile是File类型的变量，是要发送的文件；**\n\n7. 找到接收到的文件的路径的方法见此：\n\n```\nWXAppExtendObject wxAppExtendObject = (WXAppExtendObject) ((((ShowMessageFromWX.Req) req).message.mediaObject));\nString filePath = wxAppExtendObject.filePath;\n```\n\n到此，获取到文件路径，可以通过该路径进行自定义的操作了。   \n**特别注意，这里的文件路径通常是微信的缓存路径，因此基本上无需考虑文件重名问题了。**","source":"_posts/微信插件开发手记-聊天界面传送任意类型文件.md","raw":"---\ntitle: 微信插件开发手记-聊天界面传送任意类型文件\ndate: 2014-07-03 19:32:42\ntags: Android\ncategories: 编程世界\n---\n\n项目完整源码请见：https://github.com/XiaoWenHan/Anytransforwechat\n\n## 目的  \n好，这是整篇文章唯一一个看似废话的部分，毕竟它才是整个项目得以完成并分享的源动力。最初的想法是由于目前微信移动客户端无法给好友发送文件，除了图片、语音、视频。当然，询问了很多人之后答案是Web版可以，可是每次传文件都要去Web客户端也太麻烦了一些，于是萌发了要做一个文件传送的微信插件的想法，暂定为《微信随心传 1.0 Beta》。功能很明确，就是向好友分享文件，其他的功能就没有了。虽然功能很单一，但希望它能为更多的人提供方便。  \n\n## 微信审核\n这个是前提，只有通过审核，才能得到APP_ID；只有得到APP_ID，才能进行开发，才能在微信的附件栏里成功调用这个应用。具体方法如下：   \n\n1. 登录微信开放平台：https://open.weixin.qq.com/，注册开发者帐号；   \n2. 创建一个项目，使用微信开放平台提供的签名生成工具，生成此项目的签名信息（就是Debug Key）；   \n3. 在移动应用板块，按照网页上的向导创建移动应用，填上相关信息，等待审核通过（这个过程不会太慢，差不多第三天就会通过，运气好的话几个小时而已）；   \n一旦通过审核，会有通知，在管理中心的已通过审核部分，会看到我们创建好的应用信息，我们可以通过查看详情找到开发所需的APP_ID。   \n\n\n## 搭建项目\n从这个部分开始，就是真正编码的过程了。   \n1. 首先从官方提供的SDK Demo项目中找到libammsdk.jar，复制到我们的项目lib文件夹中，这个Jar包是实现所有功能的核心。   \n2. 修改AndroidManifest.xml文件，添加一个Activity。路径固定为包名后跟\".wxapi.WXEntryActivity\"。具体代码块如下：   \n\n```\n<activity\n            android:name=\".wxapi.WXEntryActivity\"\n            android:exported=\"true\"\n</activity>\n```\n\n上述两个Activity属性固定，不要做任何改变。但不妨碍继续添加属性，比如加一个\"android:label=\"@string/app_name\"\"，是没有关系的；    \n3. 创建第2步中被添加的Activity，该Activity必须实现IWXAPIEventHandler。这时，该类会提示我们要去Override onReq()和onResp()方法，这里我们主要是重写onReq()方法即可；   \n4. 声明一个全局的IWXAPI对象的变量，在onCreate方法中进行初始化。代码块如下：    \n\n```\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n\tsuper.onCreate(savedInstanceState);\n\tiwxapi = WXAPIFactory.createWXAPI(WXEntryActivity.this,MainActivity.APP_ID);\n\tiwxapi.handleIntent(getIntent(), this);\n}\n```\n\n**注意：iwxapi为已声明但尚未初始化的变量；**   \n5. 在onReq回调方法里，根据微信不同的响应类型分别做操作。类型我们可以通过req.getType()得到，具体代码块如下：   \n\n```\n@Override\npublic void onReq(BaseReq req) {\n\tswitch (req.getType()) {\n\tcase ConstantsAPI.COMMAND_GETMESSAGE_FROM_WX:\n\t\t// 选取文件发送\n\tcase ConstantsAPI.COMMAND_SHOWMESSAGE_FROM_WX:\n\t\t// 打开文件\n        }\n}\n```\n\n根据注释信息在相应的位置进行相应的操作即可；   \n6. 获取到文件路径后，使用下面的方法，即可发送指定的文件：\n\n```\nWXAppExtendObject wxAppExtendObject = new WXAppExtendObject();\nwxAppExtendObject.filePath = sendFile.getPath();\nWXMediaMessage msg = new WXMediaMessage();\nmsg.mediaObject = wxAppExtendObject;\nSendMessageToWX.Req req = new SendMessageToWX.Req();\nreq.transaction = getTransaction();\nreq.message = msg;\nreq.scene = SendMessageToWX.Req.WXSceneSession;\niwxapi.sendReq(req);\n```\n\n**注：sendFile是File类型的变量，是要发送的文件；**\n\n7. 找到接收到的文件的路径的方法见此：\n\n```\nWXAppExtendObject wxAppExtendObject = (WXAppExtendObject) ((((ShowMessageFromWX.Req) req).message.mediaObject));\nString filePath = wxAppExtendObject.filePath;\n```\n\n到此，获取到文件路径，可以通过该路径进行自定义的操作了。   \n**特别注意，这里的文件路径通常是微信的缓存路径，因此基本上无需考虑文件重名问题了。**","slug":"微信插件开发手记-聊天界面传送任意类型文件","published":1,"updated":"2019-07-31T04:11:26.147Z","_id":"cjyqq3tk10017fkqd9vqf65r5","comments":1,"layout":"post","photos":[],"link":"","content":"<p>项目完整源码请见：<a href=\"https://github.com/XiaoWenHan/Anytransforwechat\" target=\"_blank\" rel=\"noopener\">https://github.com/XiaoWenHan/Anytransforwechat</a></p>\n<h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><p>好，这是整篇文章唯一一个看似废话的部分，毕竟它才是整个项目得以完成并分享的源动力。最初的想法是由于目前微信移动客户端无法给好友发送文件，除了图片、语音、视频。当然，询问了很多人之后答案是Web版可以，可是每次传文件都要去Web客户端也太麻烦了一些，于是萌发了要做一个文件传送的微信插件的想法，暂定为《微信随心传 1.0 Beta》。功能很明确，就是向好友分享文件，其他的功能就没有了。虽然功能很单一，但希望它能为更多的人提供方便。  </p>\n<h2 id=\"微信审核\"><a href=\"#微信审核\" class=\"headerlink\" title=\"微信审核\"></a>微信审核</h2><p>这个是前提，只有通过审核，才能得到APP_ID；只有得到APP_ID，才能进行开发，才能在微信的附件栏里成功调用这个应用。具体方法如下：   </p>\n<ol>\n<li>登录微信开放平台：<a href=\"https://open.weixin.qq.com/，注册开发者帐号；\" target=\"_blank\" rel=\"noopener\">https://open.weixin.qq.com/，注册开发者帐号；</a>   </li>\n<li>创建一个项目，使用微信开放平台提供的签名生成工具，生成此项目的签名信息（就是Debug Key）；   </li>\n<li>在移动应用板块，按照网页上的向导创建移动应用，填上相关信息，等待审核通过（这个过程不会太慢，差不多第三天就会通过，运气好的话几个小时而已）；<br>一旦通过审核，会有通知，在管理中心的已通过审核部分，会看到我们创建好的应用信息，我们可以通过查看详情找到开发所需的APP_ID。   </li>\n</ol>\n<h2 id=\"搭建项目\"><a href=\"#搭建项目\" class=\"headerlink\" title=\"搭建项目\"></a>搭建项目</h2><p>从这个部分开始，就是真正编码的过程了。   </p>\n<ol>\n<li>首先从官方提供的SDK Demo项目中找到libammsdk.jar，复制到我们的项目lib文件夹中，这个Jar包是实现所有功能的核心。   </li>\n<li>修改AndroidManifest.xml文件，添加一个Activity。路径固定为包名后跟”.wxapi.WXEntryActivity”。具体代码块如下：   </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;activity</span><br><span class=\"line\">            android:name=&quot;.wxapi.WXEntryActivity&quot;</span><br><span class=\"line\">            android:exported=&quot;true&quot;</span><br><span class=\"line\">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>\n\n<p>上述两个Activity属性固定，不要做任何改变。但不妨碍继续添加属性，比如加一个”android:label=”@string/app_name””，是没有关系的；    </p>\n<ol start=\"3\">\n<li>创建第2步中被添加的Activity，该Activity必须实现IWXAPIEventHandler。这时，该类会提示我们要去Override onReq()和onResp()方法，这里我们主要是重写onReq()方法即可；   </li>\n<li>声明一个全局的IWXAPI对象的变量，在onCreate方法中进行初始化。代码块如下：    </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">\tsuper.onCreate(savedInstanceState);</span><br><span class=\"line\">\tiwxapi = WXAPIFactory.createWXAPI(WXEntryActivity.this,MainActivity.APP_ID);</span><br><span class=\"line\">\tiwxapi.handleIntent(getIntent(), this);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：iwxapi为已声明但尚未初始化的变量；</strong>   </p>\n<ol start=\"5\">\n<li>在onReq回调方法里，根据微信不同的响应类型分别做操作。类型我们可以通过req.getType()得到，具体代码块如下：   </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void onReq(BaseReq req) &#123;</span><br><span class=\"line\">\tswitch (req.getType()) &#123;</span><br><span class=\"line\">\tcase ConstantsAPI.COMMAND_GETMESSAGE_FROM_WX:</span><br><span class=\"line\">\t\t// 选取文件发送</span><br><span class=\"line\">\tcase ConstantsAPI.COMMAND_SHOWMESSAGE_FROM_WX:</span><br><span class=\"line\">\t\t// 打开文件</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>根据注释信息在相应的位置进行相应的操作即可；   </p>\n<ol start=\"6\">\n<li>获取到文件路径后，使用下面的方法，即可发送指定的文件：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WXAppExtendObject wxAppExtendObject = new WXAppExtendObject();</span><br><span class=\"line\">wxAppExtendObject.filePath = sendFile.getPath();</span><br><span class=\"line\">WXMediaMessage msg = new WXMediaMessage();</span><br><span class=\"line\">msg.mediaObject = wxAppExtendObject;</span><br><span class=\"line\">SendMessageToWX.Req req = new SendMessageToWX.Req();</span><br><span class=\"line\">req.transaction = getTransaction();</span><br><span class=\"line\">req.message = msg;</span><br><span class=\"line\">req.scene = SendMessageToWX.Req.WXSceneSession;</span><br><span class=\"line\">iwxapi.sendReq(req);</span><br></pre></td></tr></table></figure>\n\n<p><strong>注：sendFile是File类型的变量，是要发送的文件；</strong></p>\n<ol start=\"7\">\n<li>找到接收到的文件的路径的方法见此：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WXAppExtendObject wxAppExtendObject = (WXAppExtendObject) ((((ShowMessageFromWX.Req) req).message.mediaObject));</span><br><span class=\"line\">String filePath = wxAppExtendObject.filePath;</span><br></pre></td></tr></table></figure>\n\n<p>到此，获取到文件路径，可以通过该路径进行自定义的操作了。<br><strong>特别注意，这里的文件路径通常是微信的缓存路径，因此基本上无需考虑文件重名问题了。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p>项目完整源码请见：<a href=\"https://github.com/XiaoWenHan/Anytransforwechat\" target=\"_blank\" rel=\"noopener\">https://github.com/XiaoWenHan/Anytransforwechat</a></p>\n<h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><p>好，这是整篇文章唯一一个看似废话的部分，毕竟它才是整个项目得以完成并分享的源动力。最初的想法是由于目前微信移动客户端无法给好友发送文件，除了图片、语音、视频。当然，询问了很多人之后答案是Web版可以，可是每次传文件都要去Web客户端也太麻烦了一些，于是萌发了要做一个文件传送的微信插件的想法，暂定为《微信随心传 1.0 Beta》。功能很明确，就是向好友分享文件，其他的功能就没有了。虽然功能很单一，但希望它能为更多的人提供方便。  </p>\n<h2 id=\"微信审核\"><a href=\"#微信审核\" class=\"headerlink\" title=\"微信审核\"></a>微信审核</h2><p>这个是前提，只有通过审核，才能得到APP_ID；只有得到APP_ID，才能进行开发，才能在微信的附件栏里成功调用这个应用。具体方法如下：   </p>\n<ol>\n<li>登录微信开放平台：<a href=\"https://open.weixin.qq.com/，注册开发者帐号；\" target=\"_blank\" rel=\"noopener\">https://open.weixin.qq.com/，注册开发者帐号；</a>   </li>\n<li>创建一个项目，使用微信开放平台提供的签名生成工具，生成此项目的签名信息（就是Debug Key）；   </li>\n<li>在移动应用板块，按照网页上的向导创建移动应用，填上相关信息，等待审核通过（这个过程不会太慢，差不多第三天就会通过，运气好的话几个小时而已）；<br>一旦通过审核，会有通知，在管理中心的已通过审核部分，会看到我们创建好的应用信息，我们可以通过查看详情找到开发所需的APP_ID。   </li>\n</ol>\n<h2 id=\"搭建项目\"><a href=\"#搭建项目\" class=\"headerlink\" title=\"搭建项目\"></a>搭建项目</h2><p>从这个部分开始，就是真正编码的过程了。   </p>\n<ol>\n<li>首先从官方提供的SDK Demo项目中找到libammsdk.jar，复制到我们的项目lib文件夹中，这个Jar包是实现所有功能的核心。   </li>\n<li>修改AndroidManifest.xml文件，添加一个Activity。路径固定为包名后跟”.wxapi.WXEntryActivity”。具体代码块如下：   </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;activity</span><br><span class=\"line\">            android:name=&quot;.wxapi.WXEntryActivity&quot;</span><br><span class=\"line\">            android:exported=&quot;true&quot;</span><br><span class=\"line\">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>\n\n<p>上述两个Activity属性固定，不要做任何改变。但不妨碍继续添加属性，比如加一个”android:label=”@string/app_name””，是没有关系的；    </p>\n<ol start=\"3\">\n<li>创建第2步中被添加的Activity，该Activity必须实现IWXAPIEventHandler。这时，该类会提示我们要去Override onReq()和onResp()方法，这里我们主要是重写onReq()方法即可；   </li>\n<li>声明一个全局的IWXAPI对象的变量，在onCreate方法中进行初始化。代码块如下：    </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">\tsuper.onCreate(savedInstanceState);</span><br><span class=\"line\">\tiwxapi = WXAPIFactory.createWXAPI(WXEntryActivity.this,MainActivity.APP_ID);</span><br><span class=\"line\">\tiwxapi.handleIntent(getIntent(), this);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：iwxapi为已声明但尚未初始化的变量；</strong>   </p>\n<ol start=\"5\">\n<li>在onReq回调方法里，根据微信不同的响应类型分别做操作。类型我们可以通过req.getType()得到，具体代码块如下：   </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void onReq(BaseReq req) &#123;</span><br><span class=\"line\">\tswitch (req.getType()) &#123;</span><br><span class=\"line\">\tcase ConstantsAPI.COMMAND_GETMESSAGE_FROM_WX:</span><br><span class=\"line\">\t\t// 选取文件发送</span><br><span class=\"line\">\tcase ConstantsAPI.COMMAND_SHOWMESSAGE_FROM_WX:</span><br><span class=\"line\">\t\t// 打开文件</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>根据注释信息在相应的位置进行相应的操作即可；   </p>\n<ol start=\"6\">\n<li>获取到文件路径后，使用下面的方法，即可发送指定的文件：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WXAppExtendObject wxAppExtendObject = new WXAppExtendObject();</span><br><span class=\"line\">wxAppExtendObject.filePath = sendFile.getPath();</span><br><span class=\"line\">WXMediaMessage msg = new WXMediaMessage();</span><br><span class=\"line\">msg.mediaObject = wxAppExtendObject;</span><br><span class=\"line\">SendMessageToWX.Req req = new SendMessageToWX.Req();</span><br><span class=\"line\">req.transaction = getTransaction();</span><br><span class=\"line\">req.message = msg;</span><br><span class=\"line\">req.scene = SendMessageToWX.Req.WXSceneSession;</span><br><span class=\"line\">iwxapi.sendReq(req);</span><br></pre></td></tr></table></figure>\n\n<p><strong>注：sendFile是File类型的变量，是要发送的文件；</strong></p>\n<ol start=\"7\">\n<li>找到接收到的文件的路径的方法见此：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WXAppExtendObject wxAppExtendObject = (WXAppExtendObject) ((((ShowMessageFromWX.Req) req).message.mediaObject));</span><br><span class=\"line\">String filePath = wxAppExtendObject.filePath;</span><br></pre></td></tr></table></figure>\n\n<p>到此，获取到文件路径，可以通过该路径进行自定义的操作了。<br><strong>特别注意，这里的文件路径通常是微信的缓存路径，因此基本上无需考虑文件重名问题了。</strong></p>\n"},{"title":"Mapbox 地图SDK极速集成指导","date":"2016-12-22T03:42:14.000Z","_content":"这次跟各位分享一个地图的SDK。先说说为什么拿Mapbox来用吧。  \n首先就是——国际化。当需求要显示国外的地理位置信息的时候，通常使用的是Google Map。但是Google Map目前需要手机带有完整的Google Play套件才行，但是基本上所有的国内上市的手机都把Google Play套件阉割了。然后就是偏移量，从目前来看，Mapbox的路网和卫星照片是重合的，而Google Map则是有一定的偏移，尤其是在中国。最后呢，Mapbox的集成方式实在是太简单了。不过呢，说了这么多优点，再说一个缺点。就是Mapbox的卫星照片略慢，尤其是中国，某些地方还停留在几年前的样子，这个以年为单位，一点都不夸张。  \n如果你需要做海外的地图定位，个人认为，Mapbox可作为首选。  \n下面说一下具体的集成方法。  \n首先，需要去官网注册一个账号，这里附上官网地址链接：  \nhttps://www.mapbox.com/  \n注册完成后，进入网页Studio界面，我们会轻松找到Access Token。我们后面会用到。  \n然后新建一个Android项目，这里推荐targetAPI<23，但是必须大于15。  \n在app目录下的build.gradle文件中添加下面的内容，用来导入依赖库。  \n\n```\nrepositories{mavenCentral()}\ncompile('com.mapbox.mapboxsdk:mapbox-android-sdk:4.2.0@aar') {\n    transitive = true\n}\n```  \n\n这里注意版本，虽然复制粘贴过去没有问题，但是依赖库的版本还在不断更新，也许下一秒就发布4.2.1或者其他什么版本，所以这个还是有必要直接去官网上看一下。网址在此：  \nhttps://www.mapbox.com/android-sdk/   \n下一步我们在布局文件中添加地图控件，很简单，最简易的写法可以像下面这样：  \n\n```\n<com.mapbox.mapboxsdk.maps.MapView\n    android:id=\"@+id/mapview\"\n    android:layout_width=\"fill_parent\"\n    android:layout_height=\"fill_parent\" />\n```\n\n当然，我们需要显示一个自己比较熟悉的位置，而且还要能够看得足够清晰，可以写成像下面这样：  \n\n```\n<com.mapbox.mapboxsdk.maps.MapView\n    android:id=\"@+id/mapview\"\n    android:layout_width=\"fill_parent\"\n    android:layout_height=\"fill_parent\"\n    mapbox:center_latitude=\"39.069\"\n    mapbox:center_longitude=\"117.221\"\n    mapbox:style_url=\"@string/style_satellite_streets\"\n    mapbox:zoom=\"15\" />\n```\n\n这里提醒一下，在xml最上方加上命名空间，否则会报错：  \n\n```\nxmlns:mapbox=\"http://schemas.android.com/apk/res-auto\"  \n```        \n\n这样做，可以同时显示路网和卫星照片，虽然卫星照片可能比较过时，但是确实很清楚。而且可以稍微移动一下，看看国外的风景，情况就大不一样了。  \n下一步需要在Activity中完成初始化等操作，在onCreate()方法中添加如下代码：  \n\n```\nsetContentView(R.layout.activity_main);\nMapboxAccountManager.start(this, getString(R.string.access_token));\nmv = (MapView) findViewById(R.id.mapview);\nmv.onCreate(savedInstanceState);\nmv.getMapAsync(new OnMapReadyCallback() {\n    @Override\n    public void onMapReady(MapboxMap mapboxMap) {\n\n    }\n});\n```\n\n当然，这只是个例子。  \n这里要注意的就是必须在Activity中的各个生命周期中添加相应的方法，比如onResume()中，需要加上：  \n\n```\nmv.onResume();\n```\n\n其他生命周期回调类似。  \n最后在AndroidManifest.xml中做好相关权限声明：  \n\n```\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n<uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" />\n<uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />\n<uses-permission android:name=\"android.permission.INTERNET\" />\n```\n\n还有一个Service：  \n\n```\n<service android:name=\"com.mapbox.mapboxsdk.telemetry.TelemetryService\" />\n```\n\n该Service在Application节点内。  \n好了，运行一下吧，一切顺利的话就可以看到地图的显示了。    \n\n下面附上完整的项目源码：  \nhttps://github.com/XiaoWenHan/MapboxAndroidDemo  ","source":"_posts/Mapbox 地图SDK极速集成指导.md","raw":"---\ntitle: Mapbox 地图SDK极速集成指导\ndate: 2016-12-22 11:42:14\ntags: Android\ncategories: 编程世界\n---\n这次跟各位分享一个地图的SDK。先说说为什么拿Mapbox来用吧。  \n首先就是——国际化。当需求要显示国外的地理位置信息的时候，通常使用的是Google Map。但是Google Map目前需要手机带有完整的Google Play套件才行，但是基本上所有的国内上市的手机都把Google Play套件阉割了。然后就是偏移量，从目前来看，Mapbox的路网和卫星照片是重合的，而Google Map则是有一定的偏移，尤其是在中国。最后呢，Mapbox的集成方式实在是太简单了。不过呢，说了这么多优点，再说一个缺点。就是Mapbox的卫星照片略慢，尤其是中国，某些地方还停留在几年前的样子，这个以年为单位，一点都不夸张。  \n如果你需要做海外的地图定位，个人认为，Mapbox可作为首选。  \n下面说一下具体的集成方法。  \n首先，需要去官网注册一个账号，这里附上官网地址链接：  \nhttps://www.mapbox.com/  \n注册完成后，进入网页Studio界面，我们会轻松找到Access Token。我们后面会用到。  \n然后新建一个Android项目，这里推荐targetAPI<23，但是必须大于15。  \n在app目录下的build.gradle文件中添加下面的内容，用来导入依赖库。  \n\n```\nrepositories{mavenCentral()}\ncompile('com.mapbox.mapboxsdk:mapbox-android-sdk:4.2.0@aar') {\n    transitive = true\n}\n```  \n\n这里注意版本，虽然复制粘贴过去没有问题，但是依赖库的版本还在不断更新，也许下一秒就发布4.2.1或者其他什么版本，所以这个还是有必要直接去官网上看一下。网址在此：  \nhttps://www.mapbox.com/android-sdk/   \n下一步我们在布局文件中添加地图控件，很简单，最简易的写法可以像下面这样：  \n\n```\n<com.mapbox.mapboxsdk.maps.MapView\n    android:id=\"@+id/mapview\"\n    android:layout_width=\"fill_parent\"\n    android:layout_height=\"fill_parent\" />\n```\n\n当然，我们需要显示一个自己比较熟悉的位置，而且还要能够看得足够清晰，可以写成像下面这样：  \n\n```\n<com.mapbox.mapboxsdk.maps.MapView\n    android:id=\"@+id/mapview\"\n    android:layout_width=\"fill_parent\"\n    android:layout_height=\"fill_parent\"\n    mapbox:center_latitude=\"39.069\"\n    mapbox:center_longitude=\"117.221\"\n    mapbox:style_url=\"@string/style_satellite_streets\"\n    mapbox:zoom=\"15\" />\n```\n\n这里提醒一下，在xml最上方加上命名空间，否则会报错：  \n\n```\nxmlns:mapbox=\"http://schemas.android.com/apk/res-auto\"  \n```        \n\n这样做，可以同时显示路网和卫星照片，虽然卫星照片可能比较过时，但是确实很清楚。而且可以稍微移动一下，看看国外的风景，情况就大不一样了。  \n下一步需要在Activity中完成初始化等操作，在onCreate()方法中添加如下代码：  \n\n```\nsetContentView(R.layout.activity_main);\nMapboxAccountManager.start(this, getString(R.string.access_token));\nmv = (MapView) findViewById(R.id.mapview);\nmv.onCreate(savedInstanceState);\nmv.getMapAsync(new OnMapReadyCallback() {\n    @Override\n    public void onMapReady(MapboxMap mapboxMap) {\n\n    }\n});\n```\n\n当然，这只是个例子。  \n这里要注意的就是必须在Activity中的各个生命周期中添加相应的方法，比如onResume()中，需要加上：  \n\n```\nmv.onResume();\n```\n\n其他生命周期回调类似。  \n最后在AndroidManifest.xml中做好相关权限声明：  \n\n```\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n<uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" />\n<uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />\n<uses-permission android:name=\"android.permission.INTERNET\" />\n```\n\n还有一个Service：  \n\n```\n<service android:name=\"com.mapbox.mapboxsdk.telemetry.TelemetryService\" />\n```\n\n该Service在Application节点内。  \n好了，运行一下吧，一切顺利的话就可以看到地图的显示了。    \n\n下面附上完整的项目源码：  \nhttps://github.com/XiaoWenHan/MapboxAndroidDemo  ","slug":"Mapbox 地图SDK极速集成指导","published":1,"updated":"2019-07-31T04:10:58.593Z","_id":"cjyqq3tk30019fkqd9lol6cgf","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这次跟各位分享一个地图的SDK。先说说为什么拿Mapbox来用吧。<br>首先就是——国际化。当需求要显示国外的地理位置信息的时候，通常使用的是Google Map。但是Google Map目前需要手机带有完整的Google Play套件才行，但是基本上所有的国内上市的手机都把Google Play套件阉割了。然后就是偏移量，从目前来看，Mapbox的路网和卫星照片是重合的，而Google Map则是有一定的偏移，尤其是在中国。最后呢，Mapbox的集成方式实在是太简单了。不过呢，说了这么多优点，再说一个缺点。就是Mapbox的卫星照片略慢，尤其是中国，某些地方还停留在几年前的样子，这个以年为单位，一点都不夸张。<br>如果你需要做海外的地图定位，个人认为，Mapbox可作为首选。<br>下面说一下具体的集成方法。<br>首先，需要去官网注册一个账号，这里附上官网地址链接：<br><a href=\"https://www.mapbox.com/\" target=\"_blank\" rel=\"noopener\">https://www.mapbox.com/</a><br>注册完成后，进入网页Studio界面，我们会轻松找到Access Token。我们后面会用到。<br>然后新建一个Android项目，这里推荐targetAPI&lt;23，但是必须大于15。<br>在app目录下的build.gradle文件中添加下面的内容，用来导入依赖库。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repositories&#123;mavenCentral()&#125;</span><br><span class=\"line\">compile(&apos;com.mapbox.mapboxsdk:mapbox-android-sdk:4.2.0@aar&apos;) &#123;</span><br><span class=\"line\">    transitive = true</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\">这里注意版本，虽然复制粘贴过去没有问题，但是依赖库的版本还在不断更新，也许下一秒就发布4.2.1或者其他什么版本，所以这个还是有必要直接去官网上看一下。网址在此：  </span><br><span class=\"line\">https://www.mapbox.com/android-sdk/   </span><br><span class=\"line\">下一步我们在布局文件中添加地图控件，很简单，最简易的写法可以像下面这样：</span><br></pre></td></tr></table></figure>\n\n<p>&lt;com.mapbox.mapboxsdk.maps.MapView<br>    android:id=”@+id/mapview”<br>    android:layout_width=”fill_parent”<br>    android:layout_height=”fill_parent” /&gt;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">当然，我们需要显示一个自己比较熟悉的位置，而且还要能够看得足够清晰，可以写成像下面这样：</span><br></pre></td></tr></table></figure>\n\n<p>&lt;com.mapbox.mapboxsdk.maps.MapView<br>    android:id=”@+id/mapview”<br>    android:layout_width=”fill_parent”<br>    android:layout_height=”fill_parent”<br>    mapbox:center_latitude=”39.069”<br>    mapbox:center_longitude=”117.221”<br>    mapbox:style_url=”@string/style_satellite_streets”<br>    mapbox:zoom=”15” /&gt;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这里提醒一下，在xml最上方加上命名空间，否则会报错：</span><br></pre></td></tr></table></figure>\n\n<p>xmlns:mapbox=”<a href=\"http://schemas.android.com/apk/res-auto&quot;\" target=\"_blank\" rel=\"noopener\">http://schemas.android.com/apk/res-auto&quot;</a>  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这样做，可以同时显示路网和卫星照片，虽然卫星照片可能比较过时，但是确实很清楚。而且可以稍微移动一下，看看国外的风景，情况就大不一样了。  </span><br><span class=\"line\">下一步需要在Activity中完成初始化等操作，在onCreate()方法中添加如下代码：</span><br></pre></td></tr></table></figure>\n\n<p>setContentView(R.layout.activity_main);<br>MapboxAccountManager.start(this, getString(R.string.access_token));<br>mv = (MapView) findViewById(R.id.mapview);<br>mv.onCreate(savedInstanceState);<br>mv.getMapAsync(new OnMapReadyCallback() {<br>    @Override<br>    public void onMapReady(MapboxMap mapboxMap) {</p>\n<pre><code>}</code></pre><p>});</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">当然，这只是个例子。  </span><br><span class=\"line\">这里要注意的就是必须在Activity中的各个生命周期中添加相应的方法，比如onResume()中，需要加上：</span><br></pre></td></tr></table></figure>\n\n<p>mv.onResume();</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">其他生命周期回调类似。  </span><br><span class=\"line\">最后在AndroidManifest.xml中做好相关权限声明：</span><br></pre></td></tr></table></figure>\n\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\">\n<uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\">\n<uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\">\n<uses-permission android:name=\"android.permission.INTERNET\">\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">还有一个Service：</span><br></pre></td></tr></table></figure>\n\n<service android:name=\"com.mapbox.mapboxsdk.telemetry.TelemetryService\">\n```\n\n<p>该Service在Application节点内。<br>好了，运行一下吧，一切顺利的话就可以看到地图的显示了。    </p>\n<p>下面附上完整的项目源码：<br><a href=\"https://github.com/XiaoWenHan/MapboxAndroidDemo\" target=\"_blank\" rel=\"noopener\">https://github.com/XiaoWenHan/MapboxAndroidDemo</a>  </p>\n</service></uses-permission></uses-permission></uses-permission></uses-permission>","site":{"data":{}},"excerpt":"","more":"<p>这次跟各位分享一个地图的SDK。先说说为什么拿Mapbox来用吧。<br>首先就是——国际化。当需求要显示国外的地理位置信息的时候，通常使用的是Google Map。但是Google Map目前需要手机带有完整的Google Play套件才行，但是基本上所有的国内上市的手机都把Google Play套件阉割了。然后就是偏移量，从目前来看，Mapbox的路网和卫星照片是重合的，而Google Map则是有一定的偏移，尤其是在中国。最后呢，Mapbox的集成方式实在是太简单了。不过呢，说了这么多优点，再说一个缺点。就是Mapbox的卫星照片略慢，尤其是中国，某些地方还停留在几年前的样子，这个以年为单位，一点都不夸张。<br>如果你需要做海外的地图定位，个人认为，Mapbox可作为首选。<br>下面说一下具体的集成方法。<br>首先，需要去官网注册一个账号，这里附上官网地址链接：<br><a href=\"https://www.mapbox.com/\" target=\"_blank\" rel=\"noopener\">https://www.mapbox.com/</a><br>注册完成后，进入网页Studio界面，我们会轻松找到Access Token。我们后面会用到。<br>然后新建一个Android项目，这里推荐targetAPI&lt;23，但是必须大于15。<br>在app目录下的build.gradle文件中添加下面的内容，用来导入依赖库。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repositories&#123;mavenCentral()&#125;</span><br><span class=\"line\">compile(&apos;com.mapbox.mapboxsdk:mapbox-android-sdk:4.2.0@aar&apos;) &#123;</span><br><span class=\"line\">    transitive = true</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\">这里注意版本，虽然复制粘贴过去没有问题，但是依赖库的版本还在不断更新，也许下一秒就发布4.2.1或者其他什么版本，所以这个还是有必要直接去官网上看一下。网址在此：  </span><br><span class=\"line\">https://www.mapbox.com/android-sdk/   </span><br><span class=\"line\">下一步我们在布局文件中添加地图控件，很简单，最简易的写法可以像下面这样：</span><br></pre></td></tr></table></figure>\n\n<p>&lt;com.mapbox.mapboxsdk.maps.MapView<br>    android:id=”@+id/mapview”<br>    android:layout_width=”fill_parent”<br>    android:layout_height=”fill_parent” /&gt;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">当然，我们需要显示一个自己比较熟悉的位置，而且还要能够看得足够清晰，可以写成像下面这样：</span><br></pre></td></tr></table></figure>\n\n<p>&lt;com.mapbox.mapboxsdk.maps.MapView<br>    android:id=”@+id/mapview”<br>    android:layout_width=”fill_parent”<br>    android:layout_height=”fill_parent”<br>    mapbox:center_latitude=”39.069”<br>    mapbox:center_longitude=”117.221”<br>    mapbox:style_url=”@string/style_satellite_streets”<br>    mapbox:zoom=”15” /&gt;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这里提醒一下，在xml最上方加上命名空间，否则会报错：</span><br></pre></td></tr></table></figure>\n\n<p>xmlns:mapbox=”<a href=\"http://schemas.android.com/apk/res-auto&quot;\" target=\"_blank\" rel=\"noopener\">http://schemas.android.com/apk/res-auto&quot;</a>  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这样做，可以同时显示路网和卫星照片，虽然卫星照片可能比较过时，但是确实很清楚。而且可以稍微移动一下，看看国外的风景，情况就大不一样了。  </span><br><span class=\"line\">下一步需要在Activity中完成初始化等操作，在onCreate()方法中添加如下代码：</span><br></pre></td></tr></table></figure>\n\n<p>setContentView(R.layout.activity_main);<br>MapboxAccountManager.start(this, getString(R.string.access_token));<br>mv = (MapView) findViewById(R.id.mapview);<br>mv.onCreate(savedInstanceState);<br>mv.getMapAsync(new OnMapReadyCallback() {<br>    @Override<br>    public void onMapReady(MapboxMap mapboxMap) {</p>\n<pre><code>}</code></pre><p>});</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">当然，这只是个例子。  </span><br><span class=\"line\">这里要注意的就是必须在Activity中的各个生命周期中添加相应的方法，比如onResume()中，需要加上：</span><br></pre></td></tr></table></figure>\n\n<p>mv.onResume();</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">其他生命周期回调类似。  </span><br><span class=\"line\">最后在AndroidManifest.xml中做好相关权限声明：</span><br></pre></td></tr></table></figure>\n\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\">\n<uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\">\n<uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\">\n<uses-permission android:name=\"android.permission.INTERNET\">\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">还有一个Service：</span><br></pre></td></tr></table></figure>\n\n<service android:name=\"com.mapbox.mapboxsdk.telemetry.TelemetryService\">\n```\n\n<p>该Service在Application节点内。<br>好了，运行一下吧，一切顺利的话就可以看到地图的显示了。    </p>\n<p>下面附上完整的项目源码：<br><a href=\"https://github.com/XiaoWenHan/MapboxAndroidDemo\" target=\"_blank\" rel=\"noopener\">https://github.com/XiaoWenHan/MapboxAndroidDemo</a>  </p>\n</service></uses-permission></uses-permission></uses-permission></uses-permission>"},{"title":"搭建React Native环境的几个Tips","date":"2016-11-08T00:09:47.000Z","_content":"\n博主最近在研究跨平台开发，打算好好研究一下React Native这个比较被大家熟知的玩意。  \n昨天进行了环境搭建和初步的学习，感觉上手还算快。在这里，把一些已经发现的坑，提前告诉给各位，希望能让读者们少走一些弯路。  \n首先说一下无论是Mac，Windows，还是Linux，如果有能力，请直接去英文官网查看文档，不要看中文官网，真的有坑，稍候细说。  \n我的环境，Mac，Windows都有，先说Windows。  \nWindows环境暂且肯定是不支持开发iOS应用的哈，这个大家应该知道。然后大家按照官网文档中的步骤来就行。这里放一个链接：  \nhttps://facebook.github.io/react-native/docs/getting-started.html \n这个给大家提个醒，最好全程备梯子翻墙。  \n说下Chocolatey，比较简单的方法就是cmd里面执行语句，很快就行了，这个是前提，没有Chocolatey，就没有后面的步骤，所以不要被它卡住。   \n这里放下cmd命令：   \n```\npowershell -NoProfile -ExecutionPolicy Bypass -Command \"iex((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))\" && SET PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin  \n```\n网络畅通的话几秒钟就安装好了。   \n接下来就是Node和Python，这个按照官网的指令来就可以了。还是那句话，网络畅通的话也是很快就好了。这里可能Python慢一点，多等一下就会好。  \n再下来就是准备Android开发环境，什么SDK啊，IDE（Android Studio）啊都备好。SDK的话我建议大家，下全，如果硬盘空间足够，就做个全下载吧。   \n再下来安装React Native Cli，这一步，关掉cmd窗口，再开个新的，才能使用新的环境变量，也就是npm正常工作。重新打开cmd窗口后，还是按照官网的指引，安装React Native Cli。这一步会有命令行版的进度指示，虽然不太美观，至少还算直观。  \n再下来配置Android SDK环境变量，这一步必须配，否则再下来会报错。配置的方法依然按照官方文档走。  \n设置完环境变量之后，就可以运行了，首先cmd进入一个文件夹，这个文件夹将作为项目代码文件夹，可以新建，这个就随意了。  \n运行`react-native init AwesomeProject`后，会出现install若干包的提示，这个是正常的，而且仅当新建项目的时候会有这个步骤，日后重新运行就没有了，而且不可省略，因此这里多等待一下吧。  \n若干分钟后，进入新项目目录下执行`react-native run-android`，代码就运行起来了，和在Android Studio里面按Shift+F10（默认的Windows环境下的“运行”快捷键）的效果是一样的。这一步在首次运行时也需要下载一堆东西，日后也是无需的。  \n部署到手机上之后，按手机的菜单键，或`adb shell input keyevent 82`唤出菜单键效果，在`Dev Settings`项里面把PC端IP和端口设置好。具体方法参见：https://facebook.github.io/react-native/docs/running-on-device-android.html   \n文档里有详细的说明，当然，中文文档在部署运行上给出的向导一样贴心。   \n再来说下Mac平台。  \n到Mac平台就简单多了，还是按照官网的指示就行，没什么好特别强调的。不过这里还是要给大家提个醒，如果你看的是React Native的中文官网，那么，在安装node之后，在推荐安装里你会发现推荐安装Watchman。这个必须装，不是选装组件，是必须的，否则电脑端JS Server会报错，手机也会红屏报错，切记！  ","source":"_posts/搭建React Native环境的几个Tips.md","raw":"---\ntitle: 搭建React Native环境的几个Tips\ndate: 2016-11-08 08:09:47\ntags: React Native\ncategories: 编程世界\n---\n\n博主最近在研究跨平台开发，打算好好研究一下React Native这个比较被大家熟知的玩意。  \n昨天进行了环境搭建和初步的学习，感觉上手还算快。在这里，把一些已经发现的坑，提前告诉给各位，希望能让读者们少走一些弯路。  \n首先说一下无论是Mac，Windows，还是Linux，如果有能力，请直接去英文官网查看文档，不要看中文官网，真的有坑，稍候细说。  \n我的环境，Mac，Windows都有，先说Windows。  \nWindows环境暂且肯定是不支持开发iOS应用的哈，这个大家应该知道。然后大家按照官网文档中的步骤来就行。这里放一个链接：  \nhttps://facebook.github.io/react-native/docs/getting-started.html \n这个给大家提个醒，最好全程备梯子翻墙。  \n说下Chocolatey，比较简单的方法就是cmd里面执行语句，很快就行了，这个是前提，没有Chocolatey，就没有后面的步骤，所以不要被它卡住。   \n这里放下cmd命令：   \n```\npowershell -NoProfile -ExecutionPolicy Bypass -Command \"iex((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))\" && SET PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin  \n```\n网络畅通的话几秒钟就安装好了。   \n接下来就是Node和Python，这个按照官网的指令来就可以了。还是那句话，网络畅通的话也是很快就好了。这里可能Python慢一点，多等一下就会好。  \n再下来就是准备Android开发环境，什么SDK啊，IDE（Android Studio）啊都备好。SDK的话我建议大家，下全，如果硬盘空间足够，就做个全下载吧。   \n再下来安装React Native Cli，这一步，关掉cmd窗口，再开个新的，才能使用新的环境变量，也就是npm正常工作。重新打开cmd窗口后，还是按照官网的指引，安装React Native Cli。这一步会有命令行版的进度指示，虽然不太美观，至少还算直观。  \n再下来配置Android SDK环境变量，这一步必须配，否则再下来会报错。配置的方法依然按照官方文档走。  \n设置完环境变量之后，就可以运行了，首先cmd进入一个文件夹，这个文件夹将作为项目代码文件夹，可以新建，这个就随意了。  \n运行`react-native init AwesomeProject`后，会出现install若干包的提示，这个是正常的，而且仅当新建项目的时候会有这个步骤，日后重新运行就没有了，而且不可省略，因此这里多等待一下吧。  \n若干分钟后，进入新项目目录下执行`react-native run-android`，代码就运行起来了，和在Android Studio里面按Shift+F10（默认的Windows环境下的“运行”快捷键）的效果是一样的。这一步在首次运行时也需要下载一堆东西，日后也是无需的。  \n部署到手机上之后，按手机的菜单键，或`adb shell input keyevent 82`唤出菜单键效果，在`Dev Settings`项里面把PC端IP和端口设置好。具体方法参见：https://facebook.github.io/react-native/docs/running-on-device-android.html   \n文档里有详细的说明，当然，中文文档在部署运行上给出的向导一样贴心。   \n再来说下Mac平台。  \n到Mac平台就简单多了，还是按照官网的指示就行，没什么好特别强调的。不过这里还是要给大家提个醒，如果你看的是React Native的中文官网，那么，在安装node之后，在推荐安装里你会发现推荐安装Watchman。这个必须装，不是选装组件，是必须的，否则电脑端JS Server会报错，手机也会红屏报错，切记！  ","slug":"搭建React Native环境的几个Tips","published":1,"updated":"2019-07-31T04:11:40.351Z","_id":"cjyqq3tk4001bfkqdu7kthr6w","comments":1,"layout":"post","photos":[],"link":"","content":"<p>博主最近在研究跨平台开发，打算好好研究一下React Native这个比较被大家熟知的玩意。<br>昨天进行了环境搭建和初步的学习，感觉上手还算快。在这里，把一些已经发现的坑，提前告诉给各位，希望能让读者们少走一些弯路。<br>首先说一下无论是Mac，Windows，还是Linux，如果有能力，请直接去英文官网查看文档，不要看中文官网，真的有坑，稍候细说。<br>我的环境，Mac，Windows都有，先说Windows。<br>Windows环境暂且肯定是不支持开发iOS应用的哈，这个大家应该知道。然后大家按照官网文档中的步骤来就行。这里放一个链接：<br><a href=\"https://facebook.github.io/react-native/docs/getting-started.html\" target=\"_blank\" rel=\"noopener\">https://facebook.github.io/react-native/docs/getting-started.html</a><br>这个给大家提个醒，最好全程备梯子翻墙。<br>说下Chocolatey，比较简单的方法就是cmd里面执行语句，很快就行了，这个是前提，没有Chocolatey，就没有后面的步骤，所以不要被它卡住。<br>这里放下cmd命令：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">powershell -NoProfile -ExecutionPolicy Bypass -Command &quot;iex((new-object net.webclient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))&quot; &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin</span><br></pre></td></tr></table></figure>\n\n<p>网络畅通的话几秒钟就安装好了。<br>接下来就是Node和Python，这个按照官网的指令来就可以了。还是那句话，网络畅通的话也是很快就好了。这里可能Python慢一点，多等一下就会好。<br>再下来就是准备Android开发环境，什么SDK啊，IDE（Android Studio）啊都备好。SDK的话我建议大家，下全，如果硬盘空间足够，就做个全下载吧。<br>再下来安装React Native Cli，这一步，关掉cmd窗口，再开个新的，才能使用新的环境变量，也就是npm正常工作。重新打开cmd窗口后，还是按照官网的指引，安装React Native Cli。这一步会有命令行版的进度指示，虽然不太美观，至少还算直观。<br>再下来配置Android SDK环境变量，这一步必须配，否则再下来会报错。配置的方法依然按照官方文档走。<br>设置完环境变量之后，就可以运行了，首先cmd进入一个文件夹，这个文件夹将作为项目代码文件夹，可以新建，这个就随意了。<br>运行<code>react-native init AwesomeProject</code>后，会出现install若干包的提示，这个是正常的，而且仅当新建项目的时候会有这个步骤，日后重新运行就没有了，而且不可省略，因此这里多等待一下吧。<br>若干分钟后，进入新项目目录下执行<code>react-native run-android</code>，代码就运行起来了，和在Android Studio里面按Shift+F10（默认的Windows环境下的“运行”快捷键）的效果是一样的。这一步在首次运行时也需要下载一堆东西，日后也是无需的。<br>部署到手机上之后，按手机的菜单键，或<code>adb shell input keyevent 82</code>唤出菜单键效果，在<code>Dev Settings</code>项里面把PC端IP和端口设置好。具体方法参见：<a href=\"https://facebook.github.io/react-native/docs/running-on-device-android.html\" target=\"_blank\" rel=\"noopener\">https://facebook.github.io/react-native/docs/running-on-device-android.html</a><br>文档里有详细的说明，当然，中文文档在部署运行上给出的向导一样贴心。<br>再来说下Mac平台。<br>到Mac平台就简单多了，还是按照官网的指示就行，没什么好特别强调的。不过这里还是要给大家提个醒，如果你看的是React Native的中文官网，那么，在安装node之后，在推荐安装里你会发现推荐安装Watchman。这个必须装，不是选装组件，是必须的，否则电脑端JS Server会报错，手机也会红屏报错，切记！  </p>\n","site":{"data":{}},"excerpt":"","more":"<p>博主最近在研究跨平台开发，打算好好研究一下React Native这个比较被大家熟知的玩意。<br>昨天进行了环境搭建和初步的学习，感觉上手还算快。在这里，把一些已经发现的坑，提前告诉给各位，希望能让读者们少走一些弯路。<br>首先说一下无论是Mac，Windows，还是Linux，如果有能力，请直接去英文官网查看文档，不要看中文官网，真的有坑，稍候细说。<br>我的环境，Mac，Windows都有，先说Windows。<br>Windows环境暂且肯定是不支持开发iOS应用的哈，这个大家应该知道。然后大家按照官网文档中的步骤来就行。这里放一个链接：<br><a href=\"https://facebook.github.io/react-native/docs/getting-started.html\" target=\"_blank\" rel=\"noopener\">https://facebook.github.io/react-native/docs/getting-started.html</a><br>这个给大家提个醒，最好全程备梯子翻墙。<br>说下Chocolatey，比较简单的方法就是cmd里面执行语句，很快就行了，这个是前提，没有Chocolatey，就没有后面的步骤，所以不要被它卡住。<br>这里放下cmd命令：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">powershell -NoProfile -ExecutionPolicy Bypass -Command &quot;iex((new-object net.webclient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))&quot; &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin</span><br></pre></td></tr></table></figure>\n\n<p>网络畅通的话几秒钟就安装好了。<br>接下来就是Node和Python，这个按照官网的指令来就可以了。还是那句话，网络畅通的话也是很快就好了。这里可能Python慢一点，多等一下就会好。<br>再下来就是准备Android开发环境，什么SDK啊，IDE（Android Studio）啊都备好。SDK的话我建议大家，下全，如果硬盘空间足够，就做个全下载吧。<br>再下来安装React Native Cli，这一步，关掉cmd窗口，再开个新的，才能使用新的环境变量，也就是npm正常工作。重新打开cmd窗口后，还是按照官网的指引，安装React Native Cli。这一步会有命令行版的进度指示，虽然不太美观，至少还算直观。<br>再下来配置Android SDK环境变量，这一步必须配，否则再下来会报错。配置的方法依然按照官方文档走。<br>设置完环境变量之后，就可以运行了，首先cmd进入一个文件夹，这个文件夹将作为项目代码文件夹，可以新建，这个就随意了。<br>运行<code>react-native init AwesomeProject</code>后，会出现install若干包的提示，这个是正常的，而且仅当新建项目的时候会有这个步骤，日后重新运行就没有了，而且不可省略，因此这里多等待一下吧。<br>若干分钟后，进入新项目目录下执行<code>react-native run-android</code>，代码就运行起来了，和在Android Studio里面按Shift+F10（默认的Windows环境下的“运行”快捷键）的效果是一样的。这一步在首次运行时也需要下载一堆东西，日后也是无需的。<br>部署到手机上之后，按手机的菜单键，或<code>adb shell input keyevent 82</code>唤出菜单键效果，在<code>Dev Settings</code>项里面把PC端IP和端口设置好。具体方法参见：<a href=\"https://facebook.github.io/react-native/docs/running-on-device-android.html\" target=\"_blank\" rel=\"noopener\">https://facebook.github.io/react-native/docs/running-on-device-android.html</a><br>文档里有详细的说明，当然，中文文档在部署运行上给出的向导一样贴心。<br>再来说下Mac平台。<br>到Mac平台就简单多了，还是按照官网的指示就行，没什么好特别强调的。不过这里还是要给大家提个醒，如果你看的是React Native的中文官网，那么，在安装node之后，在推荐安装里你会发现推荐安装Watchman。这个必须装，不是选装组件，是必须的，否则电脑端JS Server会报错，手机也会红屏报错，切记！  </p>\n"},{"title":"简易实现脸部贴近自动关屏","date":"2016-10-16T09:48:47.000Z","_content":"\n博主最近工作超忙，好久没来更新博客了，真是抱歉。  \n今天分享给大家一个简易的Demo，实现的效果是：当手机屏幕贴近脸部时，屏幕自动熄灭。当然，由于是简单的思路，所以这里所谓的“熄灭”并非真的关闭屏幕，而是简单地使用一张黑色背景的图片遮盖住所有显示的内容，看上去像是关闭了屏幕而已。   \n整个实现思路较为简单，首先启动监听器，监听距离变化，一旦距离到达一定的接近值的时候，就关掉屏幕；反之则打开屏幕。这里的学问仅在于一个距离传感器返回给我们的距离值，这个距离值会在相应的监听器回调里面获取。   \n不多说了，直接上代码：  \n需要添加的权限：   \n\n```\n<uses-permission Android:name=\"android.permission.DEVICE_POWER\"/>\n<uses-permission android:name=\"android.permission.WAKE_LOCK\"/>\n```\n\nJava主逻辑：   \n\n```\nimport android.app.Activity;  \nimport android.content.Context;  \nimport android.hardware.Sensor;  \nimport android.hardware.SensorEvent;  \nimport android.hardware.SensorEventListener;  \nimport android.hardware.SensorManager;  \nimport android.os.Bundle;  \nimport android.os.PowerManager;  \nimport android.util.Log;  \nimport android.view.Menu;  \nimport android.view.View;  \n    \npublic class SensorTest extends Activity implements SensorEventListener{  \n    public static final String TAG = \"SensorTest\";  \n        \n    //调用距离传感器，控制屏幕  \n    private SensorManager mManager;//传感器管理对象  \n    //屏幕开关  \n    private PowerManager localPowerManager = null;//电源管理对象  \n    private PowerManager.WakeLock localWakeLock = null;//电源锁  \n        \n    @Override  \n    protected void onCreate(Bundle savedInstanceState) {  \n        super.onCreate(savedInstanceState);  \n        setContentView(R.layout.sensor);  \n            \n        mManager = (SensorManager)getSystemService(Context.SENSOR_SERVICE);  \n        //获取系统服务POWER_SERVICE，返回一个PowerManager对象  \n        localPowerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);  \n        //获取PowerManager.WakeLock对象,后面的参数|表示同时传入两个值,最后的是LogCat里用的Tag   \n        localWakeLock = this.localPowerManager.newWakeLock(32, \"MyPower\");//第一个参数为电源锁级别，第二个是日志tag  \n    }  \n        \n    public void onResume(){  \n        super.onResume();  \n        mManager.registerListener(this, mManager.getDefaultSensor(Sensor.TYPE_PROXIMITY),// 距离感应器  \n                SensorManager.SENSOR_DELAY_NORMAL);//注册传感器，第一个参数为距离监听器，第二个是传感器类型，第三个是延迟类型  \n    }  \n        \n    public void onStop(){  \n        super.onStop();  \n        Log.d(TAG,\"on stop\");  \n    }  \n        \n    public void onDestroy(){  \n        super.onDestroy();  \n        Log.d(TAG,\"on destroy\");  \n        if(mManager != null){  \n            localWakeLock.release();//释放电源锁，如果不释放finish这个acitivity后仍然会有自动锁屏的效果，不信可以试一试  \n            mManager.unregisterListener(this);//注销传感器监听  \n        }  \n    }  \n    \n    @Override  \n    public void onAccuracyChanged(Sensor sensor, int accuracy) {  \n        // TODO Auto-generated method stub  \n            \n    }  \n    \n    @Override  \n    public void onSensorChanged(SensorEvent event) {  \n        // TODO Auto-generated method stub  \n        float[] its = event.values;  \n        //Log.d(TAG,\"its array:\"+its+\"sensor type :\"+event.sensor.getType()+\" proximity type:\"+Sensor.TYPE_PROXIMITY);  \n        if (its != null && event.sensor.getType() == Sensor.TYPE_PROXIMITY) {  \n    \n            System.out.println(\"its[0]:\" + its[0]);  \n    \n            //经过测试，当手贴近距离感应器的时候its[0]返回值为0.0，当手离开时返回1.0  \n            if (its[0] == 0.0) {// 贴近手机  \n    \n                System.out.println(\"hands up\");  \n                Log.d(TAG,\"hands up in calling activity\");  \n                if (localWakeLock.isHeld()) {  \n                    return;  \n                } else{  \n    \n                    localWakeLock.acquire();// 申请设备电源锁  \n                }  \n            } else {// 远离手机  \n    \n                System.out.println(\"hands moved\");  \n                Log.d(TAG,\"hands moved in calling activity\");  \n                if (localWakeLock.isHeld()) {  \n                    return;  \n                } else{  \n                    localWakeLock.setReferenceCounted(false);  \n                    localWakeLock.release(); // 释放设备电源锁  \n                }  \n            }  \n        }  \n    }  \n    \n}  \n```\n\n这里特别注意：  \n1、在退出的时候务必释放，否则有可能在其他正常使用的情况下仍然会黑屏；  \n2、注意非空检查，在某些未配备距离传感器的机型上，会报空。","source":"_posts/简易实现脸部贴近自动关屏.md","raw":"---\ntitle: 简易实现脸部贴近自动关屏\ndate: 2016-10-16 17:48:47\ntags: Android\ncategories: 编程世界\n---\n\n博主最近工作超忙，好久没来更新博客了，真是抱歉。  \n今天分享给大家一个简易的Demo，实现的效果是：当手机屏幕贴近脸部时，屏幕自动熄灭。当然，由于是简单的思路，所以这里所谓的“熄灭”并非真的关闭屏幕，而是简单地使用一张黑色背景的图片遮盖住所有显示的内容，看上去像是关闭了屏幕而已。   \n整个实现思路较为简单，首先启动监听器，监听距离变化，一旦距离到达一定的接近值的时候，就关掉屏幕；反之则打开屏幕。这里的学问仅在于一个距离传感器返回给我们的距离值，这个距离值会在相应的监听器回调里面获取。   \n不多说了，直接上代码：  \n需要添加的权限：   \n\n```\n<uses-permission Android:name=\"android.permission.DEVICE_POWER\"/>\n<uses-permission android:name=\"android.permission.WAKE_LOCK\"/>\n```\n\nJava主逻辑：   \n\n```\nimport android.app.Activity;  \nimport android.content.Context;  \nimport android.hardware.Sensor;  \nimport android.hardware.SensorEvent;  \nimport android.hardware.SensorEventListener;  \nimport android.hardware.SensorManager;  \nimport android.os.Bundle;  \nimport android.os.PowerManager;  \nimport android.util.Log;  \nimport android.view.Menu;  \nimport android.view.View;  \n    \npublic class SensorTest extends Activity implements SensorEventListener{  \n    public static final String TAG = \"SensorTest\";  \n        \n    //调用距离传感器，控制屏幕  \n    private SensorManager mManager;//传感器管理对象  \n    //屏幕开关  \n    private PowerManager localPowerManager = null;//电源管理对象  \n    private PowerManager.WakeLock localWakeLock = null;//电源锁  \n        \n    @Override  \n    protected void onCreate(Bundle savedInstanceState) {  \n        super.onCreate(savedInstanceState);  \n        setContentView(R.layout.sensor);  \n            \n        mManager = (SensorManager)getSystemService(Context.SENSOR_SERVICE);  \n        //获取系统服务POWER_SERVICE，返回一个PowerManager对象  \n        localPowerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);  \n        //获取PowerManager.WakeLock对象,后面的参数|表示同时传入两个值,最后的是LogCat里用的Tag   \n        localWakeLock = this.localPowerManager.newWakeLock(32, \"MyPower\");//第一个参数为电源锁级别，第二个是日志tag  \n    }  \n        \n    public void onResume(){  \n        super.onResume();  \n        mManager.registerListener(this, mManager.getDefaultSensor(Sensor.TYPE_PROXIMITY),// 距离感应器  \n                SensorManager.SENSOR_DELAY_NORMAL);//注册传感器，第一个参数为距离监听器，第二个是传感器类型，第三个是延迟类型  \n    }  \n        \n    public void onStop(){  \n        super.onStop();  \n        Log.d(TAG,\"on stop\");  \n    }  \n        \n    public void onDestroy(){  \n        super.onDestroy();  \n        Log.d(TAG,\"on destroy\");  \n        if(mManager != null){  \n            localWakeLock.release();//释放电源锁，如果不释放finish这个acitivity后仍然会有自动锁屏的效果，不信可以试一试  \n            mManager.unregisterListener(this);//注销传感器监听  \n        }  \n    }  \n    \n    @Override  \n    public void onAccuracyChanged(Sensor sensor, int accuracy) {  \n        // TODO Auto-generated method stub  \n            \n    }  \n    \n    @Override  \n    public void onSensorChanged(SensorEvent event) {  \n        // TODO Auto-generated method stub  \n        float[] its = event.values;  \n        //Log.d(TAG,\"its array:\"+its+\"sensor type :\"+event.sensor.getType()+\" proximity type:\"+Sensor.TYPE_PROXIMITY);  \n        if (its != null && event.sensor.getType() == Sensor.TYPE_PROXIMITY) {  \n    \n            System.out.println(\"its[0]:\" + its[0]);  \n    \n            //经过测试，当手贴近距离感应器的时候its[0]返回值为0.0，当手离开时返回1.0  \n            if (its[0] == 0.0) {// 贴近手机  \n    \n                System.out.println(\"hands up\");  \n                Log.d(TAG,\"hands up in calling activity\");  \n                if (localWakeLock.isHeld()) {  \n                    return;  \n                } else{  \n    \n                    localWakeLock.acquire();// 申请设备电源锁  \n                }  \n            } else {// 远离手机  \n    \n                System.out.println(\"hands moved\");  \n                Log.d(TAG,\"hands moved in calling activity\");  \n                if (localWakeLock.isHeld()) {  \n                    return;  \n                } else{  \n                    localWakeLock.setReferenceCounted(false);  \n                    localWakeLock.release(); // 释放设备电源锁  \n                }  \n            }  \n        }  \n    }  \n    \n}  \n```\n\n这里特别注意：  \n1、在退出的时候务必释放，否则有可能在其他正常使用的情况下仍然会黑屏；  \n2、注意非空检查，在某些未配备距离传感器的机型上，会报空。","slug":"简易实现脸部贴近自动关屏","published":1,"updated":"2019-07-31T04:11:43.998Z","_id":"cjyqq3tk6001dfkqdal71ot6h","comments":1,"layout":"post","photos":[],"link":"","content":"<p>博主最近工作超忙，好久没来更新博客了，真是抱歉。<br>今天分享给大家一个简易的Demo，实现的效果是：当手机屏幕贴近脸部时，屏幕自动熄灭。当然，由于是简单的思路，所以这里所谓的“熄灭”并非真的关闭屏幕，而是简单地使用一张黑色背景的图片遮盖住所有显示的内容，看上去像是关闭了屏幕而已。<br>整个实现思路较为简单，首先启动监听器，监听距离变化，一旦距离到达一定的接近值的时候，就关掉屏幕；反之则打开屏幕。这里的学问仅在于一个距离传感器返回给我们的距离值，这个距离值会在相应的监听器回调里面获取。<br>不多说了，直接上代码：<br>需要添加的权限：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-permission Android:name=&quot;android.permission.DEVICE_POWER&quot;/&gt;</span><br><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<p>Java主逻辑：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import android.app.Activity;  </span><br><span class=\"line\">import android.content.Context;  </span><br><span class=\"line\">import android.hardware.Sensor;  </span><br><span class=\"line\">import android.hardware.SensorEvent;  </span><br><span class=\"line\">import android.hardware.SensorEventListener;  </span><br><span class=\"line\">import android.hardware.SensorManager;  </span><br><span class=\"line\">import android.os.Bundle;  </span><br><span class=\"line\">import android.os.PowerManager;  </span><br><span class=\"line\">import android.util.Log;  </span><br><span class=\"line\">import android.view.Menu;  </span><br><span class=\"line\">import android.view.View;  </span><br><span class=\"line\">    </span><br><span class=\"line\">public class SensorTest extends Activity implements SensorEventListener&#123;  </span><br><span class=\"line\">    public static final String TAG = &quot;SensorTest&quot;;  </span><br><span class=\"line\">        </span><br><span class=\"line\">    //调用距离传感器，控制屏幕  </span><br><span class=\"line\">    private SensorManager mManager;//传感器管理对象  </span><br><span class=\"line\">    //屏幕开关  </span><br><span class=\"line\">    private PowerManager localPowerManager = null;//电源管理对象  </span><br><span class=\"line\">    private PowerManager.WakeLock localWakeLock = null;//电源锁  </span><br><span class=\"line\">        </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    protected void onCreate(Bundle savedInstanceState) &#123;  </span><br><span class=\"line\">        super.onCreate(savedInstanceState);  </span><br><span class=\"line\">        setContentView(R.layout.sensor);  </span><br><span class=\"line\">            </span><br><span class=\"line\">        mManager = (SensorManager)getSystemService(Context.SENSOR_SERVICE);  </span><br><span class=\"line\">        //获取系统服务POWER_SERVICE，返回一个PowerManager对象  </span><br><span class=\"line\">        localPowerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);  </span><br><span class=\"line\">        //获取PowerManager.WakeLock对象,后面的参数|表示同时传入两个值,最后的是LogCat里用的Tag   </span><br><span class=\"line\">        localWakeLock = this.localPowerManager.newWakeLock(32, &quot;MyPower&quot;);//第一个参数为电源锁级别，第二个是日志tag  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">        </span><br><span class=\"line\">    public void onResume()&#123;  </span><br><span class=\"line\">        super.onResume();  </span><br><span class=\"line\">        mManager.registerListener(this, mManager.getDefaultSensor(Sensor.TYPE_PROXIMITY),// 距离感应器  </span><br><span class=\"line\">                SensorManager.SENSOR_DELAY_NORMAL);//注册传感器，第一个参数为距离监听器，第二个是传感器类型，第三个是延迟类型  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">        </span><br><span class=\"line\">    public void onStop()&#123;  </span><br><span class=\"line\">        super.onStop();  </span><br><span class=\"line\">        Log.d(TAG,&quot;on stop&quot;);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">        </span><br><span class=\"line\">    public void onDestroy()&#123;  </span><br><span class=\"line\">        super.onDestroy();  </span><br><span class=\"line\">        Log.d(TAG,&quot;on destroy&quot;);  </span><br><span class=\"line\">        if(mManager != null)&#123;  </span><br><span class=\"line\">            localWakeLock.release();//释放电源锁，如果不释放finish这个acitivity后仍然会有自动锁屏的效果，不信可以试一试  </span><br><span class=\"line\">            mManager.unregisterListener(this);//注销传感器监听  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public void onAccuracyChanged(Sensor sensor, int accuracy) &#123;  </span><br><span class=\"line\">        // TODO Auto-generated method stub  </span><br><span class=\"line\">            </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public void onSensorChanged(SensorEvent event) &#123;  </span><br><span class=\"line\">        // TODO Auto-generated method stub  </span><br><span class=\"line\">        float[] its = event.values;  </span><br><span class=\"line\">        //Log.d(TAG,&quot;its array:&quot;+its+&quot;sensor type :&quot;+event.sensor.getType()+&quot; proximity type:&quot;+Sensor.TYPE_PROXIMITY);  </span><br><span class=\"line\">        if (its != null &amp;&amp; event.sensor.getType() == Sensor.TYPE_PROXIMITY) &#123;  </span><br><span class=\"line\">    </span><br><span class=\"line\">            System.out.println(&quot;its[0]:&quot; + its[0]);  </span><br><span class=\"line\">    </span><br><span class=\"line\">            //经过测试，当手贴近距离感应器的时候its[0]返回值为0.0，当手离开时返回1.0  </span><br><span class=\"line\">            if (its[0] == 0.0) &#123;// 贴近手机  </span><br><span class=\"line\">    </span><br><span class=\"line\">                System.out.println(&quot;hands up&quot;);  </span><br><span class=\"line\">                Log.d(TAG,&quot;hands up in calling activity&quot;);  </span><br><span class=\"line\">                if (localWakeLock.isHeld()) &#123;  </span><br><span class=\"line\">                    return;  </span><br><span class=\"line\">                &#125; else&#123;  </span><br><span class=\"line\">    </span><br><span class=\"line\">                    localWakeLock.acquire();// 申请设备电源锁  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125; else &#123;// 远离手机  </span><br><span class=\"line\">    </span><br><span class=\"line\">                System.out.println(&quot;hands moved&quot;);  </span><br><span class=\"line\">                Log.d(TAG,&quot;hands moved in calling activity&quot;);  </span><br><span class=\"line\">                if (localWakeLock.isHeld()) &#123;  </span><br><span class=\"line\">                    return;  </span><br><span class=\"line\">                &#125; else&#123;  </span><br><span class=\"line\">                    localWakeLock.setReferenceCounted(false);  </span><br><span class=\"line\">                    localWakeLock.release(); // 释放设备电源锁  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里特别注意：<br>1、在退出的时候务必释放，否则有可能在其他正常使用的情况下仍然会黑屏；<br>2、注意非空检查，在某些未配备距离传感器的机型上，会报空。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>博主最近工作超忙，好久没来更新博客了，真是抱歉。<br>今天分享给大家一个简易的Demo，实现的效果是：当手机屏幕贴近脸部时，屏幕自动熄灭。当然，由于是简单的思路，所以这里所谓的“熄灭”并非真的关闭屏幕，而是简单地使用一张黑色背景的图片遮盖住所有显示的内容，看上去像是关闭了屏幕而已。<br>整个实现思路较为简单，首先启动监听器，监听距离变化，一旦距离到达一定的接近值的时候，就关掉屏幕；反之则打开屏幕。这里的学问仅在于一个距离传感器返回给我们的距离值，这个距离值会在相应的监听器回调里面获取。<br>不多说了，直接上代码：<br>需要添加的权限：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;uses-permission Android:name=&quot;android.permission.DEVICE_POWER&quot;/&gt;</span><br><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<p>Java主逻辑：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import android.app.Activity;  </span><br><span class=\"line\">import android.content.Context;  </span><br><span class=\"line\">import android.hardware.Sensor;  </span><br><span class=\"line\">import android.hardware.SensorEvent;  </span><br><span class=\"line\">import android.hardware.SensorEventListener;  </span><br><span class=\"line\">import android.hardware.SensorManager;  </span><br><span class=\"line\">import android.os.Bundle;  </span><br><span class=\"line\">import android.os.PowerManager;  </span><br><span class=\"line\">import android.util.Log;  </span><br><span class=\"line\">import android.view.Menu;  </span><br><span class=\"line\">import android.view.View;  </span><br><span class=\"line\">    </span><br><span class=\"line\">public class SensorTest extends Activity implements SensorEventListener&#123;  </span><br><span class=\"line\">    public static final String TAG = &quot;SensorTest&quot;;  </span><br><span class=\"line\">        </span><br><span class=\"line\">    //调用距离传感器，控制屏幕  </span><br><span class=\"line\">    private SensorManager mManager;//传感器管理对象  </span><br><span class=\"line\">    //屏幕开关  </span><br><span class=\"line\">    private PowerManager localPowerManager = null;//电源管理对象  </span><br><span class=\"line\">    private PowerManager.WakeLock localWakeLock = null;//电源锁  </span><br><span class=\"line\">        </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    protected void onCreate(Bundle savedInstanceState) &#123;  </span><br><span class=\"line\">        super.onCreate(savedInstanceState);  </span><br><span class=\"line\">        setContentView(R.layout.sensor);  </span><br><span class=\"line\">            </span><br><span class=\"line\">        mManager = (SensorManager)getSystemService(Context.SENSOR_SERVICE);  </span><br><span class=\"line\">        //获取系统服务POWER_SERVICE，返回一个PowerManager对象  </span><br><span class=\"line\">        localPowerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);  </span><br><span class=\"line\">        //获取PowerManager.WakeLock对象,后面的参数|表示同时传入两个值,最后的是LogCat里用的Tag   </span><br><span class=\"line\">        localWakeLock = this.localPowerManager.newWakeLock(32, &quot;MyPower&quot;);//第一个参数为电源锁级别，第二个是日志tag  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">        </span><br><span class=\"line\">    public void onResume()&#123;  </span><br><span class=\"line\">        super.onResume();  </span><br><span class=\"line\">        mManager.registerListener(this, mManager.getDefaultSensor(Sensor.TYPE_PROXIMITY),// 距离感应器  </span><br><span class=\"line\">                SensorManager.SENSOR_DELAY_NORMAL);//注册传感器，第一个参数为距离监听器，第二个是传感器类型，第三个是延迟类型  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">        </span><br><span class=\"line\">    public void onStop()&#123;  </span><br><span class=\"line\">        super.onStop();  </span><br><span class=\"line\">        Log.d(TAG,&quot;on stop&quot;);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">        </span><br><span class=\"line\">    public void onDestroy()&#123;  </span><br><span class=\"line\">        super.onDestroy();  </span><br><span class=\"line\">        Log.d(TAG,&quot;on destroy&quot;);  </span><br><span class=\"line\">        if(mManager != null)&#123;  </span><br><span class=\"line\">            localWakeLock.release();//释放电源锁，如果不释放finish这个acitivity后仍然会有自动锁屏的效果，不信可以试一试  </span><br><span class=\"line\">            mManager.unregisterListener(this);//注销传感器监听  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public void onAccuracyChanged(Sensor sensor, int accuracy) &#123;  </span><br><span class=\"line\">        // TODO Auto-generated method stub  </span><br><span class=\"line\">            </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    @Override  </span><br><span class=\"line\">    public void onSensorChanged(SensorEvent event) &#123;  </span><br><span class=\"line\">        // TODO Auto-generated method stub  </span><br><span class=\"line\">        float[] its = event.values;  </span><br><span class=\"line\">        //Log.d(TAG,&quot;its array:&quot;+its+&quot;sensor type :&quot;+event.sensor.getType()+&quot; proximity type:&quot;+Sensor.TYPE_PROXIMITY);  </span><br><span class=\"line\">        if (its != null &amp;&amp; event.sensor.getType() == Sensor.TYPE_PROXIMITY) &#123;  </span><br><span class=\"line\">    </span><br><span class=\"line\">            System.out.println(&quot;its[0]:&quot; + its[0]);  </span><br><span class=\"line\">    </span><br><span class=\"line\">            //经过测试，当手贴近距离感应器的时候its[0]返回值为0.0，当手离开时返回1.0  </span><br><span class=\"line\">            if (its[0] == 0.0) &#123;// 贴近手机  </span><br><span class=\"line\">    </span><br><span class=\"line\">                System.out.println(&quot;hands up&quot;);  </span><br><span class=\"line\">                Log.d(TAG,&quot;hands up in calling activity&quot;);  </span><br><span class=\"line\">                if (localWakeLock.isHeld()) &#123;  </span><br><span class=\"line\">                    return;  </span><br><span class=\"line\">                &#125; else&#123;  </span><br><span class=\"line\">    </span><br><span class=\"line\">                    localWakeLock.acquire();// 申请设备电源锁  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125; else &#123;// 远离手机  </span><br><span class=\"line\">    </span><br><span class=\"line\">                System.out.println(&quot;hands moved&quot;);  </span><br><span class=\"line\">                Log.d(TAG,&quot;hands moved in calling activity&quot;);  </span><br><span class=\"line\">                if (localWakeLock.isHeld()) &#123;  </span><br><span class=\"line\">                    return;  </span><br><span class=\"line\">                &#125; else&#123;  </span><br><span class=\"line\">                    localWakeLock.setReferenceCounted(false);  </span><br><span class=\"line\">                    localWakeLock.release(); // 释放设备电源锁  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里特别注意：<br>1、在退出的时候务必释放，否则有可能在其他正常使用的情况下仍然会黑屏；<br>2、注意非空检查，在某些未配备距离传感器的机型上，会报空。</p>\n"},{"title":"粮草先行——Android折叠屏开发技术点（一）","date":"2019-01-30T06:58:37.000Z","_content":"最近有关折叠屏产品的新闻层出不穷，各家手机厂商也分别慢慢地亮出了自家的产品。然而市场上的一些APP仍然没有很好地适配这样的设备，显示不正常和应用重启的状况时有发生。因此，我会用接下来的几篇文章来点出有关折叠屏开发中的一些需要注意的地方。  \n今天我们先来说一下**生命周期**，这是广大开发者特别需要注意的一点。  \n首先我们来看一下测试代码：  \n```\npublic class MainActivity extends AppCompatActivity {\n\n    private final String TAG = \"MainActivity\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Log.d(TAG, \"onCreate\");\n    }\n\n    @Override\n    protected void onStart() {\n        super.onStart();\n        Log.d(TAG, \"onStart\");\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        Log.d(TAG, \"onResume\");\n    }\n\n    @Override\n    protected void onPause() {\n        super.onPause();\n        Log.d(TAG, \"onPause\");\n    }\n\n    @Override\n    protected void onStop() {\n        super.onStop();\n        Log.d(TAG, \"onStop\");\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        Log.d(TAG, \"onDestroy\");\n    }\n\n    @Override\n    protected void onRestart() {\n        super.onRestart();\n        Log.d(TAG, \"onRestart\");\n    }\n\n    @Override\n    protected void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        Log.d(TAG, \"onSaveInstanceState\");\n    }\n\n    @Override\n    protected void onRestoreInstanceState(Bundle savedInstanceState) {\n        super.onRestoreInstanceState(savedInstanceState);\n        Log.d(TAG, \"onRestoreInstanceState\");\n    }\n\n    @Override\n    public void onConfigurationChanged(Configuration newConfig) {\n        super.onConfigurationChanged(newConfig);\n        Log.d(TAG, \"onConfigurationChanged\");\n    }\n\n}\n```\n我在每一个生命周期和恢复现场的回调方法中都加了Logcat输出，我们来看一下切换屏幕时APP的具体表现。\n>2019-01-30 11:19:00.216 30205-30205/com.example.helloworld D/MainActivity: onPause  \n2019-01-30 11:19:00.221 30205-30205/com.example.helloworld D/MainActivity: onSaveInstanceState  \n2019-01-30 11:19:00.227 30205-30205/com.example.helloworld D/MainActivity: onStop  \n2019-01-30 11:19:00.228 30205-30205/com.example.helloworld D/MainActivity: onDestroy  \n2019-01-30 11:19:00.325 30205-30205/com.example.helloworld D/MainActivity: onCreate  \n2019-01-30 11:19:00.326 30205-30205/com.example.helloworld D/MainActivity: hashcode is 89642980  \n2019-01-30 11:19:00.327 30205-30205/com.example.helloworld D/MainActivity: onStart  \n2019-01-30 11:19:00.328 30205-30205/com.example.helloworld D/MainActivity: onRestoreInstanceState  \n2019-01-30 11:19:00.331 30205-30205/com.example.helloworld D/MainActivity: onResume  \n\n我们可以看到，**默认情形下，Activity在屏幕尺寸发生改变的时候也随之重启了。** 和改变屏幕Orientation的行为有几分相像。  \n此时我们面临两个选择：\n1. 重启APP以适应屏幕改变；  \n2. 手动处理数据，避免APP重启。  \n\n对于第一种情况，我们一般在回调onSaveInstanceState()方法中保存数据，并在onCreate()或onRestoreInstanceState()回调方法中取回保存的数据用于恢复现场。  \n然而，并非在所有情况下都需要完整地重启APP来适应屏幕改变，和改变屏幕方向一样，我们只需要在Androidmanifest.xml中相应的Activity声明中加入相应的属性值即可。此处，需要添加：  \n```\nandroid:configChanges=\"screenSize|smallestScreenSize|screenLayout\"\n```\n添加好之后再次运行APP并反复改变屏幕大小，此时的生命周期回调顺序变为：\n>2019-01-30 11:13:02.217 29276-29276/com.example.helloworld D/MainActivity: onCreate  \n2019-01-30 11:13:02.219 29276-29276/com.example.helloworld D/MainActivity: onStart  \n2019-01-30 11:13:02.223 29276-29276/com.example.helloworld D/MainActivity: onResume  \n2019-01-30 11:13:05.289 29276-29276/com.example.helloworld D/MainActivity: onConfigurationChanged  \n\n可见，此时Activity并没有销毁重建，而是只回调了onConfigurationChanged()方法。在某些情况下，可用此办法避免APP重启。  \n那么，上述三个属性值各代表什么意思呢，详见下表：  \n\n| 属性值 | 含义 |\n| ----- | ---- |\n|screenSize|当前可用屏幕尺寸发生了变化。它表示当前可用尺寸相对于当前纵横比的变化，因此会在用户在横向与纵向之间切换时发生变化。 不过，如果您的应用面向 API 级别 12 或更低级别，则 Activity 始终会自行处理此配置变更（即便是在 Android 3.2 或更高版本的设备上运行，此配置变更也不会重新启动 Activity）。|\n|smallestScreenSize|物理屏幕尺寸发生了变化。它表示与方向无关的尺寸变化，因此只有在实际物理屏幕尺寸发生变化（如切换到外部显示器）时才会变化。 对此配置的变更对应于smallestWidth 配置的变化。 不过，如果您的应用面向 API 级别 12 或更低级别，则 Activity 始终会自行处理此配置变更（即便是在 Android 3.2 或更高版本的设备上运行，此配置变更也不会重新启动 Activity）。|\n|screenLayout|屏幕布局发生了变化 — 这可能是由激活了其他显示方式所致。|\n注：上表摘自 https://developer.android.com/guide/topics/manifest/activity-element  \n如此，我们便处理完了对于折叠屏切换屏幕的优化。\n","source":"_posts/粮草先行——Android折叠屏开发技术点（一）.md","raw":"---\ntitle: 粮草先行——Android折叠屏开发技术点（一）\ndate: 2019-01-30 14:58:37\ntags: Android\ncategories: 编程世界\n---\n最近有关折叠屏产品的新闻层出不穷，各家手机厂商也分别慢慢地亮出了自家的产品。然而市场上的一些APP仍然没有很好地适配这样的设备，显示不正常和应用重启的状况时有发生。因此，我会用接下来的几篇文章来点出有关折叠屏开发中的一些需要注意的地方。  \n今天我们先来说一下**生命周期**，这是广大开发者特别需要注意的一点。  \n首先我们来看一下测试代码：  \n```\npublic class MainActivity extends AppCompatActivity {\n\n    private final String TAG = \"MainActivity\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Log.d(TAG, \"onCreate\");\n    }\n\n    @Override\n    protected void onStart() {\n        super.onStart();\n        Log.d(TAG, \"onStart\");\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        Log.d(TAG, \"onResume\");\n    }\n\n    @Override\n    protected void onPause() {\n        super.onPause();\n        Log.d(TAG, \"onPause\");\n    }\n\n    @Override\n    protected void onStop() {\n        super.onStop();\n        Log.d(TAG, \"onStop\");\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        Log.d(TAG, \"onDestroy\");\n    }\n\n    @Override\n    protected void onRestart() {\n        super.onRestart();\n        Log.d(TAG, \"onRestart\");\n    }\n\n    @Override\n    protected void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        Log.d(TAG, \"onSaveInstanceState\");\n    }\n\n    @Override\n    protected void onRestoreInstanceState(Bundle savedInstanceState) {\n        super.onRestoreInstanceState(savedInstanceState);\n        Log.d(TAG, \"onRestoreInstanceState\");\n    }\n\n    @Override\n    public void onConfigurationChanged(Configuration newConfig) {\n        super.onConfigurationChanged(newConfig);\n        Log.d(TAG, \"onConfigurationChanged\");\n    }\n\n}\n```\n我在每一个生命周期和恢复现场的回调方法中都加了Logcat输出，我们来看一下切换屏幕时APP的具体表现。\n>2019-01-30 11:19:00.216 30205-30205/com.example.helloworld D/MainActivity: onPause  \n2019-01-30 11:19:00.221 30205-30205/com.example.helloworld D/MainActivity: onSaveInstanceState  \n2019-01-30 11:19:00.227 30205-30205/com.example.helloworld D/MainActivity: onStop  \n2019-01-30 11:19:00.228 30205-30205/com.example.helloworld D/MainActivity: onDestroy  \n2019-01-30 11:19:00.325 30205-30205/com.example.helloworld D/MainActivity: onCreate  \n2019-01-30 11:19:00.326 30205-30205/com.example.helloworld D/MainActivity: hashcode is 89642980  \n2019-01-30 11:19:00.327 30205-30205/com.example.helloworld D/MainActivity: onStart  \n2019-01-30 11:19:00.328 30205-30205/com.example.helloworld D/MainActivity: onRestoreInstanceState  \n2019-01-30 11:19:00.331 30205-30205/com.example.helloworld D/MainActivity: onResume  \n\n我们可以看到，**默认情形下，Activity在屏幕尺寸发生改变的时候也随之重启了。** 和改变屏幕Orientation的行为有几分相像。  \n此时我们面临两个选择：\n1. 重启APP以适应屏幕改变；  \n2. 手动处理数据，避免APP重启。  \n\n对于第一种情况，我们一般在回调onSaveInstanceState()方法中保存数据，并在onCreate()或onRestoreInstanceState()回调方法中取回保存的数据用于恢复现场。  \n然而，并非在所有情况下都需要完整地重启APP来适应屏幕改变，和改变屏幕方向一样，我们只需要在Androidmanifest.xml中相应的Activity声明中加入相应的属性值即可。此处，需要添加：  \n```\nandroid:configChanges=\"screenSize|smallestScreenSize|screenLayout\"\n```\n添加好之后再次运行APP并反复改变屏幕大小，此时的生命周期回调顺序变为：\n>2019-01-30 11:13:02.217 29276-29276/com.example.helloworld D/MainActivity: onCreate  \n2019-01-30 11:13:02.219 29276-29276/com.example.helloworld D/MainActivity: onStart  \n2019-01-30 11:13:02.223 29276-29276/com.example.helloworld D/MainActivity: onResume  \n2019-01-30 11:13:05.289 29276-29276/com.example.helloworld D/MainActivity: onConfigurationChanged  \n\n可见，此时Activity并没有销毁重建，而是只回调了onConfigurationChanged()方法。在某些情况下，可用此办法避免APP重启。  \n那么，上述三个属性值各代表什么意思呢，详见下表：  \n\n| 属性值 | 含义 |\n| ----- | ---- |\n|screenSize|当前可用屏幕尺寸发生了变化。它表示当前可用尺寸相对于当前纵横比的变化，因此会在用户在横向与纵向之间切换时发生变化。 不过，如果您的应用面向 API 级别 12 或更低级别，则 Activity 始终会自行处理此配置变更（即便是在 Android 3.2 或更高版本的设备上运行，此配置变更也不会重新启动 Activity）。|\n|smallestScreenSize|物理屏幕尺寸发生了变化。它表示与方向无关的尺寸变化，因此只有在实际物理屏幕尺寸发生变化（如切换到外部显示器）时才会变化。 对此配置的变更对应于smallestWidth 配置的变化。 不过，如果您的应用面向 API 级别 12 或更低级别，则 Activity 始终会自行处理此配置变更（即便是在 Android 3.2 或更高版本的设备上运行，此配置变更也不会重新启动 Activity）。|\n|screenLayout|屏幕布局发生了变化 — 这可能是由激活了其他显示方式所致。|\n注：上表摘自 https://developer.android.com/guide/topics/manifest/activity-element  \n如此，我们便处理完了对于折叠屏切换屏幕的优化。\n","slug":"粮草先行——Android折叠屏开发技术点（一）","published":1,"updated":"2019-07-31T04:11:47.123Z","_id":"cjyqq3tk7001gfkqdjwcvimd0","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近有关折叠屏产品的新闻层出不穷，各家手机厂商也分别慢慢地亮出了自家的产品。然而市场上的一些APP仍然没有很好地适配这样的设备，显示不正常和应用重启的状况时有发生。因此，我会用接下来的几篇文章来点出有关折叠屏开发中的一些需要注意的地方。<br>今天我们先来说一下<strong>生命周期</strong>，这是广大开发者特别需要注意的一点。<br>首先我们来看一下测试代码：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MainActivity extends AppCompatActivity &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final String TAG = &quot;MainActivity&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        super.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        Log.d(TAG, &quot;onCreate&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onStart() &#123;</span><br><span class=\"line\">        super.onStart();</span><br><span class=\"line\">        Log.d(TAG, &quot;onStart&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onResume() &#123;</span><br><span class=\"line\">        super.onResume();</span><br><span class=\"line\">        Log.d(TAG, &quot;onResume&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onPause() &#123;</span><br><span class=\"line\">        super.onPause();</span><br><span class=\"line\">        Log.d(TAG, &quot;onPause&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onStop() &#123;</span><br><span class=\"line\">        super.onStop();</span><br><span class=\"line\">        Log.d(TAG, &quot;onStop&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onDestroy() &#123;</span><br><span class=\"line\">        super.onDestroy();</span><br><span class=\"line\">        Log.d(TAG, &quot;onDestroy&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onRestart() &#123;</span><br><span class=\"line\">        super.onRestart();</span><br><span class=\"line\">        Log.d(TAG, &quot;onRestart&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onSaveInstanceState(Bundle outState) &#123;</span><br><span class=\"line\">        super.onSaveInstanceState(outState);</span><br><span class=\"line\">        Log.d(TAG, &quot;onSaveInstanceState&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onRestoreInstanceState(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        super.onRestoreInstanceState(savedInstanceState);</span><br><span class=\"line\">        Log.d(TAG, &quot;onRestoreInstanceState&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onConfigurationChanged(Configuration newConfig) &#123;</span><br><span class=\"line\">        super.onConfigurationChanged(newConfig);</span><br><span class=\"line\">        Log.d(TAG, &quot;onConfigurationChanged&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我在每一个生命周期和恢复现场的回调方法中都加了Logcat输出，我们来看一下切换屏幕时APP的具体表现。</p>\n<blockquote>\n<p>2019-01-30 11:19:00.216 30205-30205/com.example.helloworld D/MainActivity: onPause<br>2019-01-30 11:19:00.221 30205-30205/com.example.helloworld D/MainActivity: onSaveInstanceState<br>2019-01-30 11:19:00.227 30205-30205/com.example.helloworld D/MainActivity: onStop<br>2019-01-30 11:19:00.228 30205-30205/com.example.helloworld D/MainActivity: onDestroy<br>2019-01-30 11:19:00.325 30205-30205/com.example.helloworld D/MainActivity: onCreate<br>2019-01-30 11:19:00.326 30205-30205/com.example.helloworld D/MainActivity: hashcode is 89642980<br>2019-01-30 11:19:00.327 30205-30205/com.example.helloworld D/MainActivity: onStart<br>2019-01-30 11:19:00.328 30205-30205/com.example.helloworld D/MainActivity: onRestoreInstanceState<br>2019-01-30 11:19:00.331 30205-30205/com.example.helloworld D/MainActivity: onResume  </p>\n</blockquote>\n<p>我们可以看到，<strong>默认情形下，Activity在屏幕尺寸发生改变的时候也随之重启了。</strong> 和改变屏幕Orientation的行为有几分相像。<br>此时我们面临两个选择：</p>\n<ol>\n<li>重启APP以适应屏幕改变；  </li>\n<li>手动处理数据，避免APP重启。  </li>\n</ol>\n<p>对于第一种情况，我们一般在回调onSaveInstanceState()方法中保存数据，并在onCreate()或onRestoreInstanceState()回调方法中取回保存的数据用于恢复现场。<br>然而，并非在所有情况下都需要完整地重启APP来适应屏幕改变，和改变屏幕方向一样，我们只需要在Androidmanifest.xml中相应的Activity声明中加入相应的属性值即可。此处，需要添加：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:configChanges=&quot;screenSize|smallestScreenSize|screenLayout&quot;</span><br></pre></td></tr></table></figure>\n\n<p>添加好之后再次运行APP并反复改变屏幕大小，此时的生命周期回调顺序变为：</p>\n<blockquote>\n<p>2019-01-30 11:13:02.217 29276-29276/com.example.helloworld D/MainActivity: onCreate<br>2019-01-30 11:13:02.219 29276-29276/com.example.helloworld D/MainActivity: onStart<br>2019-01-30 11:13:02.223 29276-29276/com.example.helloworld D/MainActivity: onResume<br>2019-01-30 11:13:05.289 29276-29276/com.example.helloworld D/MainActivity: onConfigurationChanged  </p>\n</blockquote>\n<p>可见，此时Activity并没有销毁重建，而是只回调了onConfigurationChanged()方法。在某些情况下，可用此办法避免APP重启。<br>那么，上述三个属性值各代表什么意思呢，详见下表：  </p>\n<table>\n<thead>\n<tr>\n<th>属性值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>screenSize</td>\n<td>当前可用屏幕尺寸发生了变化。它表示当前可用尺寸相对于当前纵横比的变化，因此会在用户在横向与纵向之间切换时发生变化。 不过，如果您的应用面向 API 级别 12 或更低级别，则 Activity 始终会自行处理此配置变更（即便是在 Android 3.2 或更高版本的设备上运行，此配置变更也不会重新启动 Activity）。</td>\n</tr>\n<tr>\n<td>smallestScreenSize</td>\n<td>物理屏幕尺寸发生了变化。它表示与方向无关的尺寸变化，因此只有在实际物理屏幕尺寸发生变化（如切换到外部显示器）时才会变化。 对此配置的变更对应于smallestWidth 配置的变化。 不过，如果您的应用面向 API 级别 12 或更低级别，则 Activity 始终会自行处理此配置变更（即便是在 Android 3.2 或更高版本的设备上运行，此配置变更也不会重新启动 Activity）。</td>\n</tr>\n<tr>\n<td>screenLayout</td>\n<td>屏幕布局发生了变化 — 这可能是由激活了其他显示方式所致。</td>\n</tr>\n<tr>\n<td>注：上表摘自 <a href=\"https://developer.android.com/guide/topics/manifest/activity-element\" target=\"_blank\" rel=\"noopener\">https://developer.android.com/guide/topics/manifest/activity-element</a></td>\n<td></td>\n</tr>\n<tr>\n<td>如此，我们便处理完了对于折叠屏切换屏幕的优化。</td>\n<td></td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<p>最近有关折叠屏产品的新闻层出不穷，各家手机厂商也分别慢慢地亮出了自家的产品。然而市场上的一些APP仍然没有很好地适配这样的设备，显示不正常和应用重启的状况时有发生。因此，我会用接下来的几篇文章来点出有关折叠屏开发中的一些需要注意的地方。<br>今天我们先来说一下<strong>生命周期</strong>，这是广大开发者特别需要注意的一点。<br>首先我们来看一下测试代码：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MainActivity extends AppCompatActivity &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final String TAG = &quot;MainActivity&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        super.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        Log.d(TAG, &quot;onCreate&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onStart() &#123;</span><br><span class=\"line\">        super.onStart();</span><br><span class=\"line\">        Log.d(TAG, &quot;onStart&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onResume() &#123;</span><br><span class=\"line\">        super.onResume();</span><br><span class=\"line\">        Log.d(TAG, &quot;onResume&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onPause() &#123;</span><br><span class=\"line\">        super.onPause();</span><br><span class=\"line\">        Log.d(TAG, &quot;onPause&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onStop() &#123;</span><br><span class=\"line\">        super.onStop();</span><br><span class=\"line\">        Log.d(TAG, &quot;onStop&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onDestroy() &#123;</span><br><span class=\"line\">        super.onDestroy();</span><br><span class=\"line\">        Log.d(TAG, &quot;onDestroy&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onRestart() &#123;</span><br><span class=\"line\">        super.onRestart();</span><br><span class=\"line\">        Log.d(TAG, &quot;onRestart&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onSaveInstanceState(Bundle outState) &#123;</span><br><span class=\"line\">        super.onSaveInstanceState(outState);</span><br><span class=\"line\">        Log.d(TAG, &quot;onSaveInstanceState&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void onRestoreInstanceState(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        super.onRestoreInstanceState(savedInstanceState);</span><br><span class=\"line\">        Log.d(TAG, &quot;onRestoreInstanceState&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onConfigurationChanged(Configuration newConfig) &#123;</span><br><span class=\"line\">        super.onConfigurationChanged(newConfig);</span><br><span class=\"line\">        Log.d(TAG, &quot;onConfigurationChanged&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我在每一个生命周期和恢复现场的回调方法中都加了Logcat输出，我们来看一下切换屏幕时APP的具体表现。</p>\n<blockquote>\n<p>2019-01-30 11:19:00.216 30205-30205/com.example.helloworld D/MainActivity: onPause<br>2019-01-30 11:19:00.221 30205-30205/com.example.helloworld D/MainActivity: onSaveInstanceState<br>2019-01-30 11:19:00.227 30205-30205/com.example.helloworld D/MainActivity: onStop<br>2019-01-30 11:19:00.228 30205-30205/com.example.helloworld D/MainActivity: onDestroy<br>2019-01-30 11:19:00.325 30205-30205/com.example.helloworld D/MainActivity: onCreate<br>2019-01-30 11:19:00.326 30205-30205/com.example.helloworld D/MainActivity: hashcode is 89642980<br>2019-01-30 11:19:00.327 30205-30205/com.example.helloworld D/MainActivity: onStart<br>2019-01-30 11:19:00.328 30205-30205/com.example.helloworld D/MainActivity: onRestoreInstanceState<br>2019-01-30 11:19:00.331 30205-30205/com.example.helloworld D/MainActivity: onResume  </p>\n</blockquote>\n<p>我们可以看到，<strong>默认情形下，Activity在屏幕尺寸发生改变的时候也随之重启了。</strong> 和改变屏幕Orientation的行为有几分相像。<br>此时我们面临两个选择：</p>\n<ol>\n<li>重启APP以适应屏幕改变；  </li>\n<li>手动处理数据，避免APP重启。  </li>\n</ol>\n<p>对于第一种情况，我们一般在回调onSaveInstanceState()方法中保存数据，并在onCreate()或onRestoreInstanceState()回调方法中取回保存的数据用于恢复现场。<br>然而，并非在所有情况下都需要完整地重启APP来适应屏幕改变，和改变屏幕方向一样，我们只需要在Androidmanifest.xml中相应的Activity声明中加入相应的属性值即可。此处，需要添加：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:configChanges=&quot;screenSize|smallestScreenSize|screenLayout&quot;</span><br></pre></td></tr></table></figure>\n\n<p>添加好之后再次运行APP并反复改变屏幕大小，此时的生命周期回调顺序变为：</p>\n<blockquote>\n<p>2019-01-30 11:13:02.217 29276-29276/com.example.helloworld D/MainActivity: onCreate<br>2019-01-30 11:13:02.219 29276-29276/com.example.helloworld D/MainActivity: onStart<br>2019-01-30 11:13:02.223 29276-29276/com.example.helloworld D/MainActivity: onResume<br>2019-01-30 11:13:05.289 29276-29276/com.example.helloworld D/MainActivity: onConfigurationChanged  </p>\n</blockquote>\n<p>可见，此时Activity并没有销毁重建，而是只回调了onConfigurationChanged()方法。在某些情况下，可用此办法避免APP重启。<br>那么，上述三个属性值各代表什么意思呢，详见下表：  </p>\n<table>\n<thead>\n<tr>\n<th>属性值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>screenSize</td>\n<td>当前可用屏幕尺寸发生了变化。它表示当前可用尺寸相对于当前纵横比的变化，因此会在用户在横向与纵向之间切换时发生变化。 不过，如果您的应用面向 API 级别 12 或更低级别，则 Activity 始终会自行处理此配置变更（即便是在 Android 3.2 或更高版本的设备上运行，此配置变更也不会重新启动 Activity）。</td>\n</tr>\n<tr>\n<td>smallestScreenSize</td>\n<td>物理屏幕尺寸发生了变化。它表示与方向无关的尺寸变化，因此只有在实际物理屏幕尺寸发生变化（如切换到外部显示器）时才会变化。 对此配置的变更对应于smallestWidth 配置的变化。 不过，如果您的应用面向 API 级别 12 或更低级别，则 Activity 始终会自行处理此配置变更（即便是在 Android 3.2 或更高版本的设备上运行，此配置变更也不会重新启动 Activity）。</td>\n</tr>\n<tr>\n<td>screenLayout</td>\n<td>屏幕布局发生了变化 — 这可能是由激活了其他显示方式所致。</td>\n</tr>\n<tr>\n<td>注：上表摘自 <a href=\"https://developer.android.com/guide/topics/manifest/activity-element\" target=\"_blank\" rel=\"noopener\">https://developer.android.com/guide/topics/manifest/activity-element</a></td>\n<td></td>\n</tr>\n<tr>\n<td>如此，我们便处理完了对于折叠屏切换屏幕的优化。</td>\n<td></td>\n</tr>\n</tbody></table>\n"},{"title":"粮草先行——Android折叠屏开发技术点番外篇之运行时变更处理原则","date":"2019-02-14T03:33:28.000Z","_content":"\n上一篇文章中，我们有提到Activity在屏幕尺寸发生变更时的处理方式，总共有两种：\n\n 1. 重启APP以适应屏幕改变；\n 2. 手动处理数据，避免APP重启。\n\n同样，这两种方式也同时适用于改变屏幕方向、更改系统语言、甚至输入法等等。\n因此，本文也同样**适用于改变屏幕方向等情况的处理。**\n或许你会有疑问：**我们该如何选择合适的处理方式呢？**\n我给你的答案是：**选择最合适的。**  \n这么说好像跟没说一样，别急，给大家举个例子就明白了：\n比如更改屏幕方向，由竖屏转换为横屏，如果我们只有一套布局，符合按比例缩放仍然显示正常的话，我们大可以选择第2种处理方案。但是如果我们的横竖屏布局是不同的，比如系统中的“设置”应用，那么我们选择第2种处理方案就是不合适的。\n下图：\n![横竖屏采用不同布局的样例](https://img-blog.csdnimg.cn/20190214110923934.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doMTk5MHhpYW8yMDA1,size_16,color_FFFFFF,t_70)\n这是一个典型的横竖屏分别采用不同布局的例子。\n我们确定要采取那种解决方案后，接下来很可能要面对另一个问题，就是性能瓶颈。\n根据前一篇文章的实验结果，在发生横竖屏切换的时候，Activity的生命周期通常会按照如下顺序依次执行：\n\n> D/MainActivity: onPause   \nD/MainActivity: onSaveInstanceState  \nD/MainActivity: onStop  \nD/MainActivity: onDestroy  \nD/MainActivity: onCreate  \nD/MainActivity: onStart  \nD/MainActivity: onRestoreInstanceState  \nD/MainActivity: onResume  \n\n如果我们在生命周期中做了一些繁重的工作，那么整个Activity在重启的过程中就会很慢。\n要解决这个问题，首先我们要找Fragment帮忙，因为Bundle并不是用来传递大型对象的，而且这个对象还需要序列化和反序列化，如此执行起来就更慢了。\n当然，如果你只是保存一些整型或者字符串的话，单纯使用Bundle而不借助Fragment也是可以的，但是这样的场景在实际开发中并不常见。\n要借助Fragment来中转对象，我们采用下面三步走的方式：\n\n 1. 在Fragment类中调用 setRetainInstance(true)；\n 2. 在Activity销毁时向Fragment类存入数据；\n 3. 在Activity重建后根据Tag检索Fragment，并取出之前存入的数据。\n\n下面用具体的代码片来演示：\n首先来看Fragment类：\n\n```\npublic class TestFragment extends Fragment {\n\n    private MyData data;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setRetainInstance(true);\n    }\n\n    public void setData(MyData data) {\n        this.data = data;\n    }\n\n    public MyData getData() {\n        return data;\n    }\n}\n```\n我们再来看Activity类：\n\n```\npublic class MyActivity extends Activity {\n\n    private TestFragment mTestFragment ;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main);\n        FragmentManager fm = getFragmentManager();\n        mTestFragment = (TestFragment)fm.findFragmentByTag(“test”);\n\n        if (retainedFragment == null) {\n            mTestFragment = new TestFragment ();\n            fm.beginTransaction().add(mTestFragment, “test”).commit();\n            mTestFragment.setData(restoreData());\n        }\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        mTestFragment.setData(saveData());\n    }\n}\n```\n这里还要特别注意一点：在中转对象数据时，不要传入与Activity紧密相关的对象，比如View，否则会造成内存泄漏。\n至此，就完成了对重启Activity方案的性能优化。","source":"_posts/粮草先行——Android折叠屏开发技术点番外篇之运行时变更处理原则.md","raw":"---\ntitle: 粮草先行——Android折叠屏开发技术点番外篇之运行时变更处理原则\ndate: 2019-02-14 11:33:28\ntags: Android\ncategories: 编程世界\n---\n\n上一篇文章中，我们有提到Activity在屏幕尺寸发生变更时的处理方式，总共有两种：\n\n 1. 重启APP以适应屏幕改变；\n 2. 手动处理数据，避免APP重启。\n\n同样，这两种方式也同时适用于改变屏幕方向、更改系统语言、甚至输入法等等。\n因此，本文也同样**适用于改变屏幕方向等情况的处理。**\n或许你会有疑问：**我们该如何选择合适的处理方式呢？**\n我给你的答案是：**选择最合适的。**  \n这么说好像跟没说一样，别急，给大家举个例子就明白了：\n比如更改屏幕方向，由竖屏转换为横屏，如果我们只有一套布局，符合按比例缩放仍然显示正常的话，我们大可以选择第2种处理方案。但是如果我们的横竖屏布局是不同的，比如系统中的“设置”应用，那么我们选择第2种处理方案就是不合适的。\n下图：\n![横竖屏采用不同布局的样例](https://img-blog.csdnimg.cn/20190214110923934.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doMTk5MHhpYW8yMDA1,size_16,color_FFFFFF,t_70)\n这是一个典型的横竖屏分别采用不同布局的例子。\n我们确定要采取那种解决方案后，接下来很可能要面对另一个问题，就是性能瓶颈。\n根据前一篇文章的实验结果，在发生横竖屏切换的时候，Activity的生命周期通常会按照如下顺序依次执行：\n\n> D/MainActivity: onPause   \nD/MainActivity: onSaveInstanceState  \nD/MainActivity: onStop  \nD/MainActivity: onDestroy  \nD/MainActivity: onCreate  \nD/MainActivity: onStart  \nD/MainActivity: onRestoreInstanceState  \nD/MainActivity: onResume  \n\n如果我们在生命周期中做了一些繁重的工作，那么整个Activity在重启的过程中就会很慢。\n要解决这个问题，首先我们要找Fragment帮忙，因为Bundle并不是用来传递大型对象的，而且这个对象还需要序列化和反序列化，如此执行起来就更慢了。\n当然，如果你只是保存一些整型或者字符串的话，单纯使用Bundle而不借助Fragment也是可以的，但是这样的场景在实际开发中并不常见。\n要借助Fragment来中转对象，我们采用下面三步走的方式：\n\n 1. 在Fragment类中调用 setRetainInstance(true)；\n 2. 在Activity销毁时向Fragment类存入数据；\n 3. 在Activity重建后根据Tag检索Fragment，并取出之前存入的数据。\n\n下面用具体的代码片来演示：\n首先来看Fragment类：\n\n```\npublic class TestFragment extends Fragment {\n\n    private MyData data;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setRetainInstance(true);\n    }\n\n    public void setData(MyData data) {\n        this.data = data;\n    }\n\n    public MyData getData() {\n        return data;\n    }\n}\n```\n我们再来看Activity类：\n\n```\npublic class MyActivity extends Activity {\n\n    private TestFragment mTestFragment ;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main);\n        FragmentManager fm = getFragmentManager();\n        mTestFragment = (TestFragment)fm.findFragmentByTag(“test”);\n\n        if (retainedFragment == null) {\n            mTestFragment = new TestFragment ();\n            fm.beginTransaction().add(mTestFragment, “test”).commit();\n            mTestFragment.setData(restoreData());\n        }\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        mTestFragment.setData(saveData());\n    }\n}\n```\n这里还要特别注意一点：在中转对象数据时，不要传入与Activity紧密相关的对象，比如View，否则会造成内存泄漏。\n至此，就完成了对重启Activity方案的性能优化。","slug":"粮草先行——Android折叠屏开发技术点番外篇之运行时变更处理原则","published":1,"updated":"2019-07-31T04:11:52.998Z","_id":"cjyqq3tk8001ifkqd3sisrf7b","comments":1,"layout":"post","photos":[],"link":"","content":"<p>上一篇文章中，我们有提到Activity在屏幕尺寸发生变更时的处理方式，总共有两种：</p>\n<ol>\n<li>重启APP以适应屏幕改变；</li>\n<li>手动处理数据，避免APP重启。</li>\n</ol>\n<p>同样，这两种方式也同时适用于改变屏幕方向、更改系统语言、甚至输入法等等。<br>因此，本文也同样<strong>适用于改变屏幕方向等情况的处理。</strong><br>或许你会有疑问：<strong>我们该如何选择合适的处理方式呢？</strong><br>我给你的答案是：<strong>选择最合适的。</strong><br>这么说好像跟没说一样，别急，给大家举个例子就明白了：<br>比如更改屏幕方向，由竖屏转换为横屏，如果我们只有一套布局，符合按比例缩放仍然显示正常的话，我们大可以选择第2种处理方案。但是如果我们的横竖屏布局是不同的，比如系统中的“设置”应用，那么我们选择第2种处理方案就是不合适的。<br>下图：<br><img src=\"https://img-blog.csdnimg.cn/20190214110923934.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doMTk5MHhpYW8yMDA1,size_16,color_FFFFFF,t_70\" alt=\"横竖屏采用不同布局的样例\"><br>这是一个典型的横竖屏分别采用不同布局的例子。<br>我们确定要采取那种解决方案后，接下来很可能要面对另一个问题，就是性能瓶颈。<br>根据前一篇文章的实验结果，在发生横竖屏切换的时候，Activity的生命周期通常会按照如下顺序依次执行：</p>\n<blockquote>\n<p>D/MainActivity: onPause<br>D/MainActivity: onSaveInstanceState<br>D/MainActivity: onStop<br>D/MainActivity: onDestroy<br>D/MainActivity: onCreate<br>D/MainActivity: onStart<br>D/MainActivity: onRestoreInstanceState<br>D/MainActivity: onResume  </p>\n</blockquote>\n<p>如果我们在生命周期中做了一些繁重的工作，那么整个Activity在重启的过程中就会很慢。<br>要解决这个问题，首先我们要找Fragment帮忙，因为Bundle并不是用来传递大型对象的，而且这个对象还需要序列化和反序列化，如此执行起来就更慢了。<br>当然，如果你只是保存一些整型或者字符串的话，单纯使用Bundle而不借助Fragment也是可以的，但是这样的场景在实际开发中并不常见。<br>要借助Fragment来中转对象，我们采用下面三步走的方式：</p>\n<ol>\n<li>在Fragment类中调用 setRetainInstance(true)；</li>\n<li>在Activity销毁时向Fragment类存入数据；</li>\n<li>在Activity重建后根据Tag检索Fragment，并取出之前存入的数据。</li>\n</ol>\n<p>下面用具体的代码片来演示：<br>首先来看Fragment类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestFragment extends Fragment &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private MyData data;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        super.onCreate(savedInstanceState);</span><br><span class=\"line\">        setRetainInstance(true);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setData(MyData data) &#123;</span><br><span class=\"line\">        this.data = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public MyData getData() &#123;</span><br><span class=\"line\">        return data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们再来看Activity类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyActivity extends Activity &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private TestFragment mTestFragment ;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        super.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.main);</span><br><span class=\"line\">        FragmentManager fm = getFragmentManager();</span><br><span class=\"line\">        mTestFragment = (TestFragment)fm.findFragmentByTag(“test”);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (retainedFragment == null) &#123;</span><br><span class=\"line\">            mTestFragment = new TestFragment ();</span><br><span class=\"line\">            fm.beginTransaction().add(mTestFragment, “test”).commit();</span><br><span class=\"line\">            mTestFragment.setData(restoreData());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onDestroy() &#123;</span><br><span class=\"line\">        super.onDestroy();</span><br><span class=\"line\">        mTestFragment.setData(saveData());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里还要特别注意一点：在中转对象数据时，不要传入与Activity紧密相关的对象，比如View，否则会造成内存泄漏。<br>至此，就完成了对重启Activity方案的性能优化。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>上一篇文章中，我们有提到Activity在屏幕尺寸发生变更时的处理方式，总共有两种：</p>\n<ol>\n<li>重启APP以适应屏幕改变；</li>\n<li>手动处理数据，避免APP重启。</li>\n</ol>\n<p>同样，这两种方式也同时适用于改变屏幕方向、更改系统语言、甚至输入法等等。<br>因此，本文也同样<strong>适用于改变屏幕方向等情况的处理。</strong><br>或许你会有疑问：<strong>我们该如何选择合适的处理方式呢？</strong><br>我给你的答案是：<strong>选择最合适的。</strong><br>这么说好像跟没说一样，别急，给大家举个例子就明白了：<br>比如更改屏幕方向，由竖屏转换为横屏，如果我们只有一套布局，符合按比例缩放仍然显示正常的话，我们大可以选择第2种处理方案。但是如果我们的横竖屏布局是不同的，比如系统中的“设置”应用，那么我们选择第2种处理方案就是不合适的。<br>下图：<br><img src=\"https://img-blog.csdnimg.cn/20190214110923934.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doMTk5MHhpYW8yMDA1,size_16,color_FFFFFF,t_70\" alt=\"横竖屏采用不同布局的样例\"><br>这是一个典型的横竖屏分别采用不同布局的例子。<br>我们确定要采取那种解决方案后，接下来很可能要面对另一个问题，就是性能瓶颈。<br>根据前一篇文章的实验结果，在发生横竖屏切换的时候，Activity的生命周期通常会按照如下顺序依次执行：</p>\n<blockquote>\n<p>D/MainActivity: onPause<br>D/MainActivity: onSaveInstanceState<br>D/MainActivity: onStop<br>D/MainActivity: onDestroy<br>D/MainActivity: onCreate<br>D/MainActivity: onStart<br>D/MainActivity: onRestoreInstanceState<br>D/MainActivity: onResume  </p>\n</blockquote>\n<p>如果我们在生命周期中做了一些繁重的工作，那么整个Activity在重启的过程中就会很慢。<br>要解决这个问题，首先我们要找Fragment帮忙，因为Bundle并不是用来传递大型对象的，而且这个对象还需要序列化和反序列化，如此执行起来就更慢了。<br>当然，如果你只是保存一些整型或者字符串的话，单纯使用Bundle而不借助Fragment也是可以的，但是这样的场景在实际开发中并不常见。<br>要借助Fragment来中转对象，我们采用下面三步走的方式：</p>\n<ol>\n<li>在Fragment类中调用 setRetainInstance(true)；</li>\n<li>在Activity销毁时向Fragment类存入数据；</li>\n<li>在Activity重建后根据Tag检索Fragment，并取出之前存入的数据。</li>\n</ol>\n<p>下面用具体的代码片来演示：<br>首先来看Fragment类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestFragment extends Fragment &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private MyData data;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        super.onCreate(savedInstanceState);</span><br><span class=\"line\">        setRetainInstance(true);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setData(MyData data) &#123;</span><br><span class=\"line\">        this.data = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public MyData getData() &#123;</span><br><span class=\"line\">        return data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们再来看Activity类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyActivity extends Activity &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private TestFragment mTestFragment ;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">        super.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.main);</span><br><span class=\"line\">        FragmentManager fm = getFragmentManager();</span><br><span class=\"line\">        mTestFragment = (TestFragment)fm.findFragmentByTag(“test”);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (retainedFragment == null) &#123;</span><br><span class=\"line\">            mTestFragment = new TestFragment ();</span><br><span class=\"line\">            fm.beginTransaction().add(mTestFragment, “test”).commit();</span><br><span class=\"line\">            mTestFragment.setData(restoreData());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onDestroy() &#123;</span><br><span class=\"line\">        super.onDestroy();</span><br><span class=\"line\">        mTestFragment.setData(saveData());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里还要特别注意一点：在中转对象数据时，不要传入与Activity紧密相关的对象，比如View，否则会造成内存泄漏。<br>至此，就完成了对重启Activity方案的性能优化。</p>\n"},{"title":"自定义ImageView系列 － 区域截图（上）","date":"2015-11-04T15:52:48.000Z","_content":"\n## 功能要点：\n1. 根据控件自身大小计算合适的透明正方形预览区；\n2. 截取预览区图像并按照指定的尺寸缩放，生成Bitmap对象。\n本文着重介绍上述第1个要点。\n\n博主又来更新文章啦！  \n关于ImageView呢，其实我之前接触过一些继承它来实现一些功能。比如双指缩放，单指移动之类。而最近工作中又要用到继承它来实现某些功能。借此机会好好整理一下，也分享给更多需要的朋友们！  \n使用本系列文章完成的自定义多功能ImageView可以实现微信中的头像选择的照片调整功能。而且，微信的图片调整界面会有不流畅的情况出现。而用本文中的办法是不会出现卡顿现象的。当然，这可能是机器的原因，不同的机器可能表现不同。我使用的测试机是三星的S6。  \n废话不多说，我们来讲一下如何绘制中间的透明框。  \n思路是这样的：为了更好的可移植性，首先通过获取ImageView的尺寸，获得ImageView的尺寸；然后通过该尺寸计算出控件中点和合适的正方形边长，一般是由宽和高其中最短的一者决定的；最后，将该正方形外的所有部分给一个半透明的黑色，再画出正方形的边缘即可。\n获取控件的高度不是难事，继承了ImageView后，调用getWidth()和getHeight()方法即可完成宽高的获取。   \n获取控件的中点的方法是首先获取控件所在位置的起始点，也就是左上角的x和y的绝对像素坐标点。然后与宽度和高度分别相加，就可得到控件的终止点，也就是控件右下角的x和y的绝对像素坐标点。有了这两个值，控件的中点就可以确定下来了。  \n下面再定义预览框的边长。由于这里我们要采用绝对像素值，因此需要根据控件的大小动态计算出预览框的大小。这里我要提醒各位的就是：一个正方形，只要有两个完整的x和y轴的组合坐标，就可以确定该正方形的位置了，即对角坐标。我们这里计算左上和右下的位置。  \n左上角x坐标我是采用了中点x坐标减控件起点x位置再除以8确定的。换言之，就是该值是整个预览框距离左边的距离，而又由于这是一个正方形，因此右上角的坐标也就同时确定了（中点坐标x减去左上角x坐标再乘以2）。y轴坐标也很容易了，只需用中点y坐标减去上述两个x轴坐标之差的二分之一就可以了。由此，y轴终点的坐标也可以计算出来了，即用起点y轴坐标加上两个x轴之差坐标即可。\n\n**特别注意 － 这里有坑**  \n后面我会把这部分的代码贴上，个人私心想，肯定会有人直接复制粘贴，所以……必须提醒一下各位：犹豫项目需求问题，我这里只考虑了控件高度大于控件宽度的情况，所以，诸位在复制粘贴后，务必判断一下宽高的情况，然后分情况讨论。  \n上述问题分别出现在中点和预览区边距的计算上。  \n如果这个坑的问题没看懂，没事，试一次就知道了。方法是：不要限制屏幕旋转，然后整个屏幕放这样一个ImageView，然后倒转屏幕，看看正方形会发生什么变化。  \n**祝君好运！**  \n最后，我们画正方形的边缘，再在其余的部分给定半透明黑色即可。这里就直接放代码片段了：  \n画正方形边缘：  \n\n```\nif (previewEdge != null) {\n    //上\n    canvas.drawLine(previewEdge[0], previewEdge[2], previewEdge[1], previewEdge[2], rectPaint);\n    //左\n    canvas.drawLine(previewEdge[0], previewEdge[2], previewEdge[0], previewEdge[3], rectPaint);\n    //下\n    canvas.drawLine(previewEdge[0], previewEdge[3], previewEdge[1], previewEdge[3], rectPaint);\n    //右\n    canvas.drawLine(previewEdge[1], previewEdge[2], previewEdge[1], previewEdge[3], rectPaint);\n｝\n```\n\n解释一下：该部分代码放在重写的onDraw()中。previewEdge是一个有4个int值的数组，分别代表左上和右下的x和y坐标值。稍后贴出计算部分代码。  \n填充半透明黑色：  \n\n```\n//灰色部分\ncanvas.drawRect(0, 0, previewEdge[0], myLocationEnd[1], rectBgPaint);\ncanvas.drawRect(previewEdge[0], 0, previewEdge[1], previewEdge[2], rectBgPaint);\ncanvas.drawRect(previewEdge[1], 0, myLocationEnd[0], myLocationEnd[1], rectBgPaint);\ncanvas.drawRect(previewEdge[0], previewEdge[3], previewEdge[1], myLocationEnd[1], rectBgPaint);\n```\n\n各种计算的代码片： \n\n```\n//获取控件自身起始点\nmyLocationStart = new int[2];\ngetLocationOnScreen(myLocationStart);\n//获取控件自身终止点\nmyLocationEnd = new int[2];\nmyLocationEnd[0] = getWidth() + myLocationStart[0];\nmyLocationEnd[1] = getHeight() + myLocationStart[1];\n//计算控件自身中点\nmyLocationMid = new int[2];\nmyLocationMid[0] = (myLocationStart[0] + myLocationEnd[0]) / 2;\nmyLocationMid[1] = (myLocationStart[1] + myLocationEnd[1]) / 2 - myLocationStart[1];\n//设置中间预览框边框色\nrectPaint = new Paint();\nrectPaint.setColor(Color.WHITE);\nrectPaint.setStrokeWidth(2);\nrectBgPaint = new Paint();\nrectBgPaint.setColor(getResources().getColor(R.color.photo\\_adjust\\_for\\_avator\\_bg));\n//计算中间预览边框位置\npreviewEdge = new int[4];\npreviewEdge[0] = (myLocationMid[0] - myLocationStart[0]) / 8;\npreviewEdge[1] = myLocationEnd[0] - previewEdge[0];\npreviewEdge[2] = myLocationMid[1] - ((previewEdge[1] - previewEdge[0]) / 2);\npreviewEdge[3] = myLocationMid[1] + ((previewEdge[1] - previewEdge[0]) / 2);  \n```\n\n变量的名字都很容易看懂吧，我这里就不详述了。  \n最后说一句，这个最好自己练习一下计算，印象深一些。完整的ImageView类代码将在整个系列文章的最后一篇中贴出。希望大家多多支持，谢谢！！！\n\n","source":"_posts/自定义ImageView系列 － 区域截图（上）.md","raw":"---\ntitle: 自定义ImageView系列 － 区域截图（上）\ndate: 2015-11-04 23:52:48\ntags: Android\ncategories: 编程世界\n---\n\n## 功能要点：\n1. 根据控件自身大小计算合适的透明正方形预览区；\n2. 截取预览区图像并按照指定的尺寸缩放，生成Bitmap对象。\n本文着重介绍上述第1个要点。\n\n博主又来更新文章啦！  \n关于ImageView呢，其实我之前接触过一些继承它来实现一些功能。比如双指缩放，单指移动之类。而最近工作中又要用到继承它来实现某些功能。借此机会好好整理一下，也分享给更多需要的朋友们！  \n使用本系列文章完成的自定义多功能ImageView可以实现微信中的头像选择的照片调整功能。而且，微信的图片调整界面会有不流畅的情况出现。而用本文中的办法是不会出现卡顿现象的。当然，这可能是机器的原因，不同的机器可能表现不同。我使用的测试机是三星的S6。  \n废话不多说，我们来讲一下如何绘制中间的透明框。  \n思路是这样的：为了更好的可移植性，首先通过获取ImageView的尺寸，获得ImageView的尺寸；然后通过该尺寸计算出控件中点和合适的正方形边长，一般是由宽和高其中最短的一者决定的；最后，将该正方形外的所有部分给一个半透明的黑色，再画出正方形的边缘即可。\n获取控件的高度不是难事，继承了ImageView后，调用getWidth()和getHeight()方法即可完成宽高的获取。   \n获取控件的中点的方法是首先获取控件所在位置的起始点，也就是左上角的x和y的绝对像素坐标点。然后与宽度和高度分别相加，就可得到控件的终止点，也就是控件右下角的x和y的绝对像素坐标点。有了这两个值，控件的中点就可以确定下来了。  \n下面再定义预览框的边长。由于这里我们要采用绝对像素值，因此需要根据控件的大小动态计算出预览框的大小。这里我要提醒各位的就是：一个正方形，只要有两个完整的x和y轴的组合坐标，就可以确定该正方形的位置了，即对角坐标。我们这里计算左上和右下的位置。  \n左上角x坐标我是采用了中点x坐标减控件起点x位置再除以8确定的。换言之，就是该值是整个预览框距离左边的距离，而又由于这是一个正方形，因此右上角的坐标也就同时确定了（中点坐标x减去左上角x坐标再乘以2）。y轴坐标也很容易了，只需用中点y坐标减去上述两个x轴坐标之差的二分之一就可以了。由此，y轴终点的坐标也可以计算出来了，即用起点y轴坐标加上两个x轴之差坐标即可。\n\n**特别注意 － 这里有坑**  \n后面我会把这部分的代码贴上，个人私心想，肯定会有人直接复制粘贴，所以……必须提醒一下各位：犹豫项目需求问题，我这里只考虑了控件高度大于控件宽度的情况，所以，诸位在复制粘贴后，务必判断一下宽高的情况，然后分情况讨论。  \n上述问题分别出现在中点和预览区边距的计算上。  \n如果这个坑的问题没看懂，没事，试一次就知道了。方法是：不要限制屏幕旋转，然后整个屏幕放这样一个ImageView，然后倒转屏幕，看看正方形会发生什么变化。  \n**祝君好运！**  \n最后，我们画正方形的边缘，再在其余的部分给定半透明黑色即可。这里就直接放代码片段了：  \n画正方形边缘：  \n\n```\nif (previewEdge != null) {\n    //上\n    canvas.drawLine(previewEdge[0], previewEdge[2], previewEdge[1], previewEdge[2], rectPaint);\n    //左\n    canvas.drawLine(previewEdge[0], previewEdge[2], previewEdge[0], previewEdge[3], rectPaint);\n    //下\n    canvas.drawLine(previewEdge[0], previewEdge[3], previewEdge[1], previewEdge[3], rectPaint);\n    //右\n    canvas.drawLine(previewEdge[1], previewEdge[2], previewEdge[1], previewEdge[3], rectPaint);\n｝\n```\n\n解释一下：该部分代码放在重写的onDraw()中。previewEdge是一个有4个int值的数组，分别代表左上和右下的x和y坐标值。稍后贴出计算部分代码。  \n填充半透明黑色：  \n\n```\n//灰色部分\ncanvas.drawRect(0, 0, previewEdge[0], myLocationEnd[1], rectBgPaint);\ncanvas.drawRect(previewEdge[0], 0, previewEdge[1], previewEdge[2], rectBgPaint);\ncanvas.drawRect(previewEdge[1], 0, myLocationEnd[0], myLocationEnd[1], rectBgPaint);\ncanvas.drawRect(previewEdge[0], previewEdge[3], previewEdge[1], myLocationEnd[1], rectBgPaint);\n```\n\n各种计算的代码片： \n\n```\n//获取控件自身起始点\nmyLocationStart = new int[2];\ngetLocationOnScreen(myLocationStart);\n//获取控件自身终止点\nmyLocationEnd = new int[2];\nmyLocationEnd[0] = getWidth() + myLocationStart[0];\nmyLocationEnd[1] = getHeight() + myLocationStart[1];\n//计算控件自身中点\nmyLocationMid = new int[2];\nmyLocationMid[0] = (myLocationStart[0] + myLocationEnd[0]) / 2;\nmyLocationMid[1] = (myLocationStart[1] + myLocationEnd[1]) / 2 - myLocationStart[1];\n//设置中间预览框边框色\nrectPaint = new Paint();\nrectPaint.setColor(Color.WHITE);\nrectPaint.setStrokeWidth(2);\nrectBgPaint = new Paint();\nrectBgPaint.setColor(getResources().getColor(R.color.photo\\_adjust\\_for\\_avator\\_bg));\n//计算中间预览边框位置\npreviewEdge = new int[4];\npreviewEdge[0] = (myLocationMid[0] - myLocationStart[0]) / 8;\npreviewEdge[1] = myLocationEnd[0] - previewEdge[0];\npreviewEdge[2] = myLocationMid[1] - ((previewEdge[1] - previewEdge[0]) / 2);\npreviewEdge[3] = myLocationMid[1] + ((previewEdge[1] - previewEdge[0]) / 2);  \n```\n\n变量的名字都很容易看懂吧，我这里就不详述了。  \n最后说一句，这个最好自己练习一下计算，印象深一些。完整的ImageView类代码将在整个系列文章的最后一篇中贴出。希望大家多多支持，谢谢！！！\n\n","slug":"自定义ImageView系列 － 区域截图（上）","published":1,"updated":"2019-07-31T04:11:56.584Z","_id":"cjyqq3tka001kfkqdtl28s8ww","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"功能要点：\"><a href=\"#功能要点：\" class=\"headerlink\" title=\"功能要点：\"></a>功能要点：</h2><ol>\n<li>根据控件自身大小计算合适的透明正方形预览区；</li>\n<li>截取预览区图像并按照指定的尺寸缩放，生成Bitmap对象。<br>本文着重介绍上述第1个要点。</li>\n</ol>\n<p>博主又来更新文章啦！<br>关于ImageView呢，其实我之前接触过一些继承它来实现一些功能。比如双指缩放，单指移动之类。而最近工作中又要用到继承它来实现某些功能。借此机会好好整理一下，也分享给更多需要的朋友们！<br>使用本系列文章完成的自定义多功能ImageView可以实现微信中的头像选择的照片调整功能。而且，微信的图片调整界面会有不流畅的情况出现。而用本文中的办法是不会出现卡顿现象的。当然，这可能是机器的原因，不同的机器可能表现不同。我使用的测试机是三星的S6。<br>废话不多说，我们来讲一下如何绘制中间的透明框。<br>思路是这样的：为了更好的可移植性，首先通过获取ImageView的尺寸，获得ImageView的尺寸；然后通过该尺寸计算出控件中点和合适的正方形边长，一般是由宽和高其中最短的一者决定的；最后，将该正方形外的所有部分给一个半透明的黑色，再画出正方形的边缘即可。<br>获取控件的高度不是难事，继承了ImageView后，调用getWidth()和getHeight()方法即可完成宽高的获取。<br>获取控件的中点的方法是首先获取控件所在位置的起始点，也就是左上角的x和y的绝对像素坐标点。然后与宽度和高度分别相加，就可得到控件的终止点，也就是控件右下角的x和y的绝对像素坐标点。有了这两个值，控件的中点就可以确定下来了。<br>下面再定义预览框的边长。由于这里我们要采用绝对像素值，因此需要根据控件的大小动态计算出预览框的大小。这里我要提醒各位的就是：一个正方形，只要有两个完整的x和y轴的组合坐标，就可以确定该正方形的位置了，即对角坐标。我们这里计算左上和右下的位置。<br>左上角x坐标我是采用了中点x坐标减控件起点x位置再除以8确定的。换言之，就是该值是整个预览框距离左边的距离，而又由于这是一个正方形，因此右上角的坐标也就同时确定了（中点坐标x减去左上角x坐标再乘以2）。y轴坐标也很容易了，只需用中点y坐标减去上述两个x轴坐标之差的二分之一就可以了。由此，y轴终点的坐标也可以计算出来了，即用起点y轴坐标加上两个x轴之差坐标即可。</p>\n<p><strong>特别注意 － 这里有坑</strong><br>后面我会把这部分的代码贴上，个人私心想，肯定会有人直接复制粘贴，所以……必须提醒一下各位：犹豫项目需求问题，我这里只考虑了控件高度大于控件宽度的情况，所以，诸位在复制粘贴后，务必判断一下宽高的情况，然后分情况讨论。<br>上述问题分别出现在中点和预览区边距的计算上。<br>如果这个坑的问题没看懂，没事，试一次就知道了。方法是：不要限制屏幕旋转，然后整个屏幕放这样一个ImageView，然后倒转屏幕，看看正方形会发生什么变化。<br><strong>祝君好运！</strong><br>最后，我们画正方形的边缘，再在其余的部分给定半透明黑色即可。这里就直接放代码片段了：<br>画正方形边缘：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (previewEdge != null) &#123;</span><br><span class=\"line\">    //上</span><br><span class=\"line\">    canvas.drawLine(previewEdge[0], previewEdge[2], previewEdge[1], previewEdge[2], rectPaint);</span><br><span class=\"line\">    //左</span><br><span class=\"line\">    canvas.drawLine(previewEdge[0], previewEdge[2], previewEdge[0], previewEdge[3], rectPaint);</span><br><span class=\"line\">    //下</span><br><span class=\"line\">    canvas.drawLine(previewEdge[0], previewEdge[3], previewEdge[1], previewEdge[3], rectPaint);</span><br><span class=\"line\">    //右</span><br><span class=\"line\">    canvas.drawLine(previewEdge[1], previewEdge[2], previewEdge[1], previewEdge[3], rectPaint);</span><br><span class=\"line\">｝</span><br></pre></td></tr></table></figure>\n\n<p>解释一下：该部分代码放在重写的onDraw()中。previewEdge是一个有4个int值的数组，分别代表左上和右下的x和y坐标值。稍后贴出计算部分代码。<br>填充半透明黑色：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//灰色部分</span><br><span class=\"line\">canvas.drawRect(0, 0, previewEdge[0], myLocationEnd[1], rectBgPaint);</span><br><span class=\"line\">canvas.drawRect(previewEdge[0], 0, previewEdge[1], previewEdge[2], rectBgPaint);</span><br><span class=\"line\">canvas.drawRect(previewEdge[1], 0, myLocationEnd[0], myLocationEnd[1], rectBgPaint);</span><br><span class=\"line\">canvas.drawRect(previewEdge[0], previewEdge[3], previewEdge[1], myLocationEnd[1], rectBgPaint);</span><br></pre></td></tr></table></figure>\n\n<p>各种计算的代码片： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//获取控件自身起始点</span><br><span class=\"line\">myLocationStart = new int[2];</span><br><span class=\"line\">getLocationOnScreen(myLocationStart);</span><br><span class=\"line\">//获取控件自身终止点</span><br><span class=\"line\">myLocationEnd = new int[2];</span><br><span class=\"line\">myLocationEnd[0] = getWidth() + myLocationStart[0];</span><br><span class=\"line\">myLocationEnd[1] = getHeight() + myLocationStart[1];</span><br><span class=\"line\">//计算控件自身中点</span><br><span class=\"line\">myLocationMid = new int[2];</span><br><span class=\"line\">myLocationMid[0] = (myLocationStart[0] + myLocationEnd[0]) / 2;</span><br><span class=\"line\">myLocationMid[1] = (myLocationStart[1] + myLocationEnd[1]) / 2 - myLocationStart[1];</span><br><span class=\"line\">//设置中间预览框边框色</span><br><span class=\"line\">rectPaint = new Paint();</span><br><span class=\"line\">rectPaint.setColor(Color.WHITE);</span><br><span class=\"line\">rectPaint.setStrokeWidth(2);</span><br><span class=\"line\">rectBgPaint = new Paint();</span><br><span class=\"line\">rectBgPaint.setColor(getResources().getColor(R.color.photo\\_adjust\\_for\\_avator\\_bg));</span><br><span class=\"line\">//计算中间预览边框位置</span><br><span class=\"line\">previewEdge = new int[4];</span><br><span class=\"line\">previewEdge[0] = (myLocationMid[0] - myLocationStart[0]) / 8;</span><br><span class=\"line\">previewEdge[1] = myLocationEnd[0] - previewEdge[0];</span><br><span class=\"line\">previewEdge[2] = myLocationMid[1] - ((previewEdge[1] - previewEdge[0]) / 2);</span><br><span class=\"line\">previewEdge[3] = myLocationMid[1] + ((previewEdge[1] - previewEdge[0]) / 2);</span><br></pre></td></tr></table></figure>\n\n<p>变量的名字都很容易看懂吧，我这里就不详述了。<br>最后说一句，这个最好自己练习一下计算，印象深一些。完整的ImageView类代码将在整个系列文章的最后一篇中贴出。希望大家多多支持，谢谢！！！</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"功能要点：\"><a href=\"#功能要点：\" class=\"headerlink\" title=\"功能要点：\"></a>功能要点：</h2><ol>\n<li>根据控件自身大小计算合适的透明正方形预览区；</li>\n<li>截取预览区图像并按照指定的尺寸缩放，生成Bitmap对象。<br>本文着重介绍上述第1个要点。</li>\n</ol>\n<p>博主又来更新文章啦！<br>关于ImageView呢，其实我之前接触过一些继承它来实现一些功能。比如双指缩放，单指移动之类。而最近工作中又要用到继承它来实现某些功能。借此机会好好整理一下，也分享给更多需要的朋友们！<br>使用本系列文章完成的自定义多功能ImageView可以实现微信中的头像选择的照片调整功能。而且，微信的图片调整界面会有不流畅的情况出现。而用本文中的办法是不会出现卡顿现象的。当然，这可能是机器的原因，不同的机器可能表现不同。我使用的测试机是三星的S6。<br>废话不多说，我们来讲一下如何绘制中间的透明框。<br>思路是这样的：为了更好的可移植性，首先通过获取ImageView的尺寸，获得ImageView的尺寸；然后通过该尺寸计算出控件中点和合适的正方形边长，一般是由宽和高其中最短的一者决定的；最后，将该正方形外的所有部分给一个半透明的黑色，再画出正方形的边缘即可。<br>获取控件的高度不是难事，继承了ImageView后，调用getWidth()和getHeight()方法即可完成宽高的获取。<br>获取控件的中点的方法是首先获取控件所在位置的起始点，也就是左上角的x和y的绝对像素坐标点。然后与宽度和高度分别相加，就可得到控件的终止点，也就是控件右下角的x和y的绝对像素坐标点。有了这两个值，控件的中点就可以确定下来了。<br>下面再定义预览框的边长。由于这里我们要采用绝对像素值，因此需要根据控件的大小动态计算出预览框的大小。这里我要提醒各位的就是：一个正方形，只要有两个完整的x和y轴的组合坐标，就可以确定该正方形的位置了，即对角坐标。我们这里计算左上和右下的位置。<br>左上角x坐标我是采用了中点x坐标减控件起点x位置再除以8确定的。换言之，就是该值是整个预览框距离左边的距离，而又由于这是一个正方形，因此右上角的坐标也就同时确定了（中点坐标x减去左上角x坐标再乘以2）。y轴坐标也很容易了，只需用中点y坐标减去上述两个x轴坐标之差的二分之一就可以了。由此，y轴终点的坐标也可以计算出来了，即用起点y轴坐标加上两个x轴之差坐标即可。</p>\n<p><strong>特别注意 － 这里有坑</strong><br>后面我会把这部分的代码贴上，个人私心想，肯定会有人直接复制粘贴，所以……必须提醒一下各位：犹豫项目需求问题，我这里只考虑了控件高度大于控件宽度的情况，所以，诸位在复制粘贴后，务必判断一下宽高的情况，然后分情况讨论。<br>上述问题分别出现在中点和预览区边距的计算上。<br>如果这个坑的问题没看懂，没事，试一次就知道了。方法是：不要限制屏幕旋转，然后整个屏幕放这样一个ImageView，然后倒转屏幕，看看正方形会发生什么变化。<br><strong>祝君好运！</strong><br>最后，我们画正方形的边缘，再在其余的部分给定半透明黑色即可。这里就直接放代码片段了：<br>画正方形边缘：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (previewEdge != null) &#123;</span><br><span class=\"line\">    //上</span><br><span class=\"line\">    canvas.drawLine(previewEdge[0], previewEdge[2], previewEdge[1], previewEdge[2], rectPaint);</span><br><span class=\"line\">    //左</span><br><span class=\"line\">    canvas.drawLine(previewEdge[0], previewEdge[2], previewEdge[0], previewEdge[3], rectPaint);</span><br><span class=\"line\">    //下</span><br><span class=\"line\">    canvas.drawLine(previewEdge[0], previewEdge[3], previewEdge[1], previewEdge[3], rectPaint);</span><br><span class=\"line\">    //右</span><br><span class=\"line\">    canvas.drawLine(previewEdge[1], previewEdge[2], previewEdge[1], previewEdge[3], rectPaint);</span><br><span class=\"line\">｝</span><br></pre></td></tr></table></figure>\n\n<p>解释一下：该部分代码放在重写的onDraw()中。previewEdge是一个有4个int值的数组，分别代表左上和右下的x和y坐标值。稍后贴出计算部分代码。<br>填充半透明黑色：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//灰色部分</span><br><span class=\"line\">canvas.drawRect(0, 0, previewEdge[0], myLocationEnd[1], rectBgPaint);</span><br><span class=\"line\">canvas.drawRect(previewEdge[0], 0, previewEdge[1], previewEdge[2], rectBgPaint);</span><br><span class=\"line\">canvas.drawRect(previewEdge[1], 0, myLocationEnd[0], myLocationEnd[1], rectBgPaint);</span><br><span class=\"line\">canvas.drawRect(previewEdge[0], previewEdge[3], previewEdge[1], myLocationEnd[1], rectBgPaint);</span><br></pre></td></tr></table></figure>\n\n<p>各种计算的代码片： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//获取控件自身起始点</span><br><span class=\"line\">myLocationStart = new int[2];</span><br><span class=\"line\">getLocationOnScreen(myLocationStart);</span><br><span class=\"line\">//获取控件自身终止点</span><br><span class=\"line\">myLocationEnd = new int[2];</span><br><span class=\"line\">myLocationEnd[0] = getWidth() + myLocationStart[0];</span><br><span class=\"line\">myLocationEnd[1] = getHeight() + myLocationStart[1];</span><br><span class=\"line\">//计算控件自身中点</span><br><span class=\"line\">myLocationMid = new int[2];</span><br><span class=\"line\">myLocationMid[0] = (myLocationStart[0] + myLocationEnd[0]) / 2;</span><br><span class=\"line\">myLocationMid[1] = (myLocationStart[1] + myLocationEnd[1]) / 2 - myLocationStart[1];</span><br><span class=\"line\">//设置中间预览框边框色</span><br><span class=\"line\">rectPaint = new Paint();</span><br><span class=\"line\">rectPaint.setColor(Color.WHITE);</span><br><span class=\"line\">rectPaint.setStrokeWidth(2);</span><br><span class=\"line\">rectBgPaint = new Paint();</span><br><span class=\"line\">rectBgPaint.setColor(getResources().getColor(R.color.photo\\_adjust\\_for\\_avator\\_bg));</span><br><span class=\"line\">//计算中间预览边框位置</span><br><span class=\"line\">previewEdge = new int[4];</span><br><span class=\"line\">previewEdge[0] = (myLocationMid[0] - myLocationStart[0]) / 8;</span><br><span class=\"line\">previewEdge[1] = myLocationEnd[0] - previewEdge[0];</span><br><span class=\"line\">previewEdge[2] = myLocationMid[1] - ((previewEdge[1] - previewEdge[0]) / 2);</span><br><span class=\"line\">previewEdge[3] = myLocationMid[1] + ((previewEdge[1] - previewEdge[0]) / 2);</span><br></pre></td></tr></table></figure>\n\n<p>变量的名字都很容易看懂吧，我这里就不详述了。<br>最后说一句，这个最好自己练习一下计算，印象深一些。完整的ImageView类代码将在整个系列文章的最后一篇中贴出。希望大家多多支持，谢谢！！！</p>\n"},{"title":"粮草先行——Android折叠屏开发技术点（二）","date":"2019-02-20T09:56:10.000Z","_content":"\n继该系列的第一篇和番外篇之后，今天我们来聊一聊多窗口开发的注意事项。实际上，与其说“多窗口开发”，不如说让我们的APP**适应多窗口模式**。  \n可能有朋友会问，为什么要提到多窗口模式呢？  \n这是因为：\n\n1. 折叠屏在展开后的屏幕会变大，而变大带来的变化就是多窗口运行；  \n2. 多窗口模式在很早之前就已经被Google官方支持，提供了相应的API，现在也到了该了解一下的时候了；\n3. 避免我们辛辛苦苦开发好的APP，翻车在多窗口的沟里；\n4. 虽然在Android Q中，多窗口模式很可能将成为默认行为，但要兼容之前的版本，我们仍然需要做一些事情。  \n\n首先我们来看一下如果我们什么都不做，切换多窗口时，会发生什么呢？仍然从生命周期的角度来解读：  \n\n*失去焦点（未做兼容处理）*\n\n>D/MainActivity: onPause\n\n*重新获得焦点（未做兼容处理）*\n\n>D/MainActivity: onResume\n\n注意，在默认情况下，一旦失去焦点，会回调onPause()方法。而此时Activity仍然可以被用户看到，因此，如果我们在onPause()里面做了一些不合适的操作，比如来了一个手势解锁，或者特殊情况下直接关闭程序，就明显不合适了。  \n为了避免这种情况出现，我们希望在失去焦点的时候不回调onPause()。那么，我们只需在AndroidManifest.xml的application节点下添加如下代码，即可规避该问题：\n```\n<meta-data\n  android:name=\"android.allow_multiple_resumed_activities\"\n  android:value=\"true\"/>\n```\n再次测试时，我们发现onPause()已经不会被回调了。  \n到这里，我们有这样一个疑问：我们失去onPause()作为得到/失去焦点的判定依据，我们用什么来得知状态呢？  \n很简单——**借助onWindowFocusChanged()回调**，即可及时获取焦点状态了。使用如下代码片进行测试：  \n```\n@Override\npublic void onWindowFocusChanged(boolean hasFocus) {\n    super.onWindowFocusChanged(hasFocus);\n    Log.d(TAG, \"onWindowFocusChanged - \" + hasFocus);\n}\n```\n使APP反复得到/失去焦点，观察Logcat输出，得到如下结果：\n>D/MainActivity: onWindowFocusChanged - false  \nD/MainActivity: onWindowFocusChanged - true  \nD/MainActivity: onWindowFocusChanged - false  \nD/MainActivity: onWindowFocusChanged - true  \n……\n\n至此，问题解决。  \n然而，你可能还会问：**如果小窗口的尺寸发生变化如何处理？**  \n这并不困难，通过调整APP窗口大小，再次观察Logcat输出，发现**onConfigurationChanged()方法被回调**了。还记得我们之前提过的改变窗口大小吗？这就是一个实际的例子。该如何处理，大家心中应该有数了吧。  \n今天的分享就到这里，希望上面的内容能够对你有帮助。\n","source":"_posts/粮草先行——Android折叠屏开发技术点（二）.md","raw":"---\ntitle: 粮草先行——Android折叠屏开发技术点（二）\ndate: 2019-02-20 17:56:10\ntags: Android\ncategories: 编程世界\n---\n\n继该系列的第一篇和番外篇之后，今天我们来聊一聊多窗口开发的注意事项。实际上，与其说“多窗口开发”，不如说让我们的APP**适应多窗口模式**。  \n可能有朋友会问，为什么要提到多窗口模式呢？  \n这是因为：\n\n1. 折叠屏在展开后的屏幕会变大，而变大带来的变化就是多窗口运行；  \n2. 多窗口模式在很早之前就已经被Google官方支持，提供了相应的API，现在也到了该了解一下的时候了；\n3. 避免我们辛辛苦苦开发好的APP，翻车在多窗口的沟里；\n4. 虽然在Android Q中，多窗口模式很可能将成为默认行为，但要兼容之前的版本，我们仍然需要做一些事情。  \n\n首先我们来看一下如果我们什么都不做，切换多窗口时，会发生什么呢？仍然从生命周期的角度来解读：  \n\n*失去焦点（未做兼容处理）*\n\n>D/MainActivity: onPause\n\n*重新获得焦点（未做兼容处理）*\n\n>D/MainActivity: onResume\n\n注意，在默认情况下，一旦失去焦点，会回调onPause()方法。而此时Activity仍然可以被用户看到，因此，如果我们在onPause()里面做了一些不合适的操作，比如来了一个手势解锁，或者特殊情况下直接关闭程序，就明显不合适了。  \n为了避免这种情况出现，我们希望在失去焦点的时候不回调onPause()。那么，我们只需在AndroidManifest.xml的application节点下添加如下代码，即可规避该问题：\n```\n<meta-data\n  android:name=\"android.allow_multiple_resumed_activities\"\n  android:value=\"true\"/>\n```\n再次测试时，我们发现onPause()已经不会被回调了。  \n到这里，我们有这样一个疑问：我们失去onPause()作为得到/失去焦点的判定依据，我们用什么来得知状态呢？  \n很简单——**借助onWindowFocusChanged()回调**，即可及时获取焦点状态了。使用如下代码片进行测试：  \n```\n@Override\npublic void onWindowFocusChanged(boolean hasFocus) {\n    super.onWindowFocusChanged(hasFocus);\n    Log.d(TAG, \"onWindowFocusChanged - \" + hasFocus);\n}\n```\n使APP反复得到/失去焦点，观察Logcat输出，得到如下结果：\n>D/MainActivity: onWindowFocusChanged - false  \nD/MainActivity: onWindowFocusChanged - true  \nD/MainActivity: onWindowFocusChanged - false  \nD/MainActivity: onWindowFocusChanged - true  \n……\n\n至此，问题解决。  \n然而，你可能还会问：**如果小窗口的尺寸发生变化如何处理？**  \n这并不困难，通过调整APP窗口大小，再次观察Logcat输出，发现**onConfigurationChanged()方法被回调**了。还记得我们之前提过的改变窗口大小吗？这就是一个实际的例子。该如何处理，大家心中应该有数了吧。  \n今天的分享就到这里，希望上面的内容能够对你有帮助。\n","slug":"粮草先行——Android折叠屏开发技术点（二）","published":1,"updated":"2019-07-31T04:11:50.002Z","_id":"cjyqq3tkb001mfkqddni17oqc","comments":1,"layout":"post","photos":[],"link":"","content":"<p>继该系列的第一篇和番外篇之后，今天我们来聊一聊多窗口开发的注意事项。实际上，与其说“多窗口开发”，不如说让我们的APP<strong>适应多窗口模式</strong>。<br>可能有朋友会问，为什么要提到多窗口模式呢？<br>这是因为：</p>\n<ol>\n<li>折叠屏在展开后的屏幕会变大，而变大带来的变化就是多窗口运行；  </li>\n<li>多窗口模式在很早之前就已经被Google官方支持，提供了相应的API，现在也到了该了解一下的时候了；</li>\n<li>避免我们辛辛苦苦开发好的APP，翻车在多窗口的沟里；</li>\n<li>虽然在Android Q中，多窗口模式很可能将成为默认行为，但要兼容之前的版本，我们仍然需要做一些事情。  </li>\n</ol>\n<p>首先我们来看一下如果我们什么都不做，切换多窗口时，会发生什么呢？仍然从生命周期的角度来解读：  </p>\n<p><em>失去焦点（未做兼容处理）</em></p>\n<blockquote>\n<p>D/MainActivity: onPause</p>\n</blockquote>\n<p><em>重新获得焦点（未做兼容处理）</em></p>\n<blockquote>\n<p>D/MainActivity: onResume</p>\n</blockquote>\n<p>注意，在默认情况下，一旦失去焦点，会回调onPause()方法。而此时Activity仍然可以被用户看到，因此，如果我们在onPause()里面做了一些不合适的操作，比如来了一个手势解锁，或者特殊情况下直接关闭程序，就明显不合适了。<br>为了避免这种情况出现，我们希望在失去焦点的时候不回调onPause()。那么，我们只需在AndroidManifest.xml的application节点下添加如下代码，即可规避该问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta-data</span><br><span class=\"line\">  android:name=&quot;android.allow_multiple_resumed_activities&quot;</span><br><span class=\"line\">  android:value=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<p>再次测试时，我们发现onPause()已经不会被回调了。<br>到这里，我们有这样一个疑问：我们失去onPause()作为得到/失去焦点的判定依据，我们用什么来得知状态呢？<br>很简单——<strong>借助onWindowFocusChanged()回调</strong>，即可及时获取焦点状态了。使用如下代码片进行测试：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void onWindowFocusChanged(boolean hasFocus) &#123;</span><br><span class=\"line\">    super.onWindowFocusChanged(hasFocus);</span><br><span class=\"line\">    Log.d(TAG, &quot;onWindowFocusChanged - &quot; + hasFocus);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使APP反复得到/失去焦点，观察Logcat输出，得到如下结果：</p>\n<blockquote>\n<p>D/MainActivity: onWindowFocusChanged - false<br>D/MainActivity: onWindowFocusChanged - true<br>D/MainActivity: onWindowFocusChanged - false<br>D/MainActivity: onWindowFocusChanged - true<br>……</p>\n</blockquote>\n<p>至此，问题解决。<br>然而，你可能还会问：<strong>如果小窗口的尺寸发生变化如何处理？</strong><br>这并不困难，通过调整APP窗口大小，再次观察Logcat输出，发现<strong>onConfigurationChanged()方法被回调</strong>了。还记得我们之前提过的改变窗口大小吗？这就是一个实际的例子。该如何处理，大家心中应该有数了吧。<br>今天的分享就到这里，希望上面的内容能够对你有帮助。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>继该系列的第一篇和番外篇之后，今天我们来聊一聊多窗口开发的注意事项。实际上，与其说“多窗口开发”，不如说让我们的APP<strong>适应多窗口模式</strong>。<br>可能有朋友会问，为什么要提到多窗口模式呢？<br>这是因为：</p>\n<ol>\n<li>折叠屏在展开后的屏幕会变大，而变大带来的变化就是多窗口运行；  </li>\n<li>多窗口模式在很早之前就已经被Google官方支持，提供了相应的API，现在也到了该了解一下的时候了；</li>\n<li>避免我们辛辛苦苦开发好的APP，翻车在多窗口的沟里；</li>\n<li>虽然在Android Q中，多窗口模式很可能将成为默认行为，但要兼容之前的版本，我们仍然需要做一些事情。  </li>\n</ol>\n<p>首先我们来看一下如果我们什么都不做，切换多窗口时，会发生什么呢？仍然从生命周期的角度来解读：  </p>\n<p><em>失去焦点（未做兼容处理）</em></p>\n<blockquote>\n<p>D/MainActivity: onPause</p>\n</blockquote>\n<p><em>重新获得焦点（未做兼容处理）</em></p>\n<blockquote>\n<p>D/MainActivity: onResume</p>\n</blockquote>\n<p>注意，在默认情况下，一旦失去焦点，会回调onPause()方法。而此时Activity仍然可以被用户看到，因此，如果我们在onPause()里面做了一些不合适的操作，比如来了一个手势解锁，或者特殊情况下直接关闭程序，就明显不合适了。<br>为了避免这种情况出现，我们希望在失去焦点的时候不回调onPause()。那么，我们只需在AndroidManifest.xml的application节点下添加如下代码，即可规避该问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta-data</span><br><span class=\"line\">  android:name=&quot;android.allow_multiple_resumed_activities&quot;</span><br><span class=\"line\">  android:value=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<p>再次测试时，我们发现onPause()已经不会被回调了。<br>到这里，我们有这样一个疑问：我们失去onPause()作为得到/失去焦点的判定依据，我们用什么来得知状态呢？<br>很简单——<strong>借助onWindowFocusChanged()回调</strong>，即可及时获取焦点状态了。使用如下代码片进行测试：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void onWindowFocusChanged(boolean hasFocus) &#123;</span><br><span class=\"line\">    super.onWindowFocusChanged(hasFocus);</span><br><span class=\"line\">    Log.d(TAG, &quot;onWindowFocusChanged - &quot; + hasFocus);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使APP反复得到/失去焦点，观察Logcat输出，得到如下结果：</p>\n<blockquote>\n<p>D/MainActivity: onWindowFocusChanged - false<br>D/MainActivity: onWindowFocusChanged - true<br>D/MainActivity: onWindowFocusChanged - false<br>D/MainActivity: onWindowFocusChanged - true<br>……</p>\n</blockquote>\n<p>至此，问题解决。<br>然而，你可能还会问：<strong>如果小窗口的尺寸发生变化如何处理？</strong><br>这并不困难，通过调整APP窗口大小，再次观察Logcat输出，发现<strong>onConfigurationChanged()方法被回调</strong>了。还记得我们之前提过的改变窗口大小吗？这就是一个实际的例子。该如何处理，大家心中应该有数了吧。<br>今天的分享就到这里，希望上面的内容能够对你有帮助。</p>\n"},{"title":"解决Android录音iOS兼容性问题","date":"2014-09-11T02:50:46.000Z","_content":"\n最近在开发过程中遇到问题，Android客户端录制的AMR_NB编码的文件在iOS设备商播放失败。经过反复百度谷歌，得知iOS需要借助AmrToWave的转换，这无疑给iOS开发者带来不便。随即想到更改录音时的参数，经过测试，使用AAC可以解决该问题，而且Android本身使用MediaPlayer类播放即可，减轻了iOS开发者的工作量。录音示例部分代码如下：\n\n```\nMediaRecoder mediaRecorder = new MediaRecorder();\nmediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);\nmediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);\nmediaRecorder.setOutputFile(APPCFG.VOICE_FILE);\nmediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);\n```\n\n希望上面的代码片对你有帮助。","source":"_posts/解决Android录音iOS兼容性问题.md","raw":"---\ntitle: 解决Android录音iOS兼容性问题\ndate: 2014-09-11 10:50:46\ntags: Android\ncategories: 编程世界\n---\n\n最近在开发过程中遇到问题，Android客户端录制的AMR_NB编码的文件在iOS设备商播放失败。经过反复百度谷歌，得知iOS需要借助AmrToWave的转换，这无疑给iOS开发者带来不便。随即想到更改录音时的参数，经过测试，使用AAC可以解决该问题，而且Android本身使用MediaPlayer类播放即可，减轻了iOS开发者的工作量。录音示例部分代码如下：\n\n```\nMediaRecoder mediaRecorder = new MediaRecorder();\nmediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);\nmediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);\nmediaRecorder.setOutputFile(APPCFG.VOICE_FILE);\nmediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);\n```\n\n希望上面的代码片对你有帮助。","slug":"解决Android录音iOS兼容性问题","published":1,"updated":"2019-07-31T04:12:02.763Z","_id":"cjyqq3tkc001ofkqdpfp66hhf","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近在开发过程中遇到问题，Android客户端录制的AMR_NB编码的文件在iOS设备商播放失败。经过反复百度谷歌，得知iOS需要借助AmrToWave的转换，这无疑给iOS开发者带来不便。随即想到更改录音时的参数，经过测试，使用AAC可以解决该问题，而且Android本身使用MediaPlayer类播放即可，减轻了iOS开发者的工作量。录音示例部分代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MediaRecoder mediaRecorder = new MediaRecorder();</span><br><span class=\"line\">mediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);</span><br><span class=\"line\">mediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);</span><br><span class=\"line\">mediaRecorder.setOutputFile(APPCFG.VOICE_FILE);</span><br><span class=\"line\">mediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);</span><br></pre></td></tr></table></figure>\n\n<p>希望上面的代码片对你有帮助。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近在开发过程中遇到问题，Android客户端录制的AMR_NB编码的文件在iOS设备商播放失败。经过反复百度谷歌，得知iOS需要借助AmrToWave的转换，这无疑给iOS开发者带来不便。随即想到更改录音时的参数，经过测试，使用AAC可以解决该问题，而且Android本身使用MediaPlayer类播放即可，减轻了iOS开发者的工作量。录音示例部分代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MediaRecoder mediaRecorder = new MediaRecorder();</span><br><span class=\"line\">mediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);</span><br><span class=\"line\">mediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);</span><br><span class=\"line\">mediaRecorder.setOutputFile(APPCFG.VOICE_FILE);</span><br><span class=\"line\">mediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);</span><br></pre></td></tr></table></figure>\n\n<p>希望上面的代码片对你有帮助。</p>\n"},{"title":"解决TextView引起的莫名崩溃","date":"2017-04-06T01:50:35.000Z","_content":"进了2017年之后到现在，我一直都在忙着做一款IM应用，功能和微信、QQ类似。  \n在开发和测试的过程中，发现了几个可以总结记录的东西，今天和大家来分享其中之一。    \n首先来看一个异常：    \n\n> \n    java.lang.ArrayIndexOutOfBoundsException: length=125; index=-1\n\tat android.text.StaticLayout.calculateEllipsis(StaticLayout.java:830)\n\tat android.text.StaticLayout.out(StaticLayout.java:749)\n\tat android.text.StaticLayout.generate(StaticLayout.java:453)\n\tat android.text.StaticLayout.<init>(StaticLayout.java:145)\n\tat android.widget.TextView.makeSingleLayout(TextView.java:6298)\n\tat android.widget.TextView.makeNewLayout(TextView.java:6144)\n\t\n乍看上去，倒是和我这边没什么关系，都是Android内部实现的问题。但是每到这个地方，都会崩溃，100%复现。这对于实际用户使用而言不是什么好事。  \n于是Google，百度了一圈，发现了Android系统在某个版本中的“坑”。  \n具体解决办法：  \n之前xml布局中，对于TextView：  \n\n```\n<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:ellipsize=\"middle\"\n    android:lines=\"1\"\n    android:text=\"\"/>  \n```\n\n看上去没有问题，如果要解决上述崩溃问题，改为：\n\n```\n<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:ellipsize=\"middle\"\n    android:singleLine=\"true\"\n    android:text=\"\"/>  \n```\n\n即可。  \n这里参考了：[Google Code][1]\n\n\n  [1]: https://code.google.com/p/android/issues/detail?id=33868\n  \n上述问题在Android 4.4版本上有所体现，其他的版本暂不确定。","source":"_posts/解决TextView引起的莫名崩溃.md","raw":"---\ntitle: 解决TextView引起的莫名崩溃\ndate: 2017-04-06 09:50:35\ntags: Android\ncategories: 编程世界\n---\n进了2017年之后到现在，我一直都在忙着做一款IM应用，功能和微信、QQ类似。  \n在开发和测试的过程中，发现了几个可以总结记录的东西，今天和大家来分享其中之一。    \n首先来看一个异常：    \n\n> \n    java.lang.ArrayIndexOutOfBoundsException: length=125; index=-1\n\tat android.text.StaticLayout.calculateEllipsis(StaticLayout.java:830)\n\tat android.text.StaticLayout.out(StaticLayout.java:749)\n\tat android.text.StaticLayout.generate(StaticLayout.java:453)\n\tat android.text.StaticLayout.<init>(StaticLayout.java:145)\n\tat android.widget.TextView.makeSingleLayout(TextView.java:6298)\n\tat android.widget.TextView.makeNewLayout(TextView.java:6144)\n\t\n乍看上去，倒是和我这边没什么关系，都是Android内部实现的问题。但是每到这个地方，都会崩溃，100%复现。这对于实际用户使用而言不是什么好事。  \n于是Google，百度了一圈，发现了Android系统在某个版本中的“坑”。  \n具体解决办法：  \n之前xml布局中，对于TextView：  \n\n```\n<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:ellipsize=\"middle\"\n    android:lines=\"1\"\n    android:text=\"\"/>  \n```\n\n看上去没有问题，如果要解决上述崩溃问题，改为：\n\n```\n<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:ellipsize=\"middle\"\n    android:singleLine=\"true\"\n    android:text=\"\"/>  \n```\n\n即可。  \n这里参考了：[Google Code][1]\n\n\n  [1]: https://code.google.com/p/android/issues/detail?id=33868\n  \n上述问题在Android 4.4版本上有所体现，其他的版本暂不确定。","slug":"解决TextView引起的莫名崩溃","published":1,"updated":"2019-07-31T04:12:13.599Z","_id":"cjyqq3tkd001qfkqdp2qzppw3","comments":1,"layout":"post","photos":[],"link":"","content":"<p>进了2017年之后到现在，我一直都在忙着做一款IM应用，功能和微信、QQ类似。<br>在开发和测试的过程中，发现了几个可以总结记录的东西，今天和大家来分享其中之一。<br>首先来看一个异常：    </p>\n<blockquote>\n</blockquote>\n<pre><code>java.lang.ArrayIndexOutOfBoundsException: length=125; index=-1\nat android.text.StaticLayout.calculateEllipsis(StaticLayout.java:830)\nat android.text.StaticLayout.out(StaticLayout.java:749)\nat android.text.StaticLayout.generate(StaticLayout.java:453)\nat android.text.StaticLayout.&lt;init&gt;(StaticLayout.java:145)\nat android.widget.TextView.makeSingleLayout(TextView.java:6298)\nat android.widget.TextView.makeNewLayout(TextView.java:6144)</code></pre><p>乍看上去，倒是和我这边没什么关系，都是Android内部实现的问题。但是每到这个地方，都会崩溃，100%复现。这对于实际用户使用而言不是什么好事。<br>于是Google，百度了一圈，发现了Android系统在某个版本中的“坑”。<br>具体解决办法：<br>之前xml布局中，对于TextView：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">    android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">    android:ellipsize=&quot;middle&quot;</span><br><span class=\"line\">    android:lines=&quot;1&quot;</span><br><span class=\"line\">    android:text=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<p>看上去没有问题，如果要解决上述崩溃问题，改为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">    android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">    android:ellipsize=&quot;middle&quot;</span><br><span class=\"line\">    android:singleLine=&quot;true&quot;</span><br><span class=\"line\">    android:text=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<p>即可。<br>这里参考了：<a href=\"https://code.google.com/p/android/issues/detail?id=33868\" target=\"_blank\" rel=\"noopener\">Google Code</a></p>\n<p>上述问题在Android 4.4版本上有所体现，其他的版本暂不确定。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>进了2017年之后到现在，我一直都在忙着做一款IM应用，功能和微信、QQ类似。<br>在开发和测试的过程中，发现了几个可以总结记录的东西，今天和大家来分享其中之一。<br>首先来看一个异常：    </p>\n<blockquote>\n</blockquote>\n<pre><code>java.lang.ArrayIndexOutOfBoundsException: length=125; index=-1\nat android.text.StaticLayout.calculateEllipsis(StaticLayout.java:830)\nat android.text.StaticLayout.out(StaticLayout.java:749)\nat android.text.StaticLayout.generate(StaticLayout.java:453)\nat android.text.StaticLayout.&lt;init&gt;(StaticLayout.java:145)\nat android.widget.TextView.makeSingleLayout(TextView.java:6298)\nat android.widget.TextView.makeNewLayout(TextView.java:6144)</code></pre><p>乍看上去，倒是和我这边没什么关系，都是Android内部实现的问题。但是每到这个地方，都会崩溃，100%复现。这对于实际用户使用而言不是什么好事。<br>于是Google，百度了一圈，发现了Android系统在某个版本中的“坑”。<br>具体解决办法：<br>之前xml布局中，对于TextView：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">    android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">    android:ellipsize=&quot;middle&quot;</span><br><span class=\"line\">    android:lines=&quot;1&quot;</span><br><span class=\"line\">    android:text=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<p>看上去没有问题，如果要解决上述崩溃问题，改为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    android:layout_width=&quot;wrap_content&quot;</span><br><span class=\"line\">    android:layout_height=&quot;wrap_content&quot;</span><br><span class=\"line\">    android:ellipsize=&quot;middle&quot;</span><br><span class=\"line\">    android:singleLine=&quot;true&quot;</span><br><span class=\"line\">    android:text=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<p>即可。<br>这里参考了：<a href=\"https://code.google.com/p/android/issues/detail?id=33868\" target=\"_blank\" rel=\"noopener\">Google Code</a></p>\n<p>上述问题在Android 4.4版本上有所体现，其他的版本暂不确定。</p>\n"},{"title":"调用系统相机导致照片旋转问题的修复","date":"2015-07-02T06:29:56.000Z","_content":"\n如题，相信很多开发者在调用系统照相机接收拍好的照片时，发现照片被无故旋转了90度。这一问题反映在大部分的三星手机上，当然其他的机器还没试完全，总之是有问题。  \n于是乎想到如下的解决办法：  \n  \n1. 识别机型，获取手机型号，然后判断是否需要旋转；  \n2. 通过获取照片宽度和高度判断是否需要旋转；  \n3. 自己动手写一个照相机Activity，自己来获取摄像头数据，保存照片；  \n4. 分析发生旋转的照片数据，动态判断是否需要旋转，以及旋转正确的角度。   \n\n前三种方法均不是理想的解决方案。  \n首先说1：这种类似于穷举的办法，总会有那些被遗忘的“角落”，维护这些机型会很繁琐；  \n然后说2：如果这样的话，如果刚好用户要横屏照照片，还是会发生旋转；  \n最后说3：这种方法岂是我等“懒”程序员所能做到的？（PS：其实是需求所限啦，自己写照相APP，耗时+费精力+容易出bug。好处就在于用户会感觉自己始终处于同一APP中，而不是发生了跳转。）  \n那么第四种方案是如何做到的呢？  \n首先通过分析，通常一张照片包含许多EXIF信息。这些信息包含了拍照的设备，曝光度，是否使用了闪光灯种种内容。这其中包括了角度，也就是旋转问题的症结所在。  \n手机自身的照片查看器（某些机型）在显示照片的时候，会分析这些信息，当分析的角度的信息时，会自动旋转照片到合适的角度。比较常见的角度是90、180、270。大部分的三星手机在竖屏拍照的时候会拍出角度为90度的照片，横屏为0度。因此，解决的思路就是按照EXIF中的角度信息进行旋转即可。主要用到安卓API中的Matrix。关键代码可参考下面的代码片：  \n\n```\nExifInterface exifInterface = new ExifInterface(APPCFG.IMAGE_FILE);\nint orientationDegree = exifInterface.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);\nMatrix matrix = new Matrix();\nmatrix.reset();\nif (orientationDegree == ExifInterface.ORIENTATION_ROTATE_90) {\n  \tmatrix.postRotate(90);\n}\nif (orientationDegree == ExifInterface.ORIENTATION_ROTATE_180) {\n    matrix.postRotate(180);\n}\nif (orientationDegree == ExifInterface.ORIENTATION_ROTATE_270) {\n    matrix.postRotate(270);\n}\nbitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(),bitmap.getHeight(), matrix, true);\n```\n\n上述代码中，bitmap是Bitmap对象，我这里需要在后面显示，所以暂时没有recycle()，提醒大家一下，免得内存溢出。   \n到此，无论是三星还是什么机型，利用这种通用的方法，即可解决照片旋转的问题了。","source":"_posts/调用系统相机导致照片旋转问题的修复.md","raw":"---\ntitle: 调用系统相机导致照片旋转问题的修复\ndate: 2015-07-02 14:29:56\ntags: Android\ncategories: 编程世界\n---\n\n如题，相信很多开发者在调用系统照相机接收拍好的照片时，发现照片被无故旋转了90度。这一问题反映在大部分的三星手机上，当然其他的机器还没试完全，总之是有问题。  \n于是乎想到如下的解决办法：  \n  \n1. 识别机型，获取手机型号，然后判断是否需要旋转；  \n2. 通过获取照片宽度和高度判断是否需要旋转；  \n3. 自己动手写一个照相机Activity，自己来获取摄像头数据，保存照片；  \n4. 分析发生旋转的照片数据，动态判断是否需要旋转，以及旋转正确的角度。   \n\n前三种方法均不是理想的解决方案。  \n首先说1：这种类似于穷举的办法，总会有那些被遗忘的“角落”，维护这些机型会很繁琐；  \n然后说2：如果这样的话，如果刚好用户要横屏照照片，还是会发生旋转；  \n最后说3：这种方法岂是我等“懒”程序员所能做到的？（PS：其实是需求所限啦，自己写照相APP，耗时+费精力+容易出bug。好处就在于用户会感觉自己始终处于同一APP中，而不是发生了跳转。）  \n那么第四种方案是如何做到的呢？  \n首先通过分析，通常一张照片包含许多EXIF信息。这些信息包含了拍照的设备，曝光度，是否使用了闪光灯种种内容。这其中包括了角度，也就是旋转问题的症结所在。  \n手机自身的照片查看器（某些机型）在显示照片的时候，会分析这些信息，当分析的角度的信息时，会自动旋转照片到合适的角度。比较常见的角度是90、180、270。大部分的三星手机在竖屏拍照的时候会拍出角度为90度的照片，横屏为0度。因此，解决的思路就是按照EXIF中的角度信息进行旋转即可。主要用到安卓API中的Matrix。关键代码可参考下面的代码片：  \n\n```\nExifInterface exifInterface = new ExifInterface(APPCFG.IMAGE_FILE);\nint orientationDegree = exifInterface.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);\nMatrix matrix = new Matrix();\nmatrix.reset();\nif (orientationDegree == ExifInterface.ORIENTATION_ROTATE_90) {\n  \tmatrix.postRotate(90);\n}\nif (orientationDegree == ExifInterface.ORIENTATION_ROTATE_180) {\n    matrix.postRotate(180);\n}\nif (orientationDegree == ExifInterface.ORIENTATION_ROTATE_270) {\n    matrix.postRotate(270);\n}\nbitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(),bitmap.getHeight(), matrix, true);\n```\n\n上述代码中，bitmap是Bitmap对象，我这里需要在后面显示，所以暂时没有recycle()，提醒大家一下，免得内存溢出。   \n到此，无论是三星还是什么机型，利用这种通用的方法，即可解决照片旋转的问题了。","slug":"调用系统相机导致照片旋转问题的修复","published":1,"updated":"2019-07-31T04:12:16.364Z","_id":"cjyqq3tke001sfkqd3nglj09s","comments":1,"layout":"post","photos":[],"link":"","content":"<p>如题，相信很多开发者在调用系统照相机接收拍好的照片时，发现照片被无故旋转了90度。这一问题反映在大部分的三星手机上，当然其他的机器还没试完全，总之是有问题。<br>于是乎想到如下的解决办法：  </p>\n<ol>\n<li>识别机型，获取手机型号，然后判断是否需要旋转；  </li>\n<li>通过获取照片宽度和高度判断是否需要旋转；  </li>\n<li>自己动手写一个照相机Activity，自己来获取摄像头数据，保存照片；  </li>\n<li>分析发生旋转的照片数据，动态判断是否需要旋转，以及旋转正确的角度。   </li>\n</ol>\n<p>前三种方法均不是理想的解决方案。<br>首先说1：这种类似于穷举的办法，总会有那些被遗忘的“角落”，维护这些机型会很繁琐；<br>然后说2：如果这样的话，如果刚好用户要横屏照照片，还是会发生旋转；<br>最后说3：这种方法岂是我等“懒”程序员所能做到的？（PS：其实是需求所限啦，自己写照相APP，耗时+费精力+容易出bug。好处就在于用户会感觉自己始终处于同一APP中，而不是发生了跳转。）<br>那么第四种方案是如何做到的呢？<br>首先通过分析，通常一张照片包含许多EXIF信息。这些信息包含了拍照的设备，曝光度，是否使用了闪光灯种种内容。这其中包括了角度，也就是旋转问题的症结所在。<br>手机自身的照片查看器（某些机型）在显示照片的时候，会分析这些信息，当分析的角度的信息时，会自动旋转照片到合适的角度。比较常见的角度是90、180、270。大部分的三星手机在竖屏拍照的时候会拍出角度为90度的照片，横屏为0度。因此，解决的思路就是按照EXIF中的角度信息进行旋转即可。主要用到安卓API中的Matrix。关键代码可参考下面的代码片：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExifInterface exifInterface = new ExifInterface(APPCFG.IMAGE_FILE);</span><br><span class=\"line\">int orientationDegree = exifInterface.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);</span><br><span class=\"line\">Matrix matrix = new Matrix();</span><br><span class=\"line\">matrix.reset();</span><br><span class=\"line\">if (orientationDegree == ExifInterface.ORIENTATION_ROTATE_90) &#123;</span><br><span class=\"line\">  \tmatrix.postRotate(90);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if (orientationDegree == ExifInterface.ORIENTATION_ROTATE_180) &#123;</span><br><span class=\"line\">    matrix.postRotate(180);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if (orientationDegree == ExifInterface.ORIENTATION_ROTATE_270) &#123;</span><br><span class=\"line\">    matrix.postRotate(270);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(),bitmap.getHeight(), matrix, true);</span><br></pre></td></tr></table></figure>\n\n<p>上述代码中，bitmap是Bitmap对象，我这里需要在后面显示，所以暂时没有recycle()，提醒大家一下，免得内存溢出。<br>到此，无论是三星还是什么机型，利用这种通用的方法，即可解决照片旋转的问题了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>如题，相信很多开发者在调用系统照相机接收拍好的照片时，发现照片被无故旋转了90度。这一问题反映在大部分的三星手机上，当然其他的机器还没试完全，总之是有问题。<br>于是乎想到如下的解决办法：  </p>\n<ol>\n<li>识别机型，获取手机型号，然后判断是否需要旋转；  </li>\n<li>通过获取照片宽度和高度判断是否需要旋转；  </li>\n<li>自己动手写一个照相机Activity，自己来获取摄像头数据，保存照片；  </li>\n<li>分析发生旋转的照片数据，动态判断是否需要旋转，以及旋转正确的角度。   </li>\n</ol>\n<p>前三种方法均不是理想的解决方案。<br>首先说1：这种类似于穷举的办法，总会有那些被遗忘的“角落”，维护这些机型会很繁琐；<br>然后说2：如果这样的话，如果刚好用户要横屏照照片，还是会发生旋转；<br>最后说3：这种方法岂是我等“懒”程序员所能做到的？（PS：其实是需求所限啦，自己写照相APP，耗时+费精力+容易出bug。好处就在于用户会感觉自己始终处于同一APP中，而不是发生了跳转。）<br>那么第四种方案是如何做到的呢？<br>首先通过分析，通常一张照片包含许多EXIF信息。这些信息包含了拍照的设备，曝光度，是否使用了闪光灯种种内容。这其中包括了角度，也就是旋转问题的症结所在。<br>手机自身的照片查看器（某些机型）在显示照片的时候，会分析这些信息，当分析的角度的信息时，会自动旋转照片到合适的角度。比较常见的角度是90、180、270。大部分的三星手机在竖屏拍照的时候会拍出角度为90度的照片，横屏为0度。因此，解决的思路就是按照EXIF中的角度信息进行旋转即可。主要用到安卓API中的Matrix。关键代码可参考下面的代码片：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExifInterface exifInterface = new ExifInterface(APPCFG.IMAGE_FILE);</span><br><span class=\"line\">int orientationDegree = exifInterface.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);</span><br><span class=\"line\">Matrix matrix = new Matrix();</span><br><span class=\"line\">matrix.reset();</span><br><span class=\"line\">if (orientationDegree == ExifInterface.ORIENTATION_ROTATE_90) &#123;</span><br><span class=\"line\">  \tmatrix.postRotate(90);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if (orientationDegree == ExifInterface.ORIENTATION_ROTATE_180) &#123;</span><br><span class=\"line\">    matrix.postRotate(180);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if (orientationDegree == ExifInterface.ORIENTATION_ROTATE_270) &#123;</span><br><span class=\"line\">    matrix.postRotate(270);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(),bitmap.getHeight(), matrix, true);</span><br></pre></td></tr></table></figure>\n\n<p>上述代码中，bitmap是Bitmap对象，我这里需要在后面显示，所以暂时没有recycle()，提醒大家一下，免得内存溢出。<br>到此，无论是三星还是什么机型，利用这种通用的方法，即可解决照片旋转的问题了。</p>\n"},{"title":"轻松使用Github搭建个人网站","date":"2015-03-08T04:40:43.000Z","_content":"\n今天我们来谈一个有关建站的话题。  \n众所周知，Github有着程序员间的Facebook之称，很多知名的项目都是利用其公共Git服务进行开源，以供全球爱好者共享。Git的版本控制机制给我们提供了完善的版本管理功能，既能够团队协作，多地工作；又能在任何时间回滚到之前的任何版本，起到良好的备份作用。因此，在其上面搭建个人网站就变得很合适了。  \n和传统的个人博客系统不同，传统的个人博客只能提供博文的发表、评论等等，而在Github上面建站，就好比一幅油画的白纸，很纯净，很自由，人们可以自定义上面的内容，尽情挥洒自己的创意。   \n下面我们就一起体验建站之旅！   \nGithub地址：https://github.com/   \nGithub Windows版客户端：https://windows.github.com/   \n首先要有一个Github账户，这个是前提。注册流程就不多说了，打开上面的地址，应该能找到注册入口。   \n创建好用户后登录，然后创建一个新的库，如下图：    \n\n![创建repo](https://img-blog.csdn.net/20150308123930410)\n\n在创建新库的网页中，填写库名。名称必须为：username.github.io。例如，我的是XiaoWenHan.github.io。    \n\n![创建repo](https://img-blog.csdn.net/20150308123931159)\n\n通常情况下，不会出现上图中红色的部分不会变红。我这里变为红色是因为之前创建过了，因为重名，所以有错误提示。    \n创建好之后，将其Clone到本地。可以通过上面提到过的客户端，如果你使用的是比Windows 7 还要低的Windows 版本，就需要使用命令行或其他的工具了，比如SourceTree。   \n下面尝试建立一个index.html，在Clone出来的本地目录下。比如，可以写一段Hello World。然后保存，上传。   \n上传成功后，打开浏览器，在地址栏处输入你的username.github.io。不出意外的话，应该能看到HelloWorld了。   \n到此，白纸已经准备好。各位读者，动手实践起来吧！   \n","source":"_posts/轻松使用Github搭建个人网站.md","raw":"---\ntitle: 轻松使用Github搭建个人网站\ndate: 2015-03-08 12:40:43\ntags: Web\ncategories: 编程世界\n---\n\n今天我们来谈一个有关建站的话题。  \n众所周知，Github有着程序员间的Facebook之称，很多知名的项目都是利用其公共Git服务进行开源，以供全球爱好者共享。Git的版本控制机制给我们提供了完善的版本管理功能，既能够团队协作，多地工作；又能在任何时间回滚到之前的任何版本，起到良好的备份作用。因此，在其上面搭建个人网站就变得很合适了。  \n和传统的个人博客系统不同，传统的个人博客只能提供博文的发表、评论等等，而在Github上面建站，就好比一幅油画的白纸，很纯净，很自由，人们可以自定义上面的内容，尽情挥洒自己的创意。   \n下面我们就一起体验建站之旅！   \nGithub地址：https://github.com/   \nGithub Windows版客户端：https://windows.github.com/   \n首先要有一个Github账户，这个是前提。注册流程就不多说了，打开上面的地址，应该能找到注册入口。   \n创建好用户后登录，然后创建一个新的库，如下图：    \n\n![创建repo](https://img-blog.csdn.net/20150308123930410)\n\n在创建新库的网页中，填写库名。名称必须为：username.github.io。例如，我的是XiaoWenHan.github.io。    \n\n![创建repo](https://img-blog.csdn.net/20150308123931159)\n\n通常情况下，不会出现上图中红色的部分不会变红。我这里变为红色是因为之前创建过了，因为重名，所以有错误提示。    \n创建好之后，将其Clone到本地。可以通过上面提到过的客户端，如果你使用的是比Windows 7 还要低的Windows 版本，就需要使用命令行或其他的工具了，比如SourceTree。   \n下面尝试建立一个index.html，在Clone出来的本地目录下。比如，可以写一段Hello World。然后保存，上传。   \n上传成功后，打开浏览器，在地址栏处输入你的username.github.io。不出意外的话，应该能看到HelloWorld了。   \n到此，白纸已经准备好。各位读者，动手实践起来吧！   \n","slug":"轻松使用Github搭建个人网站","published":1,"updated":"2019-07-31T04:12:29.428Z","_id":"cjyqq3tkf001ufkqdukx219pz","comments":1,"layout":"post","photos":[],"link":"","content":"<p>今天我们来谈一个有关建站的话题。<br>众所周知，Github有着程序员间的Facebook之称，很多知名的项目都是利用其公共Git服务进行开源，以供全球爱好者共享。Git的版本控制机制给我们提供了完善的版本管理功能，既能够团队协作，多地工作；又能在任何时间回滚到之前的任何版本，起到良好的备份作用。因此，在其上面搭建个人网站就变得很合适了。<br>和传统的个人博客系统不同，传统的个人博客只能提供博文的发表、评论等等，而在Github上面建站，就好比一幅油画的白纸，很纯净，很自由，人们可以自定义上面的内容，尽情挥洒自己的创意。<br>下面我们就一起体验建站之旅！<br>Github地址：<a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">https://github.com/</a><br>Github Windows版客户端：<a href=\"https://windows.github.com/\" target=\"_blank\" rel=\"noopener\">https://windows.github.com/</a><br>首先要有一个Github账户，这个是前提。注册流程就不多说了，打开上面的地址，应该能找到注册入口。<br>创建好用户后登录，然后创建一个新的库，如下图：    </p>\n<p><img src=\"https://img-blog.csdn.net/20150308123930410\" alt=\"创建repo\"></p>\n<p>在创建新库的网页中，填写库名。名称必须为：username.github.io。例如，我的是XiaoWenHan.github.io。    </p>\n<p><img src=\"https://img-blog.csdn.net/20150308123931159\" alt=\"创建repo\"></p>\n<p>通常情况下，不会出现上图中红色的部分不会变红。我这里变为红色是因为之前创建过了，因为重名，所以有错误提示。<br>创建好之后，将其Clone到本地。可以通过上面提到过的客户端，如果你使用的是比Windows 7 还要低的Windows 版本，就需要使用命令行或其他的工具了，比如SourceTree。<br>下面尝试建立一个index.html，在Clone出来的本地目录下。比如，可以写一段Hello World。然后保存，上传。<br>上传成功后，打开浏览器，在地址栏处输入你的username.github.io。不出意外的话，应该能看到HelloWorld了。<br>到此，白纸已经准备好。各位读者，动手实践起来吧！   </p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天我们来谈一个有关建站的话题。<br>众所周知，Github有着程序员间的Facebook之称，很多知名的项目都是利用其公共Git服务进行开源，以供全球爱好者共享。Git的版本控制机制给我们提供了完善的版本管理功能，既能够团队协作，多地工作；又能在任何时间回滚到之前的任何版本，起到良好的备份作用。因此，在其上面搭建个人网站就变得很合适了。<br>和传统的个人博客系统不同，传统的个人博客只能提供博文的发表、评论等等，而在Github上面建站，就好比一幅油画的白纸，很纯净，很自由，人们可以自定义上面的内容，尽情挥洒自己的创意。<br>下面我们就一起体验建站之旅！<br>Github地址：<a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">https://github.com/</a><br>Github Windows版客户端：<a href=\"https://windows.github.com/\" target=\"_blank\" rel=\"noopener\">https://windows.github.com/</a><br>首先要有一个Github账户，这个是前提。注册流程就不多说了，打开上面的地址，应该能找到注册入口。<br>创建好用户后登录，然后创建一个新的库，如下图：    </p>\n<p><img src=\"https://img-blog.csdn.net/20150308123930410\" alt=\"创建repo\"></p>\n<p>在创建新库的网页中，填写库名。名称必须为：username.github.io。例如，我的是XiaoWenHan.github.io。    </p>\n<p><img src=\"https://img-blog.csdn.net/20150308123931159\" alt=\"创建repo\"></p>\n<p>通常情况下，不会出现上图中红色的部分不会变红。我这里变为红色是因为之前创建过了，因为重名，所以有错误提示。<br>创建好之后，将其Clone到本地。可以通过上面提到过的客户端，如果你使用的是比Windows 7 还要低的Windows 版本，就需要使用命令行或其他的工具了，比如SourceTree。<br>下面尝试建立一个index.html，在Clone出来的本地目录下。比如，可以写一段Hello World。然后保存，上传。<br>上传成功后，打开浏览器，在地址栏处输入你的username.github.io。不出意外的话，应该能看到HelloWorld了。<br>到此，白纸已经准备好。各位读者，动手实践起来吧！   </p>\n"},{"title":"Android 5.0(L) ToolBar(替代ActionBar) 实战（三）","date":"2014-11-01T06:35:44.000Z","_content":"\n《代码大全》一书中提到：当我们编程时，不要简单停留在“在一种编程语言上进行编程”，而是要“深入一种语言”编程。在前面两篇文章中，虽然初步实现了ViewPager+Tab的布局，但实际上还是有一些不足的。让我们把目光锁定在Tab：   \n![Tab标签样式](https://img-blog.csdn.net/20141101131904159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n可以发现，3个Tab加一起的宽度并没有填充屏幕整个宽度。实际上，Google这样的设计是为了应对多Tab的情形，当Tab总宽度超出屏幕宽度的时候，用户可以简单地通过滑动Tab看到后面未显示出来的Tab。这种情况其实还是比较多见的，比如众多的新闻阅读客户端和Google原生应用等等。   \n但是如果我们只有三个Tab，甚至只有两个Tab，想让整个Tab的宽度等于屏幕宽度，该如何做呢？第一反应自然是要略微折腾一下SlidingTabLayout.java的源码了。   \n经过研究发现，实际上如上图顶部Tab的实现通过HorizontalScrollView，然后add了一个又一个的view，这个View就是每个Tab的标题，而整个SlidingTabLayout是继承了HorizontalScrollView。   \n接下来的思路就很清晰了：首先获取屏幕的总宽度，然后传给SlidingTabLayout对象，在其类内部对每个Tab所占的宽度进行计算和分配，最后将每个Tab标题的视图add到HorizontalScrollView就OK了。   \n首先获取屏幕的宽度。这一操作我们在MainActivity中进行，下面列出这一段程序清单：   \n\n```\n// 获取屏幕宽度\nprivate int caculateScreenX() {\n\treturn getResources().getDisplayMetrics().widthPixels;\n}\n```\n\n获取到屏幕宽度之后，接下来就是把这个值传递给SlidingTabLayout。回顾一下用法，上一篇文章里面提到，我们在添加Tab导航栏的时候，仅仅是实例化了SlidingTabLayout的对象，然后调用了setViewPager()方法而已。那么，我们不妨在该方法上面添加一个参数，用来传递屏幕宽度。当然，我们需要在SlidingTabLayout中声明一个全局的int变量，用来存放每个Tab的宽度值：   \n\n```\npublic void setViewPager(ViewPager viewPager, int screenX) {\n    this.screenX = screenX / viewPager.viewPager.getAdapter().getCount();\n    mTabStrip.removeAllViews();\n    mViewPager = viewPager;\n    if (viewPager != null) {\n        viewPager.setOnPageChangeListener(new InternalViewPagerListener());\n        populateTabStrip();\n    }\n}\n```\n\n跟随该方法，找到populateTabStrip()方法，可以看到其中通过一个for循环以此添加了各个Tab视图。而每个Tab视图均通过createDefaultTabView()方法创建，因此该方法最为关键。  \n找到这个方法之后我们发现，每个Tab的标题View实际上是TextView，那么我们只需将每个TextView的宽度制定为刚刚计算出来的screenX（每个Tab的宽度）即可。具体可参看下面的代码清单：   \n\n```\nprotected TextView createDefaultTabView(Context context) {\n    TextView textView = new TextView(context);\n\ttextView.setGravity(Gravity.CENTER);\n\ttextView.setTextSize(TypedValue.COMPLEX_UNIT_SP, TAB_VIEW_TEXT_SIZE_SP);\n\ttextView.setTypeface(Typeface.DEFAULT_BOLD);\t\ttextView.setWidth(screenX);\n \n\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n\t\t// If we're running on Honeycomb or newer, then we can use the\n\t\t// Theme's\n\t\t// selectableItemBackground to ensure that the View has a pressed\n\t\t// state\n\t\tTypedValue outValue = new TypedValue();\n\t\tgetContext().getTheme().resolveAttribute(\n\t\t\t\t\tandroid.R.attr.selectableItemBackground, outValue, true);\n\t\ttextView.setBackgroundResource(outValue.resourceId);\n\t}\n \n\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {\n\t\t// If we're running on ICS or newer, enable all-caps to match the\n\t\t// Action Bar tab style\n\t\ttextView.setAllCaps(true);\n\t}\n \n\tint padding = (int) (TAB_VIEW_PADDING_DIPS * getResources()\n\t\t\t\t.getDisplayMetrics().density);\n\ttextView.setPadding(padding, padding, padding, padding);\n \n\treturn textView;\n}\n```\n\n最后，我们修改MainActivity，把计算好的屏幕宽度传给SlidingTabLayout，Ctrl+F11看看效果吧！   \n\n![等分的Tab样式](https://img-blog.csdn.net/20141101143436171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n不出意外的话，看到上图就说明已经成功了！   \n下面放上整个SlidingTabLayout修改后的类：   \n\n```\n/*\n * Copyright (C) 2013 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n \npackage com.xwh.toolbardemo.view;\n \nimport android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.graphics.Typeface;\nimport android.os.Build;\nimport android.support.v4.view.PagerAdapter;\nimport android.support.v4.view.ViewPager;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.util.TypedValue;\nimport android.view.Gravity;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.widget.HorizontalScrollView;\nimport android.widget.TextView;\n \n/**\n * To be used with ViewPager to provide a tab indicator component which give\n * constant feedback as to the user's scroll progress.\n * <p>\n * To use the component, simply add it to your view hierarchy. Then in your\n * {@link android.app.Activity} or {@link android.support.v4.app.Fragment} call\n * {@link #setViewPager(ViewPager)} providing it the ViewPager this layout is\n * being used for.\n * <p>\n * The colors can be customized in two ways. The first and simplest is to\n * provide an array of colors via {@link #setSelectedIndicatorColors(int...)}\n * and {@link #setDividerColors(int...)}. The alternative is via the\n * {@link TabColorizer} interface which provides you complete control over which\n * color is used for any individual position.\n * <p>\n * The views used as tabs can be customized by calling\n * {@link #setCustomTabView(int, int)}, providing the layout ID of your custom\n * layout.\n */\npublic class SlidingTabLayout extends HorizontalScrollView {\n \n\t/**\n\t * Allows complete control over the colors drawn in the tab layout. Set with\n\t * {@link #setCustomTabColorizer(TabColorizer)}.\n\t */\n\tpublic interface TabColorizer {\n \n\t\t/**\n\t\t * @return return the color of the indicator used when {@code position}\n\t\t *         is selected.\n\t\t */\n\t\tint getIndicatorColor(int position);\n \n\t\t/**\n\t\t * @return return the color of the divider drawn to the right of\n\t\t *         {@code position}.\n\t\t */\n\t\tint getDividerColor(int position);\n \n\t}\n \n\tprivate static final int TITLE_OFFSET_DIPS = 24;\n\tprivate static final int TAB_VIEW_PADDING_DIPS = 16;\n\tprivate static final int TAB_VIEW_TEXT_SIZE_SP = 12;\n \n\tprivate int mTitleOffset;\n \n\tprivate int mTabViewLayoutId;\n\tprivate int mTabViewTextViewId;\n \n\tprivate ViewPager mViewPager;\n\tprivate ViewPager.OnPageChangeListener mViewPagerPageChangeListener;\n \n\tprivate final SlidingTabStrip mTabStrip;\n \n\tprivate int screenX;\n \n\tpublic SlidingTabLayout(Context context) {\n\t\tthis(context, null);\n\t}\n \n\tpublic SlidingTabLayout(Context context, AttributeSet attrs) {\n\t\tthis(context, attrs, 0);\n\t}\n \n\tpublic SlidingTabLayout(Context context, AttributeSet attrs, int defStyle) {\n\t\tsuper(context, attrs, defStyle);\n \n\t\t// Disable the Scroll Bar\n\t\tsetHorizontalScrollBarEnabled(false);\n\t\t// Make sure that the Tab Strips fills this View\n\t\tsetFillViewport(true);\n \n\t\tmTitleOffset = (int) (TITLE_OFFSET_DIPS * getResources()\n\t\t\t\t.getDisplayMetrics().density);\n \n\t\tmTabStrip = new SlidingTabStrip(context);\n\t\taddView(mTabStrip, LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);\n\t}\n \n\t/**\n\t * Set the custom {@link TabColorizer} to be used.\n\t * \n\t * If you only require simple custmisation then you can use\n\t * {@link #setSelectedIndicatorColors(int...)} and\n\t * {@link #setDividerColors(int...)} to achieve similar effects.\n\t */\n\tpublic void setCustomTabColorizer(TabColorizer tabColorizer) {\n\t\tmTabStrip.setCustomTabColorizer(tabColorizer);\n\t}\n \n\t/**\n\t * Sets the colors to be used for indicating the selected tab. These colors\n\t * are treated as a circular array. Providing one color will mean that all\n\t * tabs are indicated with the same color.\n\t */\n\tpublic void setSelectedIndicatorColors(int... colors) {\n\t\tmTabStrip.setSelectedIndicatorColors(colors);\n\t}\n \n\t/**\n\t * Sets the colors to be used for tab dividers. These colors are treated as\n\t * a circular array. Providing one color will mean that all tabs are\n\t * indicated with the same color.\n\t */\n\tpublic void setDividerColors(int... colors) {\n\t\tmTabStrip.setDividerColors(colors);\n\t}\n \n\t/**\n\t * Set the {@link ViewPager.OnPageChangeListener}. When using\n\t * {@link SlidingTabLayout} you are required to set any\n\t * {@link ViewPager.OnPageChangeListener} through this method. This is so\n\t * that the layout can update it's scroll position correctly.\n\t * \n\t * @see ViewPager#setOnPageChangeListener(ViewPager.OnPageChangeListener)\n\t */\n\tpublic void setOnPageChangeListener(ViewPager.OnPageChangeListener listener) {\n\t\tmViewPagerPageChangeListener = listener;\n\t}\n \n\t/**\n\t * Set the custom layout to be inflated for the tab views.\n\t * \n\t * @param layoutResId\n\t *            Layout id to be inflated\n\t * @param textViewId\n\t *            id of the {@link TextView} in the inflated view\n\t */\n\tpublic void setCustomTabView(int layoutResId, int textViewId) {\n\t\tmTabViewLayoutId = layoutResId;\n\t\tmTabViewTextViewId = textViewId;\n\t}\n \n\t/**\n\t * Sets the associated view pager. Note that the assumption here is that the\n\t * pager content (number of tabs and tab titles) does not change after this\n\t * call has been made.\n\t */\n\tpublic void setViewPager(ViewPager viewPager, int screenX) {\n\t\tthis.screenX = (screenX / viewPager.getAdapter().getCount());\n\t\tmTabStrip.removeAllViews();\n \n\t\tmViewPager = viewPager;\n\t\tif (viewPager != null) {\n\t\t\tviewPager.setOnPageChangeListener(new InternalViewPagerListener());\n\t\t\tpopulateTabStrip();\n\t\t}\n\t}\n \n\t/**\n\t * Create a default view to be used for tabs. This is called if a custom tab\n\t * view is not set via {@link #setCustomTabView(int, int)}.\n\t */\n\t@SuppressLint(\"NewApi\")\n\tprotected TextView createDefaultTabView(Context context) {\n\t\tTextView textView = new TextView(context);\n\t\ttextView.setGravity(Gravity.CENTER);\n\t\ttextView.setTextSize(TypedValue.COMPLEX_UNIT_SP, TAB_VIEW_TEXT_SIZE_SP);\n\t\ttextView.setTypeface(Typeface.DEFAULT_BOLD);\n\t\ttextView.setWidth(screenX);\n \n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n\t\t\t// If we're running on Honeycomb or newer, then we can use the\n\t\t\t// Theme's\n\t\t\t// selectableItemBackground to ensure that the View has a pressed\n\t\t\t// state\n\t\t\tTypedValue outValue = new TypedValue();\n\t\t\tgetContext().getTheme().resolveAttribute(\n\t\t\t\t\tandroid.R.attr.selectableItemBackground, outValue, true);\n\t\t\ttextView.setBackgroundResource(outValue.resourceId);\n\t\t}\n \n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {\n\t\t\t// If we're running on ICS or newer, enable all-caps to match the\n\t\t\t// Action Bar tab style\n\t\t\ttextView.setAllCaps(true);\n\t\t}\n \n\t\tint padding = (int) (TAB_VIEW_PADDING_DIPS * getResources()\n\t\t\t\t.getDisplayMetrics().density);\n\t\ttextView.setPadding(padding, padding, padding, padding);\n \n\t\treturn textView;\n\t}\n \n\tprivate void populateTabStrip() {\n\t\tfinal PagerAdapter adapter = mViewPager.getAdapter();\n\t\tfinal View.OnClickListener tabClickListener = new TabClickListener();\n \n\t\tfor (int i = 0; i < adapter.getCount(); i++) {\n\t\t\tView tabView = null;\n\t\t\tTextView tabTitleView = null;\n \n\t\t\tif (mTabViewLayoutId != 0) {\n\t\t\t\t// If there is a custom tab view layout id set, try and inflate\n\t\t\t\t// it\n\t\t\t\ttabView = LayoutInflater.from(getContext()).inflate(\n\t\t\t\t\t\tmTabViewLayoutId, mTabStrip, false);\n\t\t\t\ttabTitleView = (TextView) tabView\n\t\t\t\t\t\t.findViewById(mTabViewTextViewId);\n\t\t\t}\n \n\t\t\tif (tabView == null) {\n\t\t\t\ttabView = createDefaultTabView(getContext());\n\t\t\t}\n \n\t\t\tif (tabTitleView == null && TextView.class.isInstance(tabView)) {\n\t\t\t\ttabTitleView = (TextView) tabView;\n\t\t\t}\n \n\t\t\ttabTitleView.setText(adapter.getPageTitle(i));\n\t\t\ttabView.setOnClickListener(tabClickListener);\n \n\t\t\tmTabStrip.addView(tabView);\n\t\t}\n\t}\n \n\t@Override\n\tprotected void onAttachedToWindow() {\n\t\tsuper.onAttachedToWindow();\n \n\t\tif (mViewPager != null) {\n\t\t\tscrollToTab(mViewPager.getCurrentItem(), 0);\n\t\t}\n\t}\n \n\tprivate void scrollToTab(int tabIndex, int positionOffset) {\n\t\tfinal int tabStripChildCount = mTabStrip.getChildCount();\n\t\tif (tabStripChildCount == 0 || tabIndex < 0\n\t\t\t\t|| tabIndex >= tabStripChildCount) {\n\t\t\treturn;\n\t\t}\n \n\t\tView selectedChild = mTabStrip.getChildAt(tabIndex);\n\t\tif (selectedChild != null) {\n\t\t\tint targetScrollX = selectedChild.getLeft() + positionOffset;\n \n\t\t\tif (tabIndex > 0 || positionOffset > 0) {\n\t\t\t\t// If we're not at the first child and are mid-scroll, make sure\n\t\t\t\t// we obey the offset\n\t\t\t\ttargetScrollX -= mTitleOffset;\n\t\t\t}\n \n\t\t\tscrollTo(targetScrollX, 0);\n\t\t}\n\t}\n \n\tprivate class InternalViewPagerListener implements\n\t\t\tViewPager.OnPageChangeListener {\n\t\tprivate int mScrollState;\n \n\t\t@Override\n\t\tpublic void onPageScrolled(int position, float positionOffset,\n\t\t\t\tint positionOffsetPixels) {\n\t\t\tint tabStripChildCount = mTabStrip.getChildCount();\n\t\t\tif ((tabStripChildCount == 0) || (position < 0)\n\t\t\t\t\t|| (position >= tabStripChildCount)) {\n\t\t\t\treturn;\n\t\t\t}\n \n\t\t\tmTabStrip.onViewPagerPageChanged(position, positionOffset);\n \n\t\t\tView selectedTitle = mTabStrip.getChildAt(position);\n\t\t\tint extraOffset = (selectedTitle != null) ? (int) (positionOffset * selectedTitle\n\t\t\t\t\t.getWidth()) : 0;\n\t\t\tscrollToTab(position, extraOffset);\n \n\t\t\tif (mViewPagerPageChangeListener != null) {\n\t\t\t\tmViewPagerPageChangeListener.onPageScrolled(position,\n\t\t\t\t\t\tpositionOffset, positionOffsetPixels);\n\t\t\t}\n\t\t}\n \n\t\t@Override\n\t\tpublic void onPageScrollStateChanged(int state) {\n\t\t\tmScrollState = state;\n \n\t\t\tif (mViewPagerPageChangeListener != null) {\n\t\t\t\tmViewPagerPageChangeListener.onPageScrollStateChanged(state);\n\t\t\t}\n\t\t}\n \n\t\t@Override\n\t\tpublic void onPageSelected(int position) {\n\t\t\tif (mScrollState == ViewPager.SCROLL_STATE_IDLE) {\n\t\t\t\tmTabStrip.onViewPagerPageChanged(position, 0f);\n\t\t\t\tscrollToTab(position, 0);\n\t\t\t}\n \n\t\t\tif (mViewPagerPageChangeListener != null) {\n\t\t\t\tmViewPagerPageChangeListener.onPageSelected(position);\n\t\t\t}\n\t\t}\n \n\t}\n \n\tprivate class TabClickListener implements View.OnClickListener {\n\t\t@Override\n\t\tpublic void onClick(View v) {\n\t\t\tfor (int i = 0; i < mTabStrip.getChildCount(); i++) {\n\t\t\t\tif (v == mTabStrip.getChildAt(i)) {\n\t\t\t\t\tmViewPager.setCurrentItem(i);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n \n}\n```\n\n这一篇到此结束。下一篇将讨论菜单的添加和关于ToolBar的更多精彩用法。","source":"_posts/Android 5.0(L) ToolBar(替代ActionBar) 实战（三）.md","raw":"---\ntitle: Android 5.0(L) ToolBar(替代ActionBar) 实战（三）\ndate: 2014-11-01 14:35:44\ntags: Android\ncategories: 编程世界\n---\n\n《代码大全》一书中提到：当我们编程时，不要简单停留在“在一种编程语言上进行编程”，而是要“深入一种语言”编程。在前面两篇文章中，虽然初步实现了ViewPager+Tab的布局，但实际上还是有一些不足的。让我们把目光锁定在Tab：   \n![Tab标签样式](https://img-blog.csdn.net/20141101131904159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n可以发现，3个Tab加一起的宽度并没有填充屏幕整个宽度。实际上，Google这样的设计是为了应对多Tab的情形，当Tab总宽度超出屏幕宽度的时候，用户可以简单地通过滑动Tab看到后面未显示出来的Tab。这种情况其实还是比较多见的，比如众多的新闻阅读客户端和Google原生应用等等。   \n但是如果我们只有三个Tab，甚至只有两个Tab，想让整个Tab的宽度等于屏幕宽度，该如何做呢？第一反应自然是要略微折腾一下SlidingTabLayout.java的源码了。   \n经过研究发现，实际上如上图顶部Tab的实现通过HorizontalScrollView，然后add了一个又一个的view，这个View就是每个Tab的标题，而整个SlidingTabLayout是继承了HorizontalScrollView。   \n接下来的思路就很清晰了：首先获取屏幕的总宽度，然后传给SlidingTabLayout对象，在其类内部对每个Tab所占的宽度进行计算和分配，最后将每个Tab标题的视图add到HorizontalScrollView就OK了。   \n首先获取屏幕的宽度。这一操作我们在MainActivity中进行，下面列出这一段程序清单：   \n\n```\n// 获取屏幕宽度\nprivate int caculateScreenX() {\n\treturn getResources().getDisplayMetrics().widthPixels;\n}\n```\n\n获取到屏幕宽度之后，接下来就是把这个值传递给SlidingTabLayout。回顾一下用法，上一篇文章里面提到，我们在添加Tab导航栏的时候，仅仅是实例化了SlidingTabLayout的对象，然后调用了setViewPager()方法而已。那么，我们不妨在该方法上面添加一个参数，用来传递屏幕宽度。当然，我们需要在SlidingTabLayout中声明一个全局的int变量，用来存放每个Tab的宽度值：   \n\n```\npublic void setViewPager(ViewPager viewPager, int screenX) {\n    this.screenX = screenX / viewPager.viewPager.getAdapter().getCount();\n    mTabStrip.removeAllViews();\n    mViewPager = viewPager;\n    if (viewPager != null) {\n        viewPager.setOnPageChangeListener(new InternalViewPagerListener());\n        populateTabStrip();\n    }\n}\n```\n\n跟随该方法，找到populateTabStrip()方法，可以看到其中通过一个for循环以此添加了各个Tab视图。而每个Tab视图均通过createDefaultTabView()方法创建，因此该方法最为关键。  \n找到这个方法之后我们发现，每个Tab的标题View实际上是TextView，那么我们只需将每个TextView的宽度制定为刚刚计算出来的screenX（每个Tab的宽度）即可。具体可参看下面的代码清单：   \n\n```\nprotected TextView createDefaultTabView(Context context) {\n    TextView textView = new TextView(context);\n\ttextView.setGravity(Gravity.CENTER);\n\ttextView.setTextSize(TypedValue.COMPLEX_UNIT_SP, TAB_VIEW_TEXT_SIZE_SP);\n\ttextView.setTypeface(Typeface.DEFAULT_BOLD);\t\ttextView.setWidth(screenX);\n \n\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n\t\t// If we're running on Honeycomb or newer, then we can use the\n\t\t// Theme's\n\t\t// selectableItemBackground to ensure that the View has a pressed\n\t\t// state\n\t\tTypedValue outValue = new TypedValue();\n\t\tgetContext().getTheme().resolveAttribute(\n\t\t\t\t\tandroid.R.attr.selectableItemBackground, outValue, true);\n\t\ttextView.setBackgroundResource(outValue.resourceId);\n\t}\n \n\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {\n\t\t// If we're running on ICS or newer, enable all-caps to match the\n\t\t// Action Bar tab style\n\t\ttextView.setAllCaps(true);\n\t}\n \n\tint padding = (int) (TAB_VIEW_PADDING_DIPS * getResources()\n\t\t\t\t.getDisplayMetrics().density);\n\ttextView.setPadding(padding, padding, padding, padding);\n \n\treturn textView;\n}\n```\n\n最后，我们修改MainActivity，把计算好的屏幕宽度传给SlidingTabLayout，Ctrl+F11看看效果吧！   \n\n![等分的Tab样式](https://img-blog.csdn.net/20141101143436171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n不出意外的话，看到上图就说明已经成功了！   \n下面放上整个SlidingTabLayout修改后的类：   \n\n```\n/*\n * Copyright (C) 2013 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n \npackage com.xwh.toolbardemo.view;\n \nimport android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.graphics.Typeface;\nimport android.os.Build;\nimport android.support.v4.view.PagerAdapter;\nimport android.support.v4.view.ViewPager;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.util.TypedValue;\nimport android.view.Gravity;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.widget.HorizontalScrollView;\nimport android.widget.TextView;\n \n/**\n * To be used with ViewPager to provide a tab indicator component which give\n * constant feedback as to the user's scroll progress.\n * <p>\n * To use the component, simply add it to your view hierarchy. Then in your\n * {@link android.app.Activity} or {@link android.support.v4.app.Fragment} call\n * {@link #setViewPager(ViewPager)} providing it the ViewPager this layout is\n * being used for.\n * <p>\n * The colors can be customized in two ways. The first and simplest is to\n * provide an array of colors via {@link #setSelectedIndicatorColors(int...)}\n * and {@link #setDividerColors(int...)}. The alternative is via the\n * {@link TabColorizer} interface which provides you complete control over which\n * color is used for any individual position.\n * <p>\n * The views used as tabs can be customized by calling\n * {@link #setCustomTabView(int, int)}, providing the layout ID of your custom\n * layout.\n */\npublic class SlidingTabLayout extends HorizontalScrollView {\n \n\t/**\n\t * Allows complete control over the colors drawn in the tab layout. Set with\n\t * {@link #setCustomTabColorizer(TabColorizer)}.\n\t */\n\tpublic interface TabColorizer {\n \n\t\t/**\n\t\t * @return return the color of the indicator used when {@code position}\n\t\t *         is selected.\n\t\t */\n\t\tint getIndicatorColor(int position);\n \n\t\t/**\n\t\t * @return return the color of the divider drawn to the right of\n\t\t *         {@code position}.\n\t\t */\n\t\tint getDividerColor(int position);\n \n\t}\n \n\tprivate static final int TITLE_OFFSET_DIPS = 24;\n\tprivate static final int TAB_VIEW_PADDING_DIPS = 16;\n\tprivate static final int TAB_VIEW_TEXT_SIZE_SP = 12;\n \n\tprivate int mTitleOffset;\n \n\tprivate int mTabViewLayoutId;\n\tprivate int mTabViewTextViewId;\n \n\tprivate ViewPager mViewPager;\n\tprivate ViewPager.OnPageChangeListener mViewPagerPageChangeListener;\n \n\tprivate final SlidingTabStrip mTabStrip;\n \n\tprivate int screenX;\n \n\tpublic SlidingTabLayout(Context context) {\n\t\tthis(context, null);\n\t}\n \n\tpublic SlidingTabLayout(Context context, AttributeSet attrs) {\n\t\tthis(context, attrs, 0);\n\t}\n \n\tpublic SlidingTabLayout(Context context, AttributeSet attrs, int defStyle) {\n\t\tsuper(context, attrs, defStyle);\n \n\t\t// Disable the Scroll Bar\n\t\tsetHorizontalScrollBarEnabled(false);\n\t\t// Make sure that the Tab Strips fills this View\n\t\tsetFillViewport(true);\n \n\t\tmTitleOffset = (int) (TITLE_OFFSET_DIPS * getResources()\n\t\t\t\t.getDisplayMetrics().density);\n \n\t\tmTabStrip = new SlidingTabStrip(context);\n\t\taddView(mTabStrip, LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);\n\t}\n \n\t/**\n\t * Set the custom {@link TabColorizer} to be used.\n\t * \n\t * If you only require simple custmisation then you can use\n\t * {@link #setSelectedIndicatorColors(int...)} and\n\t * {@link #setDividerColors(int...)} to achieve similar effects.\n\t */\n\tpublic void setCustomTabColorizer(TabColorizer tabColorizer) {\n\t\tmTabStrip.setCustomTabColorizer(tabColorizer);\n\t}\n \n\t/**\n\t * Sets the colors to be used for indicating the selected tab. These colors\n\t * are treated as a circular array. Providing one color will mean that all\n\t * tabs are indicated with the same color.\n\t */\n\tpublic void setSelectedIndicatorColors(int... colors) {\n\t\tmTabStrip.setSelectedIndicatorColors(colors);\n\t}\n \n\t/**\n\t * Sets the colors to be used for tab dividers. These colors are treated as\n\t * a circular array. Providing one color will mean that all tabs are\n\t * indicated with the same color.\n\t */\n\tpublic void setDividerColors(int... colors) {\n\t\tmTabStrip.setDividerColors(colors);\n\t}\n \n\t/**\n\t * Set the {@link ViewPager.OnPageChangeListener}. When using\n\t * {@link SlidingTabLayout} you are required to set any\n\t * {@link ViewPager.OnPageChangeListener} through this method. This is so\n\t * that the layout can update it's scroll position correctly.\n\t * \n\t * @see ViewPager#setOnPageChangeListener(ViewPager.OnPageChangeListener)\n\t */\n\tpublic void setOnPageChangeListener(ViewPager.OnPageChangeListener listener) {\n\t\tmViewPagerPageChangeListener = listener;\n\t}\n \n\t/**\n\t * Set the custom layout to be inflated for the tab views.\n\t * \n\t * @param layoutResId\n\t *            Layout id to be inflated\n\t * @param textViewId\n\t *            id of the {@link TextView} in the inflated view\n\t */\n\tpublic void setCustomTabView(int layoutResId, int textViewId) {\n\t\tmTabViewLayoutId = layoutResId;\n\t\tmTabViewTextViewId = textViewId;\n\t}\n \n\t/**\n\t * Sets the associated view pager. Note that the assumption here is that the\n\t * pager content (number of tabs and tab titles) does not change after this\n\t * call has been made.\n\t */\n\tpublic void setViewPager(ViewPager viewPager, int screenX) {\n\t\tthis.screenX = (screenX / viewPager.getAdapter().getCount());\n\t\tmTabStrip.removeAllViews();\n \n\t\tmViewPager = viewPager;\n\t\tif (viewPager != null) {\n\t\t\tviewPager.setOnPageChangeListener(new InternalViewPagerListener());\n\t\t\tpopulateTabStrip();\n\t\t}\n\t}\n \n\t/**\n\t * Create a default view to be used for tabs. This is called if a custom tab\n\t * view is not set via {@link #setCustomTabView(int, int)}.\n\t */\n\t@SuppressLint(\"NewApi\")\n\tprotected TextView createDefaultTabView(Context context) {\n\t\tTextView textView = new TextView(context);\n\t\ttextView.setGravity(Gravity.CENTER);\n\t\ttextView.setTextSize(TypedValue.COMPLEX_UNIT_SP, TAB_VIEW_TEXT_SIZE_SP);\n\t\ttextView.setTypeface(Typeface.DEFAULT_BOLD);\n\t\ttextView.setWidth(screenX);\n \n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n\t\t\t// If we're running on Honeycomb or newer, then we can use the\n\t\t\t// Theme's\n\t\t\t// selectableItemBackground to ensure that the View has a pressed\n\t\t\t// state\n\t\t\tTypedValue outValue = new TypedValue();\n\t\t\tgetContext().getTheme().resolveAttribute(\n\t\t\t\t\tandroid.R.attr.selectableItemBackground, outValue, true);\n\t\t\ttextView.setBackgroundResource(outValue.resourceId);\n\t\t}\n \n\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {\n\t\t\t// If we're running on ICS or newer, enable all-caps to match the\n\t\t\t// Action Bar tab style\n\t\t\ttextView.setAllCaps(true);\n\t\t}\n \n\t\tint padding = (int) (TAB_VIEW_PADDING_DIPS * getResources()\n\t\t\t\t.getDisplayMetrics().density);\n\t\ttextView.setPadding(padding, padding, padding, padding);\n \n\t\treturn textView;\n\t}\n \n\tprivate void populateTabStrip() {\n\t\tfinal PagerAdapter adapter = mViewPager.getAdapter();\n\t\tfinal View.OnClickListener tabClickListener = new TabClickListener();\n \n\t\tfor (int i = 0; i < adapter.getCount(); i++) {\n\t\t\tView tabView = null;\n\t\t\tTextView tabTitleView = null;\n \n\t\t\tif (mTabViewLayoutId != 0) {\n\t\t\t\t// If there is a custom tab view layout id set, try and inflate\n\t\t\t\t// it\n\t\t\t\ttabView = LayoutInflater.from(getContext()).inflate(\n\t\t\t\t\t\tmTabViewLayoutId, mTabStrip, false);\n\t\t\t\ttabTitleView = (TextView) tabView\n\t\t\t\t\t\t.findViewById(mTabViewTextViewId);\n\t\t\t}\n \n\t\t\tif (tabView == null) {\n\t\t\t\ttabView = createDefaultTabView(getContext());\n\t\t\t}\n \n\t\t\tif (tabTitleView == null && TextView.class.isInstance(tabView)) {\n\t\t\t\ttabTitleView = (TextView) tabView;\n\t\t\t}\n \n\t\t\ttabTitleView.setText(adapter.getPageTitle(i));\n\t\t\ttabView.setOnClickListener(tabClickListener);\n \n\t\t\tmTabStrip.addView(tabView);\n\t\t}\n\t}\n \n\t@Override\n\tprotected void onAttachedToWindow() {\n\t\tsuper.onAttachedToWindow();\n \n\t\tif (mViewPager != null) {\n\t\t\tscrollToTab(mViewPager.getCurrentItem(), 0);\n\t\t}\n\t}\n \n\tprivate void scrollToTab(int tabIndex, int positionOffset) {\n\t\tfinal int tabStripChildCount = mTabStrip.getChildCount();\n\t\tif (tabStripChildCount == 0 || tabIndex < 0\n\t\t\t\t|| tabIndex >= tabStripChildCount) {\n\t\t\treturn;\n\t\t}\n \n\t\tView selectedChild = mTabStrip.getChildAt(tabIndex);\n\t\tif (selectedChild != null) {\n\t\t\tint targetScrollX = selectedChild.getLeft() + positionOffset;\n \n\t\t\tif (tabIndex > 0 || positionOffset > 0) {\n\t\t\t\t// If we're not at the first child and are mid-scroll, make sure\n\t\t\t\t// we obey the offset\n\t\t\t\ttargetScrollX -= mTitleOffset;\n\t\t\t}\n \n\t\t\tscrollTo(targetScrollX, 0);\n\t\t}\n\t}\n \n\tprivate class InternalViewPagerListener implements\n\t\t\tViewPager.OnPageChangeListener {\n\t\tprivate int mScrollState;\n \n\t\t@Override\n\t\tpublic void onPageScrolled(int position, float positionOffset,\n\t\t\t\tint positionOffsetPixels) {\n\t\t\tint tabStripChildCount = mTabStrip.getChildCount();\n\t\t\tif ((tabStripChildCount == 0) || (position < 0)\n\t\t\t\t\t|| (position >= tabStripChildCount)) {\n\t\t\t\treturn;\n\t\t\t}\n \n\t\t\tmTabStrip.onViewPagerPageChanged(position, positionOffset);\n \n\t\t\tView selectedTitle = mTabStrip.getChildAt(position);\n\t\t\tint extraOffset = (selectedTitle != null) ? (int) (positionOffset * selectedTitle\n\t\t\t\t\t.getWidth()) : 0;\n\t\t\tscrollToTab(position, extraOffset);\n \n\t\t\tif (mViewPagerPageChangeListener != null) {\n\t\t\t\tmViewPagerPageChangeListener.onPageScrolled(position,\n\t\t\t\t\t\tpositionOffset, positionOffsetPixels);\n\t\t\t}\n\t\t}\n \n\t\t@Override\n\t\tpublic void onPageScrollStateChanged(int state) {\n\t\t\tmScrollState = state;\n \n\t\t\tif (mViewPagerPageChangeListener != null) {\n\t\t\t\tmViewPagerPageChangeListener.onPageScrollStateChanged(state);\n\t\t\t}\n\t\t}\n \n\t\t@Override\n\t\tpublic void onPageSelected(int position) {\n\t\t\tif (mScrollState == ViewPager.SCROLL_STATE_IDLE) {\n\t\t\t\tmTabStrip.onViewPagerPageChanged(position, 0f);\n\t\t\t\tscrollToTab(position, 0);\n\t\t\t}\n \n\t\t\tif (mViewPagerPageChangeListener != null) {\n\t\t\t\tmViewPagerPageChangeListener.onPageSelected(position);\n\t\t\t}\n\t\t}\n \n\t}\n \n\tprivate class TabClickListener implements View.OnClickListener {\n\t\t@Override\n\t\tpublic void onClick(View v) {\n\t\t\tfor (int i = 0; i < mTabStrip.getChildCount(); i++) {\n\t\t\t\tif (v == mTabStrip.getChildAt(i)) {\n\t\t\t\t\tmViewPager.setCurrentItem(i);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n \n}\n```\n\n这一篇到此结束。下一篇将讨论菜单的添加和关于ToolBar的更多精彩用法。","slug":"Android 5.0(L) ToolBar(替代ActionBar) 实战（三）","published":1,"updated":"2019-07-31T04:10:10.050Z","_id":"cjyqq3tko0020fkqdydwxf32w","comments":1,"layout":"post","photos":[],"link":"","content":"<p>《代码大全》一书中提到：当我们编程时，不要简单停留在“在一种编程语言上进行编程”，而是要“深入一种语言”编程。在前面两篇文章中，虽然初步实现了ViewPager+Tab的布局，但实际上还是有一些不足的。让我们把目光锁定在Tab：<br><img src=\"https://img-blog.csdn.net/20141101131904159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"Tab标签样式\"></p>\n<p>可以发现，3个Tab加一起的宽度并没有填充屏幕整个宽度。实际上，Google这样的设计是为了应对多Tab的情形，当Tab总宽度超出屏幕宽度的时候，用户可以简单地通过滑动Tab看到后面未显示出来的Tab。这种情况其实还是比较多见的，比如众多的新闻阅读客户端和Google原生应用等等。<br>但是如果我们只有三个Tab，甚至只有两个Tab，想让整个Tab的宽度等于屏幕宽度，该如何做呢？第一反应自然是要略微折腾一下SlidingTabLayout.java的源码了。<br>经过研究发现，实际上如上图顶部Tab的实现通过HorizontalScrollView，然后add了一个又一个的view，这个View就是每个Tab的标题，而整个SlidingTabLayout是继承了HorizontalScrollView。<br>接下来的思路就很清晰了：首先获取屏幕的总宽度，然后传给SlidingTabLayout对象，在其类内部对每个Tab所占的宽度进行计算和分配，最后将每个Tab标题的视图add到HorizontalScrollView就OK了。<br>首先获取屏幕的宽度。这一操作我们在MainActivity中进行，下面列出这一段程序清单：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获取屏幕宽度</span><br><span class=\"line\">private int caculateScreenX() &#123;</span><br><span class=\"line\">\treturn getResources().getDisplayMetrics().widthPixels;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>获取到屏幕宽度之后，接下来就是把这个值传递给SlidingTabLayout。回顾一下用法，上一篇文章里面提到，我们在添加Tab导航栏的时候，仅仅是实例化了SlidingTabLayout的对象，然后调用了setViewPager()方法而已。那么，我们不妨在该方法上面添加一个参数，用来传递屏幕宽度。当然，我们需要在SlidingTabLayout中声明一个全局的int变量，用来存放每个Tab的宽度值：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void setViewPager(ViewPager viewPager, int screenX) &#123;</span><br><span class=\"line\">    this.screenX = screenX / viewPager.viewPager.getAdapter().getCount();</span><br><span class=\"line\">    mTabStrip.removeAllViews();</span><br><span class=\"line\">    mViewPager = viewPager;</span><br><span class=\"line\">    if (viewPager != null) &#123;</span><br><span class=\"line\">        viewPager.setOnPageChangeListener(new InternalViewPagerListener());</span><br><span class=\"line\">        populateTabStrip();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>跟随该方法，找到populateTabStrip()方法，可以看到其中通过一个for循环以此添加了各个Tab视图。而每个Tab视图均通过createDefaultTabView()方法创建，因此该方法最为关键。<br>找到这个方法之后我们发现，每个Tab的标题View实际上是TextView，那么我们只需将每个TextView的宽度制定为刚刚计算出来的screenX（每个Tab的宽度）即可。具体可参看下面的代码清单：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected TextView createDefaultTabView(Context context) &#123;</span><br><span class=\"line\">    TextView textView = new TextView(context);</span><br><span class=\"line\">\ttextView.setGravity(Gravity.CENTER);</span><br><span class=\"line\">\ttextView.setTextSize(TypedValue.COMPLEX_UNIT_SP, TAB_VIEW_TEXT_SIZE_SP);</span><br><span class=\"line\">\ttextView.setTypeface(Typeface.DEFAULT_BOLD);\t\ttextView.setWidth(screenX);</span><br><span class=\"line\"> </span><br><span class=\"line\">\tif (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class=\"line\">\t\t// If we&apos;re running on Honeycomb or newer, then we can use the</span><br><span class=\"line\">\t\t// Theme&apos;s</span><br><span class=\"line\">\t\t// selectableItemBackground to ensure that the View has a pressed</span><br><span class=\"line\">\t\t// state</span><br><span class=\"line\">\t\tTypedValue outValue = new TypedValue();</span><br><span class=\"line\">\t\tgetContext().getTheme().resolveAttribute(</span><br><span class=\"line\">\t\t\t\t\tandroid.R.attr.selectableItemBackground, outValue, true);</span><br><span class=\"line\">\t\ttextView.setBackgroundResource(outValue.resourceId);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tif (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class=\"line\">\t\t// If we&apos;re running on ICS or newer, enable all-caps to match the</span><br><span class=\"line\">\t\t// Action Bar tab style</span><br><span class=\"line\">\t\ttextView.setAllCaps(true);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tint padding = (int) (TAB_VIEW_PADDING_DIPS * getResources()</span><br><span class=\"line\">\t\t\t\t.getDisplayMetrics().density);</span><br><span class=\"line\">\ttextView.setPadding(padding, padding, padding, padding);</span><br><span class=\"line\"> </span><br><span class=\"line\">\treturn textView;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，我们修改MainActivity，把计算好的屏幕宽度传给SlidingTabLayout，Ctrl+F11看看效果吧！   </p>\n<p><img src=\"https://img-blog.csdn.net/20141101143436171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"等分的Tab样式\"></p>\n<p>不出意外的话，看到上图就说明已经成功了！<br>下面放上整个SlidingTabLayout修改后的类：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * Copyright (C) 2013 The Android Open Source Project</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class=\"line\"> * you may not use this file except in compliance with the License.</span><br><span class=\"line\"> * You may obtain a copy of the License at</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *      http://www.apache.org/licenses/LICENSE-2.0</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * Unless required by applicable law or agreed to in writing, software</span><br><span class=\"line\"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class=\"line\"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class=\"line\"> * See the License for the specific language governing permissions and</span><br><span class=\"line\"> * limitations under the License.</span><br><span class=\"line\"> */</span><br><span class=\"line\"> </span><br><span class=\"line\">package com.xwh.toolbardemo.view;</span><br><span class=\"line\"> </span><br><span class=\"line\">import android.annotation.SuppressLint;</span><br><span class=\"line\">import android.content.Context;</span><br><span class=\"line\">import android.graphics.Typeface;</span><br><span class=\"line\">import android.os.Build;</span><br><span class=\"line\">import android.support.v4.view.PagerAdapter;</span><br><span class=\"line\">import android.support.v4.view.ViewPager;</span><br><span class=\"line\">import android.util.AttributeSet;</span><br><span class=\"line\">import android.util.Log;</span><br><span class=\"line\">import android.util.TypedValue;</span><br><span class=\"line\">import android.view.Gravity;</span><br><span class=\"line\">import android.view.LayoutInflater;</span><br><span class=\"line\">import android.view.View;</span><br><span class=\"line\">import android.widget.HorizontalScrollView;</span><br><span class=\"line\">import android.widget.TextView;</span><br><span class=\"line\"> </span><br><span class=\"line\">/**</span><br><span class=\"line\"> * To be used with ViewPager to provide a tab indicator component which give</span><br><span class=\"line\"> * constant feedback as to the user&apos;s scroll progress.</span><br><span class=\"line\"> * &lt;p&gt;</span><br><span class=\"line\"> * To use the component, simply add it to your view hierarchy. Then in your</span><br><span class=\"line\"> * &#123;@link android.app.Activity&#125; or &#123;@link android.support.v4.app.Fragment&#125; call</span><br><span class=\"line\"> * &#123;@link #setViewPager(ViewPager)&#125; providing it the ViewPager this layout is</span><br><span class=\"line\"> * being used for.</span><br><span class=\"line\"> * &lt;p&gt;</span><br><span class=\"line\"> * The colors can be customized in two ways. The first and simplest is to</span><br><span class=\"line\"> * provide an array of colors via &#123;@link #setSelectedIndicatorColors(int...)&#125;</span><br><span class=\"line\"> * and &#123;@link #setDividerColors(int...)&#125;. The alternative is via the</span><br><span class=\"line\"> * &#123;@link TabColorizer&#125; interface which provides you complete control over which</span><br><span class=\"line\"> * color is used for any individual position.</span><br><span class=\"line\"> * &lt;p&gt;</span><br><span class=\"line\"> * The views used as tabs can be customized by calling</span><br><span class=\"line\"> * &#123;@link #setCustomTabView(int, int)&#125;, providing the layout ID of your custom</span><br><span class=\"line\"> * layout.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class SlidingTabLayout extends HorizontalScrollView &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * Allows complete control over the colors drawn in the tab layout. Set with</span><br><span class=\"line\">\t * &#123;@link #setCustomTabColorizer(TabColorizer)&#125;.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic interface TabColorizer &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t/**</span><br><span class=\"line\">\t\t * @return return the color of the indicator used when &#123;@code position&#125;</span><br><span class=\"line\">\t\t *         is selected.</span><br><span class=\"line\">\t\t */</span><br><span class=\"line\">\t\tint getIndicatorColor(int position);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t/**</span><br><span class=\"line\">\t\t * @return return the color of the divider drawn to the right of</span><br><span class=\"line\">\t\t *         &#123;@code position&#125;.</span><br><span class=\"line\">\t\t */</span><br><span class=\"line\">\t\tint getDividerColor(int position);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate static final int TITLE_OFFSET_DIPS = 24;</span><br><span class=\"line\">\tprivate static final int TAB_VIEW_PADDING_DIPS = 16;</span><br><span class=\"line\">\tprivate static final int TAB_VIEW_TEXT_SIZE_SP = 12;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate int mTitleOffset;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate int mTabViewLayoutId;</span><br><span class=\"line\">\tprivate int mTabViewTextViewId;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate ViewPager mViewPager;</span><br><span class=\"line\">\tprivate ViewPager.OnPageChangeListener mViewPagerPageChangeListener;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate final SlidingTabStrip mTabStrip;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate int screenX;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tpublic SlidingTabLayout(Context context) &#123;</span><br><span class=\"line\">\t\tthis(context, null);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tpublic SlidingTabLayout(Context context, AttributeSet attrs) &#123;</span><br><span class=\"line\">\t\tthis(context, attrs, 0);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tpublic SlidingTabLayout(Context context, AttributeSet attrs, int defStyle) &#123;</span><br><span class=\"line\">\t\tsuper(context, attrs, defStyle);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t// Disable the Scroll Bar</span><br><span class=\"line\">\t\tsetHorizontalScrollBarEnabled(false);</span><br><span class=\"line\">\t\t// Make sure that the Tab Strips fills this View</span><br><span class=\"line\">\t\tsetFillViewport(true);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\tmTitleOffset = (int) (TITLE_OFFSET_DIPS * getResources()</span><br><span class=\"line\">\t\t\t\t.getDisplayMetrics().density);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\tmTabStrip = new SlidingTabStrip(context);</span><br><span class=\"line\">\t\taddView(mTabStrip, LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * Set the custom &#123;@link TabColorizer&#125; to be used.</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t * If you only require simple custmisation then you can use</span><br><span class=\"line\">\t * &#123;@link #setSelectedIndicatorColors(int...)&#125; and</span><br><span class=\"line\">\t * &#123;@link #setDividerColors(int...)&#125; to achieve similar effects.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic void setCustomTabColorizer(TabColorizer tabColorizer) &#123;</span><br><span class=\"line\">\t\tmTabStrip.setCustomTabColorizer(tabColorizer);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * Sets the colors to be used for indicating the selected tab. These colors</span><br><span class=\"line\">\t * are treated as a circular array. Providing one color will mean that all</span><br><span class=\"line\">\t * tabs are indicated with the same color.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic void setSelectedIndicatorColors(int... colors) &#123;</span><br><span class=\"line\">\t\tmTabStrip.setSelectedIndicatorColors(colors);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * Sets the colors to be used for tab dividers. These colors are treated as</span><br><span class=\"line\">\t * a circular array. Providing one color will mean that all tabs are</span><br><span class=\"line\">\t * indicated with the same color.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic void setDividerColors(int... colors) &#123;</span><br><span class=\"line\">\t\tmTabStrip.setDividerColors(colors);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * Set the &#123;@link ViewPager.OnPageChangeListener&#125;. When using</span><br><span class=\"line\">\t * &#123;@link SlidingTabLayout&#125; you are required to set any</span><br><span class=\"line\">\t * &#123;@link ViewPager.OnPageChangeListener&#125; through this method. This is so</span><br><span class=\"line\">\t * that the layout can update it&apos;s scroll position correctly.</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t * @see ViewPager#setOnPageChangeListener(ViewPager.OnPageChangeListener)</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic void setOnPageChangeListener(ViewPager.OnPageChangeListener listener) &#123;</span><br><span class=\"line\">\t\tmViewPagerPageChangeListener = listener;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * Set the custom layout to be inflated for the tab views.</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t * @param layoutResId</span><br><span class=\"line\">\t *            Layout id to be inflated</span><br><span class=\"line\">\t * @param textViewId</span><br><span class=\"line\">\t *            id of the &#123;@link TextView&#125; in the inflated view</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic void setCustomTabView(int layoutResId, int textViewId) &#123;</span><br><span class=\"line\">\t\tmTabViewLayoutId = layoutResId;</span><br><span class=\"line\">\t\tmTabViewTextViewId = textViewId;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * Sets the associated view pager. Note that the assumption here is that the</span><br><span class=\"line\">\t * pager content (number of tabs and tab titles) does not change after this</span><br><span class=\"line\">\t * call has been made.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic void setViewPager(ViewPager viewPager, int screenX) &#123;</span><br><span class=\"line\">\t\tthis.screenX = (screenX / viewPager.getAdapter().getCount());</span><br><span class=\"line\">\t\tmTabStrip.removeAllViews();</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\tmViewPager = viewPager;</span><br><span class=\"line\">\t\tif (viewPager != null) &#123;</span><br><span class=\"line\">\t\t\tviewPager.setOnPageChangeListener(new InternalViewPagerListener());</span><br><span class=\"line\">\t\t\tpopulateTabStrip();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * Create a default view to be used for tabs. This is called if a custom tab</span><br><span class=\"line\">\t * view is not set via &#123;@link #setCustomTabView(int, int)&#125;.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\t@SuppressLint(&quot;NewApi&quot;)</span><br><span class=\"line\">\tprotected TextView createDefaultTabView(Context context) &#123;</span><br><span class=\"line\">\t\tTextView textView = new TextView(context);</span><br><span class=\"line\">\t\ttextView.setGravity(Gravity.CENTER);</span><br><span class=\"line\">\t\ttextView.setTextSize(TypedValue.COMPLEX_UNIT_SP, TAB_VIEW_TEXT_SIZE_SP);</span><br><span class=\"line\">\t\ttextView.setTypeface(Typeface.DEFAULT_BOLD);</span><br><span class=\"line\">\t\ttextView.setWidth(screenX);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\tif (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class=\"line\">\t\t\t// If we&apos;re running on Honeycomb or newer, then we can use the</span><br><span class=\"line\">\t\t\t// Theme&apos;s</span><br><span class=\"line\">\t\t\t// selectableItemBackground to ensure that the View has a pressed</span><br><span class=\"line\">\t\t\t// state</span><br><span class=\"line\">\t\t\tTypedValue outValue = new TypedValue();</span><br><span class=\"line\">\t\t\tgetContext().getTheme().resolveAttribute(</span><br><span class=\"line\">\t\t\t\t\tandroid.R.attr.selectableItemBackground, outValue, true);</span><br><span class=\"line\">\t\t\ttextView.setBackgroundResource(outValue.resourceId);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\tif (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class=\"line\">\t\t\t// If we&apos;re running on ICS or newer, enable all-caps to match the</span><br><span class=\"line\">\t\t\t// Action Bar tab style</span><br><span class=\"line\">\t\t\ttextView.setAllCaps(true);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\tint padding = (int) (TAB_VIEW_PADDING_DIPS * getResources()</span><br><span class=\"line\">\t\t\t\t.getDisplayMetrics().density);</span><br><span class=\"line\">\t\ttextView.setPadding(padding, padding, padding, padding);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\treturn textView;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate void populateTabStrip() &#123;</span><br><span class=\"line\">\t\tfinal PagerAdapter adapter = mViewPager.getAdapter();</span><br><span class=\"line\">\t\tfinal View.OnClickListener tabClickListener = new TabClickListener();</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\tfor (int i = 0; i &lt; adapter.getCount(); i++) &#123;</span><br><span class=\"line\">\t\t\tView tabView = null;</span><br><span class=\"line\">\t\t\tTextView tabTitleView = null;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t\tif (mTabViewLayoutId != 0) &#123;</span><br><span class=\"line\">\t\t\t\t// If there is a custom tab view layout id set, try and inflate</span><br><span class=\"line\">\t\t\t\t// it</span><br><span class=\"line\">\t\t\t\ttabView = LayoutInflater.from(getContext()).inflate(</span><br><span class=\"line\">\t\t\t\t\t\tmTabViewLayoutId, mTabStrip, false);</span><br><span class=\"line\">\t\t\t\ttabTitleView = (TextView) tabView</span><br><span class=\"line\">\t\t\t\t\t\t.findViewById(mTabViewTextViewId);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t\tif (tabView == null) &#123;</span><br><span class=\"line\">\t\t\t\ttabView = createDefaultTabView(getContext());</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t\tif (tabTitleView == null &amp;&amp; TextView.class.isInstance(tabView)) &#123;</span><br><span class=\"line\">\t\t\t\ttabTitleView = (TextView) tabView;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t\ttabTitleView.setText(adapter.getPageTitle(i));</span><br><span class=\"line\">\t\t\ttabView.setOnClickListener(tabClickListener);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t\tmTabStrip.addView(tabView);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tprotected void onAttachedToWindow() &#123;</span><br><span class=\"line\">\t\tsuper.onAttachedToWindow();</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\tif (mViewPager != null) &#123;</span><br><span class=\"line\">\t\t\tscrollToTab(mViewPager.getCurrentItem(), 0);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate void scrollToTab(int tabIndex, int positionOffset) &#123;</span><br><span class=\"line\">\t\tfinal int tabStripChildCount = mTabStrip.getChildCount();</span><br><span class=\"line\">\t\tif (tabStripChildCount == 0 || tabIndex &lt; 0</span><br><span class=\"line\">\t\t\t\t|| tabIndex &gt;= tabStripChildCount) &#123;</span><br><span class=\"line\">\t\t\treturn;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\tView selectedChild = mTabStrip.getChildAt(tabIndex);</span><br><span class=\"line\">\t\tif (selectedChild != null) &#123;</span><br><span class=\"line\">\t\t\tint targetScrollX = selectedChild.getLeft() + positionOffset;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t\tif (tabIndex &gt; 0 || positionOffset &gt; 0) &#123;</span><br><span class=\"line\">\t\t\t\t// If we&apos;re not at the first child and are mid-scroll, make sure</span><br><span class=\"line\">\t\t\t\t// we obey the offset</span><br><span class=\"line\">\t\t\t\ttargetScrollX -= mTitleOffset;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t\tscrollTo(targetScrollX, 0);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate class InternalViewPagerListener implements</span><br><span class=\"line\">\t\t\tViewPager.OnPageChangeListener &#123;</span><br><span class=\"line\">\t\tprivate int mScrollState;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t@Override</span><br><span class=\"line\">\t\tpublic void onPageScrolled(int position, float positionOffset,</span><br><span class=\"line\">\t\t\t\tint positionOffsetPixels) &#123;</span><br><span class=\"line\">\t\t\tint tabStripChildCount = mTabStrip.getChildCount();</span><br><span class=\"line\">\t\t\tif ((tabStripChildCount == 0) || (position &lt; 0)</span><br><span class=\"line\">\t\t\t\t\t|| (position &gt;= tabStripChildCount)) &#123;</span><br><span class=\"line\">\t\t\t\treturn;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t\tmTabStrip.onViewPagerPageChanged(position, positionOffset);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t\tView selectedTitle = mTabStrip.getChildAt(position);</span><br><span class=\"line\">\t\t\tint extraOffset = (selectedTitle != null) ? (int) (positionOffset * selectedTitle</span><br><span class=\"line\">\t\t\t\t\t.getWidth()) : 0;</span><br><span class=\"line\">\t\t\tscrollToTab(position, extraOffset);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t\tif (mViewPagerPageChangeListener != null) &#123;</span><br><span class=\"line\">\t\t\t\tmViewPagerPageChangeListener.onPageScrolled(position,</span><br><span class=\"line\">\t\t\t\t\t\tpositionOffset, positionOffsetPixels);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t@Override</span><br><span class=\"line\">\t\tpublic void onPageScrollStateChanged(int state) &#123;</span><br><span class=\"line\">\t\t\tmScrollState = state;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t\tif (mViewPagerPageChangeListener != null) &#123;</span><br><span class=\"line\">\t\t\t\tmViewPagerPageChangeListener.onPageScrollStateChanged(state);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t@Override</span><br><span class=\"line\">\t\tpublic void onPageSelected(int position) &#123;</span><br><span class=\"line\">\t\t\tif (mScrollState == ViewPager.SCROLL_STATE_IDLE) &#123;</span><br><span class=\"line\">\t\t\t\tmTabStrip.onViewPagerPageChanged(position, 0f);</span><br><span class=\"line\">\t\t\t\tscrollToTab(position, 0);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t\tif (mViewPagerPageChangeListener != null) &#123;</span><br><span class=\"line\">\t\t\t\tmViewPagerPageChangeListener.onPageSelected(position);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate class TabClickListener implements View.OnClickListener &#123;</span><br><span class=\"line\">\t\t@Override</span><br><span class=\"line\">\t\tpublic void onClick(View v) &#123;</span><br><span class=\"line\">\t\t\tfor (int i = 0; i &lt; mTabStrip.getChildCount(); i++) &#123;</span><br><span class=\"line\">\t\t\t\tif (v == mTabStrip.getChildAt(i)) &#123;</span><br><span class=\"line\">\t\t\t\t\tmViewPager.setCurrentItem(i);</span><br><span class=\"line\">\t\t\t\t\treturn;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这一篇到此结束。下一篇将讨论菜单的添加和关于ToolBar的更多精彩用法。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>《代码大全》一书中提到：当我们编程时，不要简单停留在“在一种编程语言上进行编程”，而是要“深入一种语言”编程。在前面两篇文章中，虽然初步实现了ViewPager+Tab的布局，但实际上还是有一些不足的。让我们把目光锁定在Tab：<br><img src=\"https://img-blog.csdn.net/20141101131904159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"Tab标签样式\"></p>\n<p>可以发现，3个Tab加一起的宽度并没有填充屏幕整个宽度。实际上，Google这样的设计是为了应对多Tab的情形，当Tab总宽度超出屏幕宽度的时候，用户可以简单地通过滑动Tab看到后面未显示出来的Tab。这种情况其实还是比较多见的，比如众多的新闻阅读客户端和Google原生应用等等。<br>但是如果我们只有三个Tab，甚至只有两个Tab，想让整个Tab的宽度等于屏幕宽度，该如何做呢？第一反应自然是要略微折腾一下SlidingTabLayout.java的源码了。<br>经过研究发现，实际上如上图顶部Tab的实现通过HorizontalScrollView，然后add了一个又一个的view，这个View就是每个Tab的标题，而整个SlidingTabLayout是继承了HorizontalScrollView。<br>接下来的思路就很清晰了：首先获取屏幕的总宽度，然后传给SlidingTabLayout对象，在其类内部对每个Tab所占的宽度进行计算和分配，最后将每个Tab标题的视图add到HorizontalScrollView就OK了。<br>首先获取屏幕的宽度。这一操作我们在MainActivity中进行，下面列出这一段程序清单：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获取屏幕宽度</span><br><span class=\"line\">private int caculateScreenX() &#123;</span><br><span class=\"line\">\treturn getResources().getDisplayMetrics().widthPixels;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>获取到屏幕宽度之后，接下来就是把这个值传递给SlidingTabLayout。回顾一下用法，上一篇文章里面提到，我们在添加Tab导航栏的时候，仅仅是实例化了SlidingTabLayout的对象，然后调用了setViewPager()方法而已。那么，我们不妨在该方法上面添加一个参数，用来传递屏幕宽度。当然，我们需要在SlidingTabLayout中声明一个全局的int变量，用来存放每个Tab的宽度值：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void setViewPager(ViewPager viewPager, int screenX) &#123;</span><br><span class=\"line\">    this.screenX = screenX / viewPager.viewPager.getAdapter().getCount();</span><br><span class=\"line\">    mTabStrip.removeAllViews();</span><br><span class=\"line\">    mViewPager = viewPager;</span><br><span class=\"line\">    if (viewPager != null) &#123;</span><br><span class=\"line\">        viewPager.setOnPageChangeListener(new InternalViewPagerListener());</span><br><span class=\"line\">        populateTabStrip();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>跟随该方法，找到populateTabStrip()方法，可以看到其中通过一个for循环以此添加了各个Tab视图。而每个Tab视图均通过createDefaultTabView()方法创建，因此该方法最为关键。<br>找到这个方法之后我们发现，每个Tab的标题View实际上是TextView，那么我们只需将每个TextView的宽度制定为刚刚计算出来的screenX（每个Tab的宽度）即可。具体可参看下面的代码清单：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected TextView createDefaultTabView(Context context) &#123;</span><br><span class=\"line\">    TextView textView = new TextView(context);</span><br><span class=\"line\">\ttextView.setGravity(Gravity.CENTER);</span><br><span class=\"line\">\ttextView.setTextSize(TypedValue.COMPLEX_UNIT_SP, TAB_VIEW_TEXT_SIZE_SP);</span><br><span class=\"line\">\ttextView.setTypeface(Typeface.DEFAULT_BOLD);\t\ttextView.setWidth(screenX);</span><br><span class=\"line\"> </span><br><span class=\"line\">\tif (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class=\"line\">\t\t// If we&apos;re running on Honeycomb or newer, then we can use the</span><br><span class=\"line\">\t\t// Theme&apos;s</span><br><span class=\"line\">\t\t// selectableItemBackground to ensure that the View has a pressed</span><br><span class=\"line\">\t\t// state</span><br><span class=\"line\">\t\tTypedValue outValue = new TypedValue();</span><br><span class=\"line\">\t\tgetContext().getTheme().resolveAttribute(</span><br><span class=\"line\">\t\t\t\t\tandroid.R.attr.selectableItemBackground, outValue, true);</span><br><span class=\"line\">\t\ttextView.setBackgroundResource(outValue.resourceId);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tif (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class=\"line\">\t\t// If we&apos;re running on ICS or newer, enable all-caps to match the</span><br><span class=\"line\">\t\t// Action Bar tab style</span><br><span class=\"line\">\t\ttextView.setAllCaps(true);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tint padding = (int) (TAB_VIEW_PADDING_DIPS * getResources()</span><br><span class=\"line\">\t\t\t\t.getDisplayMetrics().density);</span><br><span class=\"line\">\ttextView.setPadding(padding, padding, padding, padding);</span><br><span class=\"line\"> </span><br><span class=\"line\">\treturn textView;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，我们修改MainActivity，把计算好的屏幕宽度传给SlidingTabLayout，Ctrl+F11看看效果吧！   </p>\n<p><img src=\"https://img-blog.csdn.net/20141101143436171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHdobmV3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"等分的Tab样式\"></p>\n<p>不出意外的话，看到上图就说明已经成功了！<br>下面放上整个SlidingTabLayout修改后的类：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * Copyright (C) 2013 The Android Open Source Project</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class=\"line\"> * you may not use this file except in compliance with the License.</span><br><span class=\"line\"> * You may obtain a copy of the License at</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *      http://www.apache.org/licenses/LICENSE-2.0</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * Unless required by applicable law or agreed to in writing, software</span><br><span class=\"line\"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class=\"line\"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class=\"line\"> * See the License for the specific language governing permissions and</span><br><span class=\"line\"> * limitations under the License.</span><br><span class=\"line\"> */</span><br><span class=\"line\"> </span><br><span class=\"line\">package com.xwh.toolbardemo.view;</span><br><span class=\"line\"> </span><br><span class=\"line\">import android.annotation.SuppressLint;</span><br><span class=\"line\">import android.content.Context;</span><br><span class=\"line\">import android.graphics.Typeface;</span><br><span class=\"line\">import android.os.Build;</span><br><span class=\"line\">import android.support.v4.view.PagerAdapter;</span><br><span class=\"line\">import android.support.v4.view.ViewPager;</span><br><span class=\"line\">import android.util.AttributeSet;</span><br><span class=\"line\">import android.util.Log;</span><br><span class=\"line\">import android.util.TypedValue;</span><br><span class=\"line\">import android.view.Gravity;</span><br><span class=\"line\">import android.view.LayoutInflater;</span><br><span class=\"line\">import android.view.View;</span><br><span class=\"line\">import android.widget.HorizontalScrollView;</span><br><span class=\"line\">import android.widget.TextView;</span><br><span class=\"line\"> </span><br><span class=\"line\">/**</span><br><span class=\"line\"> * To be used with ViewPager to provide a tab indicator component which give</span><br><span class=\"line\"> * constant feedback as to the user&apos;s scroll progress.</span><br><span class=\"line\"> * &lt;p&gt;</span><br><span class=\"line\"> * To use the component, simply add it to your view hierarchy. Then in your</span><br><span class=\"line\"> * &#123;@link android.app.Activity&#125; or &#123;@link android.support.v4.app.Fragment&#125; call</span><br><span class=\"line\"> * &#123;@link #setViewPager(ViewPager)&#125; providing it the ViewPager this layout is</span><br><span class=\"line\"> * being used for.</span><br><span class=\"line\"> * &lt;p&gt;</span><br><span class=\"line\"> * The colors can be customized in two ways. The first and simplest is to</span><br><span class=\"line\"> * provide an array of colors via &#123;@link #setSelectedIndicatorColors(int...)&#125;</span><br><span class=\"line\"> * and &#123;@link #setDividerColors(int...)&#125;. The alternative is via the</span><br><span class=\"line\"> * &#123;@link TabColorizer&#125; interface which provides you complete control over which</span><br><span class=\"line\"> * color is used for any individual position.</span><br><span class=\"line\"> * &lt;p&gt;</span><br><span class=\"line\"> * The views used as tabs can be customized by calling</span><br><span class=\"line\"> * &#123;@link #setCustomTabView(int, int)&#125;, providing the layout ID of your custom</span><br><span class=\"line\"> * layout.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class SlidingTabLayout extends HorizontalScrollView &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * Allows complete control over the colors drawn in the tab layout. Set with</span><br><span class=\"line\">\t * &#123;@link #setCustomTabColorizer(TabColorizer)&#125;.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic interface TabColorizer &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t/**</span><br><span class=\"line\">\t\t * @return return the color of the indicator used when &#123;@code position&#125;</span><br><span class=\"line\">\t\t *         is selected.</span><br><span class=\"line\">\t\t */</span><br><span class=\"line\">\t\tint getIndicatorColor(int position);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t/**</span><br><span class=\"line\">\t\t * @return return the color of the divider drawn to the right of</span><br><span class=\"line\">\t\t *         &#123;@code position&#125;.</span><br><span class=\"line\">\t\t */</span><br><span class=\"line\">\t\tint getDividerColor(int position);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate static final int TITLE_OFFSET_DIPS = 24;</span><br><span class=\"line\">\tprivate static final int TAB_VIEW_PADDING_DIPS = 16;</span><br><span class=\"line\">\tprivate static final int TAB_VIEW_TEXT_SIZE_SP = 12;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate int mTitleOffset;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate int mTabViewLayoutId;</span><br><span class=\"line\">\tprivate int mTabViewTextViewId;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate ViewPager mViewPager;</span><br><span class=\"line\">\tprivate ViewPager.OnPageChangeListener mViewPagerPageChangeListener;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate final SlidingTabStrip mTabStrip;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate int screenX;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tpublic SlidingTabLayout(Context context) &#123;</span><br><span class=\"line\">\t\tthis(context, null);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tpublic SlidingTabLayout(Context context, AttributeSet attrs) &#123;</span><br><span class=\"line\">\t\tthis(context, attrs, 0);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tpublic SlidingTabLayout(Context context, AttributeSet attrs, int defStyle) &#123;</span><br><span class=\"line\">\t\tsuper(context, attrs, defStyle);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t// Disable the Scroll Bar</span><br><span class=\"line\">\t\tsetHorizontalScrollBarEnabled(false);</span><br><span class=\"line\">\t\t// Make sure that the Tab Strips fills this View</span><br><span class=\"line\">\t\tsetFillViewport(true);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\tmTitleOffset = (int) (TITLE_OFFSET_DIPS * getResources()</span><br><span class=\"line\">\t\t\t\t.getDisplayMetrics().density);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\tmTabStrip = new SlidingTabStrip(context);</span><br><span class=\"line\">\t\taddView(mTabStrip, LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * Set the custom &#123;@link TabColorizer&#125; to be used.</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t * If you only require simple custmisation then you can use</span><br><span class=\"line\">\t * &#123;@link #setSelectedIndicatorColors(int...)&#125; and</span><br><span class=\"line\">\t * &#123;@link #setDividerColors(int...)&#125; to achieve similar effects.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic void setCustomTabColorizer(TabColorizer tabColorizer) &#123;</span><br><span class=\"line\">\t\tmTabStrip.setCustomTabColorizer(tabColorizer);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * Sets the colors to be used for indicating the selected tab. These colors</span><br><span class=\"line\">\t * are treated as a circular array. Providing one color will mean that all</span><br><span class=\"line\">\t * tabs are indicated with the same color.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic void setSelectedIndicatorColors(int... colors) &#123;</span><br><span class=\"line\">\t\tmTabStrip.setSelectedIndicatorColors(colors);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * Sets the colors to be used for tab dividers. These colors are treated as</span><br><span class=\"line\">\t * a circular array. Providing one color will mean that all tabs are</span><br><span class=\"line\">\t * indicated with the same color.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic void setDividerColors(int... colors) &#123;</span><br><span class=\"line\">\t\tmTabStrip.setDividerColors(colors);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * Set the &#123;@link ViewPager.OnPageChangeListener&#125;. When using</span><br><span class=\"line\">\t * &#123;@link SlidingTabLayout&#125; you are required to set any</span><br><span class=\"line\">\t * &#123;@link ViewPager.OnPageChangeListener&#125; through this method. This is so</span><br><span class=\"line\">\t * that the layout can update it&apos;s scroll position correctly.</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t * @see ViewPager#setOnPageChangeListener(ViewPager.OnPageChangeListener)</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic void setOnPageChangeListener(ViewPager.OnPageChangeListener listener) &#123;</span><br><span class=\"line\">\t\tmViewPagerPageChangeListener = listener;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * Set the custom layout to be inflated for the tab views.</span><br><span class=\"line\">\t * </span><br><span class=\"line\">\t * @param layoutResId</span><br><span class=\"line\">\t *            Layout id to be inflated</span><br><span class=\"line\">\t * @param textViewId</span><br><span class=\"line\">\t *            id of the &#123;@link TextView&#125; in the inflated view</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic void setCustomTabView(int layoutResId, int textViewId) &#123;</span><br><span class=\"line\">\t\tmTabViewLayoutId = layoutResId;</span><br><span class=\"line\">\t\tmTabViewTextViewId = textViewId;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * Sets the associated view pager. Note that the assumption here is that the</span><br><span class=\"line\">\t * pager content (number of tabs and tab titles) does not change after this</span><br><span class=\"line\">\t * call has been made.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic void setViewPager(ViewPager viewPager, int screenX) &#123;</span><br><span class=\"line\">\t\tthis.screenX = (screenX / viewPager.getAdapter().getCount());</span><br><span class=\"line\">\t\tmTabStrip.removeAllViews();</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\tmViewPager = viewPager;</span><br><span class=\"line\">\t\tif (viewPager != null) &#123;</span><br><span class=\"line\">\t\t\tviewPager.setOnPageChangeListener(new InternalViewPagerListener());</span><br><span class=\"line\">\t\t\tpopulateTabStrip();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * Create a default view to be used for tabs. This is called if a custom tab</span><br><span class=\"line\">\t * view is not set via &#123;@link #setCustomTabView(int, int)&#125;.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\t@SuppressLint(&quot;NewApi&quot;)</span><br><span class=\"line\">\tprotected TextView createDefaultTabView(Context context) &#123;</span><br><span class=\"line\">\t\tTextView textView = new TextView(context);</span><br><span class=\"line\">\t\ttextView.setGravity(Gravity.CENTER);</span><br><span class=\"line\">\t\ttextView.setTextSize(TypedValue.COMPLEX_UNIT_SP, TAB_VIEW_TEXT_SIZE_SP);</span><br><span class=\"line\">\t\ttextView.setTypeface(Typeface.DEFAULT_BOLD);</span><br><span class=\"line\">\t\ttextView.setWidth(screenX);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\tif (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class=\"line\">\t\t\t// If we&apos;re running on Honeycomb or newer, then we can use the</span><br><span class=\"line\">\t\t\t// Theme&apos;s</span><br><span class=\"line\">\t\t\t// selectableItemBackground to ensure that the View has a pressed</span><br><span class=\"line\">\t\t\t// state</span><br><span class=\"line\">\t\t\tTypedValue outValue = new TypedValue();</span><br><span class=\"line\">\t\t\tgetContext().getTheme().resolveAttribute(</span><br><span class=\"line\">\t\t\t\t\tandroid.R.attr.selectableItemBackground, outValue, true);</span><br><span class=\"line\">\t\t\ttextView.setBackgroundResource(outValue.resourceId);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\tif (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class=\"line\">\t\t\t// If we&apos;re running on ICS or newer, enable all-caps to match the</span><br><span class=\"line\">\t\t\t// Action Bar tab style</span><br><span class=\"line\">\t\t\ttextView.setAllCaps(true);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\tint padding = (int) (TAB_VIEW_PADDING_DIPS * getResources()</span><br><span class=\"line\">\t\t\t\t.getDisplayMetrics().density);</span><br><span class=\"line\">\t\ttextView.setPadding(padding, padding, padding, padding);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\treturn textView;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate void populateTabStrip() &#123;</span><br><span class=\"line\">\t\tfinal PagerAdapter adapter = mViewPager.getAdapter();</span><br><span class=\"line\">\t\tfinal View.OnClickListener tabClickListener = new TabClickListener();</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\tfor (int i = 0; i &lt; adapter.getCount(); i++) &#123;</span><br><span class=\"line\">\t\t\tView tabView = null;</span><br><span class=\"line\">\t\t\tTextView tabTitleView = null;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t\tif (mTabViewLayoutId != 0) &#123;</span><br><span class=\"line\">\t\t\t\t// If there is a custom tab view layout id set, try and inflate</span><br><span class=\"line\">\t\t\t\t// it</span><br><span class=\"line\">\t\t\t\ttabView = LayoutInflater.from(getContext()).inflate(</span><br><span class=\"line\">\t\t\t\t\t\tmTabViewLayoutId, mTabStrip, false);</span><br><span class=\"line\">\t\t\t\ttabTitleView = (TextView) tabView</span><br><span class=\"line\">\t\t\t\t\t\t.findViewById(mTabViewTextViewId);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t\tif (tabView == null) &#123;</span><br><span class=\"line\">\t\t\t\ttabView = createDefaultTabView(getContext());</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t\tif (tabTitleView == null &amp;&amp; TextView.class.isInstance(tabView)) &#123;</span><br><span class=\"line\">\t\t\t\ttabTitleView = (TextView) tabView;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t\ttabTitleView.setText(adapter.getPageTitle(i));</span><br><span class=\"line\">\t\t\ttabView.setOnClickListener(tabClickListener);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t\tmTabStrip.addView(tabView);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tprotected void onAttachedToWindow() &#123;</span><br><span class=\"line\">\t\tsuper.onAttachedToWindow();</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\tif (mViewPager != null) &#123;</span><br><span class=\"line\">\t\t\tscrollToTab(mViewPager.getCurrentItem(), 0);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate void scrollToTab(int tabIndex, int positionOffset) &#123;</span><br><span class=\"line\">\t\tfinal int tabStripChildCount = mTabStrip.getChildCount();</span><br><span class=\"line\">\t\tif (tabStripChildCount == 0 || tabIndex &lt; 0</span><br><span class=\"line\">\t\t\t\t|| tabIndex &gt;= tabStripChildCount) &#123;</span><br><span class=\"line\">\t\t\treturn;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\tView selectedChild = mTabStrip.getChildAt(tabIndex);</span><br><span class=\"line\">\t\tif (selectedChild != null) &#123;</span><br><span class=\"line\">\t\t\tint targetScrollX = selectedChild.getLeft() + positionOffset;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t\tif (tabIndex &gt; 0 || positionOffset &gt; 0) &#123;</span><br><span class=\"line\">\t\t\t\t// If we&apos;re not at the first child and are mid-scroll, make sure</span><br><span class=\"line\">\t\t\t\t// we obey the offset</span><br><span class=\"line\">\t\t\t\ttargetScrollX -= mTitleOffset;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t\tscrollTo(targetScrollX, 0);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate class InternalViewPagerListener implements</span><br><span class=\"line\">\t\t\tViewPager.OnPageChangeListener &#123;</span><br><span class=\"line\">\t\tprivate int mScrollState;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t@Override</span><br><span class=\"line\">\t\tpublic void onPageScrolled(int position, float positionOffset,</span><br><span class=\"line\">\t\t\t\tint positionOffsetPixels) &#123;</span><br><span class=\"line\">\t\t\tint tabStripChildCount = mTabStrip.getChildCount();</span><br><span class=\"line\">\t\t\tif ((tabStripChildCount == 0) || (position &lt; 0)</span><br><span class=\"line\">\t\t\t\t\t|| (position &gt;= tabStripChildCount)) &#123;</span><br><span class=\"line\">\t\t\t\treturn;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t\tmTabStrip.onViewPagerPageChanged(position, positionOffset);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t\tView selectedTitle = mTabStrip.getChildAt(position);</span><br><span class=\"line\">\t\t\tint extraOffset = (selectedTitle != null) ? (int) (positionOffset * selectedTitle</span><br><span class=\"line\">\t\t\t\t\t.getWidth()) : 0;</span><br><span class=\"line\">\t\t\tscrollToTab(position, extraOffset);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t\tif (mViewPagerPageChangeListener != null) &#123;</span><br><span class=\"line\">\t\t\t\tmViewPagerPageChangeListener.onPageScrolled(position,</span><br><span class=\"line\">\t\t\t\t\t\tpositionOffset, positionOffsetPixels);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t@Override</span><br><span class=\"line\">\t\tpublic void onPageScrollStateChanged(int state) &#123;</span><br><span class=\"line\">\t\t\tmScrollState = state;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t\tif (mViewPagerPageChangeListener != null) &#123;</span><br><span class=\"line\">\t\t\t\tmViewPagerPageChangeListener.onPageScrollStateChanged(state);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t@Override</span><br><span class=\"line\">\t\tpublic void onPageSelected(int position) &#123;</span><br><span class=\"line\">\t\t\tif (mScrollState == ViewPager.SCROLL_STATE_IDLE) &#123;</span><br><span class=\"line\">\t\t\t\tmTabStrip.onViewPagerPageChanged(position, 0f);</span><br><span class=\"line\">\t\t\t\tscrollToTab(position, 0);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t\tif (mViewPagerPageChangeListener != null) &#123;</span><br><span class=\"line\">\t\t\t\tmViewPagerPageChangeListener.onPageSelected(position);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tprivate class TabClickListener implements View.OnClickListener &#123;</span><br><span class=\"line\">\t\t@Override</span><br><span class=\"line\">\t\tpublic void onClick(View v) &#123;</span><br><span class=\"line\">\t\t\tfor (int i = 0; i &lt; mTabStrip.getChildCount(); i++) &#123;</span><br><span class=\"line\">\t\t\t\tif (v == mTabStrip.getChildAt(i)) &#123;</span><br><span class=\"line\">\t\t\t\t\tmViewPager.setCurrentItem(i);</span><br><span class=\"line\">\t\t\t\t\treturn;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这一篇到此结束。下一篇将讨论菜单的添加和关于ToolBar的更多精彩用法。</p>\n"},{"title":"Android Jetpack之AppCompat - Actionbar篇","date":"2019-03-11T14:05:21.000Z","_content":"\n今天我们来聊一聊有关AppCompat，作为Android Jetpack系列文章的开篇。说到Android Jetpack，我们先看一下这张图：   \n\n![Jetpack一览](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0MDY5MC0zNTRjODMxNGIzMzZkZjU3LnBuZw)   \n\n从图中我们可以看到，整个Android Jetpack分为了四大部分，而我们今天要讲述的就是Foundation中的AppCompat小节，官方将该部分翻译为“基础”。   \nGoogle官方网站： \nhttps://developer.android.com/jetpack   \n按照Google官方的描述，AppCompat就是指v7 appcompat库。   \n> “This library adds support for the Action Bar user interface design pattern. This library includes support for material design user interface implementations.”   \n\n意思是：此库添加了对操作栏用户界面设计模式的支持。这个库包括对Material Design用户界面实现的支持。也就是说，我们可以借助该库，对Material Design有更便捷和兼容性更好的实现。   \n进入AppCompat章节后，我们发现它又被分为了4个部分，这4个部分被称为“key class”，也就是重点类，它们分别是：   \n - ActionBar：提供Actionbar用户界面模式的实现；  \n - AppCompatActivity：添加可用作使用支持库操作栏实现的Activity的基类；  \n - AppCompatDialog：添加一个可用作AppCompat主题的Dialog的基类;  \n - ShareActionProvider：添加对可包含在ActionBar中的标准化共享操作（如电子邮件或发布到社交应用程序）的支持。  \n\n想要使用这些类，我们需要添加v7支持库。  \n到现在为止，支持库的最新版本是28，添加的库名称和版本如下：  \n\n```\ncom.android.support:appcompat-v7:28.0.0\n```\n\n今天我们就先来聊一聊ActionBar，也是这里面最为复杂的一个部分。  \n依稀记得，伴随着Google I/O 2014的召开，早在Android 5.0的时代，Google 官方推出了ToolBar组件，在那之后，ToolBar就登上了历史舞台，扮演着重要的角色。之前我在CSDN上面也发表过相关主题的文章，因为发布的时机刚好是ToolBar登场之际，所以获得了很多的阅读量。快5年过去了，回头再看那几篇连载，感觉文笔很是稚嫩。今天借着讲述Jetpack，再次聊聊ToolBar那些事，相信你我都会有新的收获。  \n\n**首先解决疑问：**\n1.  问：既然有了ActionBar，为何还要用ToolBar？ 答：使用AppCompat Toolbar能兼容更广泛的设备（ActionBar要求最低Android 3.0，ToolBar要求最低Android 2.1，但只有Android 5.0及以上才能在不使用AppCompat兼容包的前提下支持Material Design），以及各式各样的自定义需求。\n\n2.  问：ToolBar上面都应该包含哪些内容？ 答：根据Google的指导，应用栏区域应具备以下要素：1）一个专用区域，可以标识您的应用并指示用户在应用中的位置；2）以可预测的方式访问搜索等重要操作；3）支持导航和视图切换（通过标签页或下拉列表）。\n\n**一、添加ToolBar**  \n想要添加一个ToolBar，总共3步走：  \n1\\.  更改application主题样式，操作对象：styles.xml。  \n对于新建的Android项目，AndroidManifest.xml中已经定义了所使用的theme，即：  \n\n```\nandroid:theme=\"@style/AppTheme\"\n```\n\n此时，我们修改styles.xml文件即可，将默认的继承值改掉，如下所示：  \n\n```\n<style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\">\n```\n\n2\\. 在Activity布局中添加ToolBar，操作对象：layout布局文件  \n\n```\n<android.support.v7.widget.Toolbar\n    android:id=\"@+id/activity_main_tb\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"?attr/actionBarSize\"\n    android:background=\"?attr/colorPrimary\"\n    android:elevation=\"4dp\"\n    android:theme=\"@style/ThemeOverlay.AppCompat.ActionBar\"\n    app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\" />\n```\n\n对高度掌握不好火候的同学，直接如上使用ActionBar的高度就可以了。  \nandroid:evevation指“仰角”，这部分知识请参考：\nhttps://developer.android.com/training/material/shadows-clipping  \n这里就不再赘述了。\n如果你的项目已经迁移到Android X，你的布局文件代码片应该是：  \n\n```\n<androidx.appcompat.widget.Toolbar\n    android:id=\"@+id/activity_main_tb\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"?attr/actionBarSize\"\n    android:background=\"?attr/colorPrimary\"\n    android:elevation=\"4dp\"\n    android:theme=\"@style/ThemeOverlay.AppCompat.ActionBar\"\n    app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\" />\n```\n\n3\\. 在Activity类中找到ToolBar，并应用它，操作对象：Activity类  \n这一步并不复杂，参考普通的Android控件。类似地，我们通过findViewById()找到ToolBar，并做执行一些设定，即可完成该步骤，示例如下：  \n\n```\nprivate Toolbar topTb;\ntopTb = findViewById(R.id.activity_main_tb);        \nsetSupportActionBar(topTb);\n```\n\n一旦我们setSupportActionBar()后，日后我们就可以通过getSupportActionBar()方法来获取ToolBar实例，也可以使用兼容包提供的ActionBar的各种API方法了。  \n到此，我们就完成了ToolBar的添加，还算简单吧？  \n\n**二、ToolBar外观的自定义**\n不出意外的话，我们运行的结果将会和下图类似：  \n\n![默认的配色方案](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0MDY5MC0zNTI2ZGYxNjMzZDcwMmExLnBuZw)   \n\n大绿底，大黑字，实在不怎么好看。  \n那么，如果我们想要自定义配色方案，该如何做呢？参考下图：  \n\n![配色方案指导](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0MDY5MC01NDJjZmEwNzM4MmVjMzgxLmpwZw)  \n\n这些值我们都可以在color.xml中定义，并在styles.xml中引用。下图是一个重新定义配色方案后的截图：  \n\n![自定义的配色方案](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0MDY5MC1jYjMxN2Y4YzA1ZGE5ZWY4LnBuZw)  \n\n相关的代码片：  \n\n**color.xml**  \n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <color name=\"colorPrimary\">#002FA7</color>\n    <color name=\"colorPrimaryDark\">#001F67</color>\n    <color name=\"colorAccent\">#003FB7</color>\n    <color name=\"textColorPrimary\">#FFFFFF</color>\n</resources>\n```\n\n**styles.xml**  \n\n```\n<style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\">\n    <item name=\"colorPrimary\">@color/colorPrimary</item>\n    <item name=\"colorPrimaryDark\">@color/colorPrimaryDark</item>\n    <item name=\"colorAccent\">@color/colorAccent</item>\n    <item name=\"android:textColorPrimary\">@color/textColorPrimary</item>\n</style>\n```\n\n细心的读者会发现，后面的截图中，右上角多了菜单项，这又是如何实现的呢？我们继续往后看。  \n\n**三、给ToolBar增加动作**  \n首先我们来看看如何给ToolBar增加菜单，我们依然分为3步完成。   \n1\\.  编写菜单xml文件，操作对象：menu文件夹下的菜单xml文件  \n这里我添加了两个菜单，如上图所示，一个隐藏在“更多”里，另一个是搜索。如下代码片所示：  \n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n\n    <item\n        android:id=\"@+id/menu_main_info\"\n        android:title=\"@string/menu_main_activity_info\"\n        app:showAsAction=\"never\" />\n\n    <item\n        android:id=\"@+id/menu_main_search\"\n        android:title=\"@string/menu_main_activity_search\"\n        app:actionViewClass=\"android.support.v7.widget.SearchView\"\n        app:showAsAction=\"always\" />\n</menu>\n```\n\n如上，我们可以看到有两个item，分别对应Info和搜索，我们使用\"app:showAsAction\"的值来控制这个菜单是否显示，常见的值有always，ifRoom，never。从字面上也很好理解，这里就不多解释了。   \n\n2\\. 接下来是Java代码片段：   \n\n```\nprivate SearchView tbSearchSv;\n\n@Override\npublic boolean onCreateOptionsMenu(Menu menu) {\n    getMenuInflater().inflate(R.menu.main_activity_menu, menu);\n    MenuItem searchItem = menu.findItem(R.id.menu_main_search);\n    tbSearchSv = (SearchView) searchItem.getActionView();\n    return super.onCreateOptionsMenu(menu);\n}\n```\n\n细心的朋友会发现有这一行：   \n\n```\napp:actionViewClass=\"android.support.v7.widget.SearchView\"\n```   \n\n它是做什么的呢？  \n\n![搜索栏效果](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0MDY5MC1kNjNiMDRjYjcyYWNiNDBmLnBuZw)   \n\n对了！它就是搜索栏，是原生的搜索栏。所以某些情况下，这个搜索栏是不用自己去实现的，系统已经给我们提供了SearchView！  \n典型的APP：网易云音乐、知乎上方的搜索都是这样的。   \n\n3\\. 为菜单设置监听器，我们先来看最普通的Info按钮，我们只需在Java代码中Override指定的方法就可以了，如下所示：   \n\n```\n@Override\npublic boolean onOptionsItemSelected(MenuItem item) {\n    switch (item.getItemId()) {\n        case R.id.menu_main_info:\n            Toast.makeText(MainActivity.this, R.string.menu_main_activity_info, Toast.LENGTH_LONG).show();\n            break;\n    }\n    return super.onOptionsItemSelected(item);\n}\n```\n\n对于搜索栏，首先我们想到的是，如何获取用户输入的内容呢？  \n其实很简单，玄机在于SearchView，只需对SearchView添加监听器就可以了。  \n\n```\ntbSearchSv.setOnQueryTextListener(new SearchView.OnQueryTextListener() {\n    @Override\n    public boolean onQueryTextSubmit(String s) {\n        \n        return false;\n    }\n\n    @Override\n    public boolean onQueryTextChange(String s) {\n        \n        return false;\n    }\n});\n```\n\n这里要注意，设置监听器前，要确保SearchView（这里的tbSearchSv）已经被实例化，否则，会出现空指针异常崩溃。   \n关于SearchView，还有一写额外的设置，比如：   \n\n```\n// 设置提交按钮是否可见（默认不可见）\ntbSearchSv.setSubmitButtonEnabled(true);\n```\n\n![提交按钮是否可见](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0MDY5MC1jYWQyNDA4MThlZGZkOTMwLnBuZw)   \n\n```\n// 设置左侧是否显示搜索图标（默认不可见）\ntbSearchSv.setIconifiedByDefault(false);\n```\n\n![左侧是否显示搜索图标](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0MDY5MC0yMTAzODEyMzQzMWE5OGU4LnBuZw)    \n更多可使用的API请参考官方文档：\nhttps://developer.android.google.cn/reference/android/widget/SearchView  \n\n不过，我们这里还需要做最后一点善后。如果你是一路下来照着本篇文章敲代码的话，在搜索框打开的情况下按一下返回键，你期待的是什么？是不是取消搜索操作，停留在当前界面？然而实际上是……退出了APP。   \n所以我们这里要对返回键的默认动作做一个“拦截”，具体可参考如下代码片：   \n\n```\n@Override\npublic boolean onKeyUp(int keyCode, KeyEvent event) {\n    switch (keyCode) {\n        case KeyEvent.KEYCODE_BACK:\n            if (!tbSearchSv.isIconified()) {\n                tbSearchSv.setIconified(true);\n                return true;\n            }\n            break;\n    }\n    return super.onKeyUp(keyCode, event);\n}\n```\n\n这里SearchView的isIconfied()方法可以返回当前的SearchView展开状态。  \n\n**四、返回上一层**   \n\nToolBar还有一个比较常见的功能就是左上角的返回按钮，提供返回上一层操作，很多的APP开发者都习惯于自定义一个ImageButton或类似的空间，然后使用美工提供的图像素材，设置监听器，写Selector……一套下来，费时费力。  \n其实Google已经为开发者提供了现成的非常易用的返回逻辑处理。要实现这些处理，两步就搞定了。  \n\n1\\. 在ToolBar对象上启用返回钮  \n\n```\ngetSupportActionBar().setDisplayHomeAsUpEnabled(true);\n```\n\n这里注意，虽然之前将ToolBar通过setSupportActionBar()方式当做参数被set了一次，但是ToolBar类本身并不提供setDisplayHomeAsUpEnabled()方法，因此，我们还需要getSupportActionBar()，先获取ActionBar对象，然后使用该对象，而不是直接使用ToolBar对象。  \n\n2\\. 在AndroidManifest.xml中定义要跳转的Activity  \n如题，我们在AndroidManifest.xml中，对子Activity做处理，这里不要忘记兼容低版本的系统。  \n\n```\n<activity\n    android:name=\".MainActivity\"\n    android:parentActivityName=\".SecondActivity\">\n    <!-- 兼容 Android4.0 及以下版本-->\n    <meta-data\n        android:name=\"android.support.PARENT_ACTIVITY\"\n        android:value=\".SecondActivity\" />\n</activity>\n```\n\n将SecondActivity改为入口Activity，然后重新运行程序，将实现如下效果：  \n\n![返回键视频演示](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NDA2OTAtMWJmZDM2NDg0NTczMzg1Zi5naWY)   \n\n\n到此，关于ToolBar常见用法的梳理告一段落。源码请自取：\nhttps://github.com/wh1990xiao2005/JetpackDemo    \n\n我会在接下来的文章中，和大家分享关于ToolBar的剩余内容，以及AppCompat兼容包中的其他知识，希望对你我都有帮助。   \n共勉！","source":"_posts/Android Jetpack之AppCompat - Actionbar篇.md","raw":"---\ntitle: Android Jetpack之AppCompat - Actionbar篇\ndate: 2019-03-11 22:05:21\ntags: Android\ncategories: 编程世界\n---\n\n今天我们来聊一聊有关AppCompat，作为Android Jetpack系列文章的开篇。说到Android Jetpack，我们先看一下这张图：   \n\n![Jetpack一览](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0MDY5MC0zNTRjODMxNGIzMzZkZjU3LnBuZw)   \n\n从图中我们可以看到，整个Android Jetpack分为了四大部分，而我们今天要讲述的就是Foundation中的AppCompat小节，官方将该部分翻译为“基础”。   \nGoogle官方网站： \nhttps://developer.android.com/jetpack   \n按照Google官方的描述，AppCompat就是指v7 appcompat库。   \n> “This library adds support for the Action Bar user interface design pattern. This library includes support for material design user interface implementations.”   \n\n意思是：此库添加了对操作栏用户界面设计模式的支持。这个库包括对Material Design用户界面实现的支持。也就是说，我们可以借助该库，对Material Design有更便捷和兼容性更好的实现。   \n进入AppCompat章节后，我们发现它又被分为了4个部分，这4个部分被称为“key class”，也就是重点类，它们分别是：   \n - ActionBar：提供Actionbar用户界面模式的实现；  \n - AppCompatActivity：添加可用作使用支持库操作栏实现的Activity的基类；  \n - AppCompatDialog：添加一个可用作AppCompat主题的Dialog的基类;  \n - ShareActionProvider：添加对可包含在ActionBar中的标准化共享操作（如电子邮件或发布到社交应用程序）的支持。  \n\n想要使用这些类，我们需要添加v7支持库。  \n到现在为止，支持库的最新版本是28，添加的库名称和版本如下：  \n\n```\ncom.android.support:appcompat-v7:28.0.0\n```\n\n今天我们就先来聊一聊ActionBar，也是这里面最为复杂的一个部分。  \n依稀记得，伴随着Google I/O 2014的召开，早在Android 5.0的时代，Google 官方推出了ToolBar组件，在那之后，ToolBar就登上了历史舞台，扮演着重要的角色。之前我在CSDN上面也发表过相关主题的文章，因为发布的时机刚好是ToolBar登场之际，所以获得了很多的阅读量。快5年过去了，回头再看那几篇连载，感觉文笔很是稚嫩。今天借着讲述Jetpack，再次聊聊ToolBar那些事，相信你我都会有新的收获。  \n\n**首先解决疑问：**\n1.  问：既然有了ActionBar，为何还要用ToolBar？ 答：使用AppCompat Toolbar能兼容更广泛的设备（ActionBar要求最低Android 3.0，ToolBar要求最低Android 2.1，但只有Android 5.0及以上才能在不使用AppCompat兼容包的前提下支持Material Design），以及各式各样的自定义需求。\n\n2.  问：ToolBar上面都应该包含哪些内容？ 答：根据Google的指导，应用栏区域应具备以下要素：1）一个专用区域，可以标识您的应用并指示用户在应用中的位置；2）以可预测的方式访问搜索等重要操作；3）支持导航和视图切换（通过标签页或下拉列表）。\n\n**一、添加ToolBar**  \n想要添加一个ToolBar，总共3步走：  \n1\\.  更改application主题样式，操作对象：styles.xml。  \n对于新建的Android项目，AndroidManifest.xml中已经定义了所使用的theme，即：  \n\n```\nandroid:theme=\"@style/AppTheme\"\n```\n\n此时，我们修改styles.xml文件即可，将默认的继承值改掉，如下所示：  \n\n```\n<style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\">\n```\n\n2\\. 在Activity布局中添加ToolBar，操作对象：layout布局文件  \n\n```\n<android.support.v7.widget.Toolbar\n    android:id=\"@+id/activity_main_tb\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"?attr/actionBarSize\"\n    android:background=\"?attr/colorPrimary\"\n    android:elevation=\"4dp\"\n    android:theme=\"@style/ThemeOverlay.AppCompat.ActionBar\"\n    app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\" />\n```\n\n对高度掌握不好火候的同学，直接如上使用ActionBar的高度就可以了。  \nandroid:evevation指“仰角”，这部分知识请参考：\nhttps://developer.android.com/training/material/shadows-clipping  \n这里就不再赘述了。\n如果你的项目已经迁移到Android X，你的布局文件代码片应该是：  \n\n```\n<androidx.appcompat.widget.Toolbar\n    android:id=\"@+id/activity_main_tb\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"?attr/actionBarSize\"\n    android:background=\"?attr/colorPrimary\"\n    android:elevation=\"4dp\"\n    android:theme=\"@style/ThemeOverlay.AppCompat.ActionBar\"\n    app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\" />\n```\n\n3\\. 在Activity类中找到ToolBar，并应用它，操作对象：Activity类  \n这一步并不复杂，参考普通的Android控件。类似地，我们通过findViewById()找到ToolBar，并做执行一些设定，即可完成该步骤，示例如下：  \n\n```\nprivate Toolbar topTb;\ntopTb = findViewById(R.id.activity_main_tb);        \nsetSupportActionBar(topTb);\n```\n\n一旦我们setSupportActionBar()后，日后我们就可以通过getSupportActionBar()方法来获取ToolBar实例，也可以使用兼容包提供的ActionBar的各种API方法了。  \n到此，我们就完成了ToolBar的添加，还算简单吧？  \n\n**二、ToolBar外观的自定义**\n不出意外的话，我们运行的结果将会和下图类似：  \n\n![默认的配色方案](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0MDY5MC0zNTI2ZGYxNjMzZDcwMmExLnBuZw)   \n\n大绿底，大黑字，实在不怎么好看。  \n那么，如果我们想要自定义配色方案，该如何做呢？参考下图：  \n\n![配色方案指导](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0MDY5MC01NDJjZmEwNzM4MmVjMzgxLmpwZw)  \n\n这些值我们都可以在color.xml中定义，并在styles.xml中引用。下图是一个重新定义配色方案后的截图：  \n\n![自定义的配色方案](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0MDY5MC1jYjMxN2Y4YzA1ZGE5ZWY4LnBuZw)  \n\n相关的代码片：  \n\n**color.xml**  \n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <color name=\"colorPrimary\">#002FA7</color>\n    <color name=\"colorPrimaryDark\">#001F67</color>\n    <color name=\"colorAccent\">#003FB7</color>\n    <color name=\"textColorPrimary\">#FFFFFF</color>\n</resources>\n```\n\n**styles.xml**  \n\n```\n<style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\">\n    <item name=\"colorPrimary\">@color/colorPrimary</item>\n    <item name=\"colorPrimaryDark\">@color/colorPrimaryDark</item>\n    <item name=\"colorAccent\">@color/colorAccent</item>\n    <item name=\"android:textColorPrimary\">@color/textColorPrimary</item>\n</style>\n```\n\n细心的读者会发现，后面的截图中，右上角多了菜单项，这又是如何实现的呢？我们继续往后看。  \n\n**三、给ToolBar增加动作**  \n首先我们来看看如何给ToolBar增加菜单，我们依然分为3步完成。   \n1\\.  编写菜单xml文件，操作对象：menu文件夹下的菜单xml文件  \n这里我添加了两个菜单，如上图所示，一个隐藏在“更多”里，另一个是搜索。如下代码片所示：  \n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n\n    <item\n        android:id=\"@+id/menu_main_info\"\n        android:title=\"@string/menu_main_activity_info\"\n        app:showAsAction=\"never\" />\n\n    <item\n        android:id=\"@+id/menu_main_search\"\n        android:title=\"@string/menu_main_activity_search\"\n        app:actionViewClass=\"android.support.v7.widget.SearchView\"\n        app:showAsAction=\"always\" />\n</menu>\n```\n\n如上，我们可以看到有两个item，分别对应Info和搜索，我们使用\"app:showAsAction\"的值来控制这个菜单是否显示，常见的值有always，ifRoom，never。从字面上也很好理解，这里就不多解释了。   \n\n2\\. 接下来是Java代码片段：   \n\n```\nprivate SearchView tbSearchSv;\n\n@Override\npublic boolean onCreateOptionsMenu(Menu menu) {\n    getMenuInflater().inflate(R.menu.main_activity_menu, menu);\n    MenuItem searchItem = menu.findItem(R.id.menu_main_search);\n    tbSearchSv = (SearchView) searchItem.getActionView();\n    return super.onCreateOptionsMenu(menu);\n}\n```\n\n细心的朋友会发现有这一行：   \n\n```\napp:actionViewClass=\"android.support.v7.widget.SearchView\"\n```   \n\n它是做什么的呢？  \n\n![搜索栏效果](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0MDY5MC1kNjNiMDRjYjcyYWNiNDBmLnBuZw)   \n\n对了！它就是搜索栏，是原生的搜索栏。所以某些情况下，这个搜索栏是不用自己去实现的，系统已经给我们提供了SearchView！  \n典型的APP：网易云音乐、知乎上方的搜索都是这样的。   \n\n3\\. 为菜单设置监听器，我们先来看最普通的Info按钮，我们只需在Java代码中Override指定的方法就可以了，如下所示：   \n\n```\n@Override\npublic boolean onOptionsItemSelected(MenuItem item) {\n    switch (item.getItemId()) {\n        case R.id.menu_main_info:\n            Toast.makeText(MainActivity.this, R.string.menu_main_activity_info, Toast.LENGTH_LONG).show();\n            break;\n    }\n    return super.onOptionsItemSelected(item);\n}\n```\n\n对于搜索栏，首先我们想到的是，如何获取用户输入的内容呢？  \n其实很简单，玄机在于SearchView，只需对SearchView添加监听器就可以了。  \n\n```\ntbSearchSv.setOnQueryTextListener(new SearchView.OnQueryTextListener() {\n    @Override\n    public boolean onQueryTextSubmit(String s) {\n        \n        return false;\n    }\n\n    @Override\n    public boolean onQueryTextChange(String s) {\n        \n        return false;\n    }\n});\n```\n\n这里要注意，设置监听器前，要确保SearchView（这里的tbSearchSv）已经被实例化，否则，会出现空指针异常崩溃。   \n关于SearchView，还有一写额外的设置，比如：   \n\n```\n// 设置提交按钮是否可见（默认不可见）\ntbSearchSv.setSubmitButtonEnabled(true);\n```\n\n![提交按钮是否可见](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0MDY5MC1jYWQyNDA4MThlZGZkOTMwLnBuZw)   \n\n```\n// 设置左侧是否显示搜索图标（默认不可见）\ntbSearchSv.setIconifiedByDefault(false);\n```\n\n![左侧是否显示搜索图标](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0MDY5MC0yMTAzODEyMzQzMWE5OGU4LnBuZw)    \n更多可使用的API请参考官方文档：\nhttps://developer.android.google.cn/reference/android/widget/SearchView  \n\n不过，我们这里还需要做最后一点善后。如果你是一路下来照着本篇文章敲代码的话，在搜索框打开的情况下按一下返回键，你期待的是什么？是不是取消搜索操作，停留在当前界面？然而实际上是……退出了APP。   \n所以我们这里要对返回键的默认动作做一个“拦截”，具体可参考如下代码片：   \n\n```\n@Override\npublic boolean onKeyUp(int keyCode, KeyEvent event) {\n    switch (keyCode) {\n        case KeyEvent.KEYCODE_BACK:\n            if (!tbSearchSv.isIconified()) {\n                tbSearchSv.setIconified(true);\n                return true;\n            }\n            break;\n    }\n    return super.onKeyUp(keyCode, event);\n}\n```\n\n这里SearchView的isIconfied()方法可以返回当前的SearchView展开状态。  \n\n**四、返回上一层**   \n\nToolBar还有一个比较常见的功能就是左上角的返回按钮，提供返回上一层操作，很多的APP开发者都习惯于自定义一个ImageButton或类似的空间，然后使用美工提供的图像素材，设置监听器，写Selector……一套下来，费时费力。  \n其实Google已经为开发者提供了现成的非常易用的返回逻辑处理。要实现这些处理，两步就搞定了。  \n\n1\\. 在ToolBar对象上启用返回钮  \n\n```\ngetSupportActionBar().setDisplayHomeAsUpEnabled(true);\n```\n\n这里注意，虽然之前将ToolBar通过setSupportActionBar()方式当做参数被set了一次，但是ToolBar类本身并不提供setDisplayHomeAsUpEnabled()方法，因此，我们还需要getSupportActionBar()，先获取ActionBar对象，然后使用该对象，而不是直接使用ToolBar对象。  \n\n2\\. 在AndroidManifest.xml中定义要跳转的Activity  \n如题，我们在AndroidManifest.xml中，对子Activity做处理，这里不要忘记兼容低版本的系统。  \n\n```\n<activity\n    android:name=\".MainActivity\"\n    android:parentActivityName=\".SecondActivity\">\n    <!-- 兼容 Android4.0 及以下版本-->\n    <meta-data\n        android:name=\"android.support.PARENT_ACTIVITY\"\n        android:value=\".SecondActivity\" />\n</activity>\n```\n\n将SecondActivity改为入口Activity，然后重新运行程序，将实现如下效果：  \n\n![返回键视频演示](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NDA2OTAtMWJmZDM2NDg0NTczMzg1Zi5naWY)   \n\n\n到此，关于ToolBar常见用法的梳理告一段落。源码请自取：\nhttps://github.com/wh1990xiao2005/JetpackDemo    \n\n我会在接下来的文章中，和大家分享关于ToolBar的剩余内容，以及AppCompat兼容包中的其他知识，希望对你我都有帮助。   \n共勉！","slug":"Android Jetpack之AppCompat - Actionbar篇","published":1,"updated":"2019-07-31T04:09:59.967Z","_id":"cjyqq3tkr0021fkqdfvuio1y5","comments":1,"layout":"post","photos":[],"link":"","content":"<p>今天我们来聊一聊有关AppCompat，作为Android Jetpack系列文章的开篇。说到Android Jetpack，我们先看一下这张图：   </p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0MDY5MC0zNTRjODMxNGIzMzZkZjU3LnBuZw\" alt=\"Jetpack一览\">   </p>\n<p>从图中我们可以看到，整个Android Jetpack分为了四大部分，而我们今天要讲述的就是Foundation中的AppCompat小节，官方将该部分翻译为“基础”。<br>Google官方网站：<br><a href=\"https://developer.android.com/jetpack\" target=\"_blank\" rel=\"noopener\">https://developer.android.com/jetpack</a><br>按照Google官方的描述，AppCompat就是指v7 appcompat库。   </p>\n<blockquote>\n<p>“This library adds support for the Action Bar user interface design pattern. This library includes support for material design user interface implementations.”   </p>\n</blockquote>\n<p>意思是：此库添加了对操作栏用户界面设计模式的支持。这个库包括对Material Design用户界面实现的支持。也就是说，我们可以借助该库，对Material Design有更便捷和兼容性更好的实现。<br>进入AppCompat章节后，我们发现它又被分为了4个部分，这4个部分被称为“key class”，也就是重点类，它们分别是：   </p>\n<ul>\n<li>ActionBar：提供Actionbar用户界面模式的实现；  </li>\n<li>AppCompatActivity：添加可用作使用支持库操作栏实现的Activity的基类；  </li>\n<li>AppCompatDialog：添加一个可用作AppCompat主题的Dialog的基类;  </li>\n<li>ShareActionProvider：添加对可包含在ActionBar中的标准化共享操作（如电子邮件或发布到社交应用程序）的支持。  </li>\n</ul>\n<p>想要使用这些类，我们需要添加v7支持库。<br>到现在为止，支持库的最新版本是28，添加的库名称和版本如下：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.android.support:appcompat-v7:28.0.0</span><br></pre></td></tr></table></figure>\n\n<p>今天我们就先来聊一聊ActionBar，也是这里面最为复杂的一个部分。<br>依稀记得，伴随着Google I/O 2014的召开，早在Android 5.0的时代，Google 官方推出了ToolBar组件，在那之后，ToolBar就登上了历史舞台，扮演着重要的角色。之前我在CSDN上面也发表过相关主题的文章，因为发布的时机刚好是ToolBar登场之际，所以获得了很多的阅读量。快5年过去了，回头再看那几篇连载，感觉文笔很是稚嫩。今天借着讲述Jetpack，再次聊聊ToolBar那些事，相信你我都会有新的收获。  </p>\n<p><strong>首先解决疑问：</strong></p>\n<ol>\n<li><p>问：既然有了ActionBar，为何还要用ToolBar？ 答：使用AppCompat Toolbar能兼容更广泛的设备（ActionBar要求最低Android 3.0，ToolBar要求最低Android 2.1，但只有Android 5.0及以上才能在不使用AppCompat兼容包的前提下支持Material Design），以及各式各样的自定义需求。</p>\n</li>\n<li><p>问：ToolBar上面都应该包含哪些内容？ 答：根据Google的指导，应用栏区域应具备以下要素：1）一个专用区域，可以标识您的应用并指示用户在应用中的位置；2）以可预测的方式访问搜索等重要操作；3）支持导航和视图切换（通过标签页或下拉列表）。</p>\n</li>\n</ol>\n<p><strong>一、添加ToolBar</strong><br>想要添加一个ToolBar，总共3步走：<br>1.  更改application主题样式，操作对象：styles.xml。<br>对于新建的Android项目，AndroidManifest.xml中已经定义了所使用的theme，即：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:theme=&quot;@style/AppTheme&quot;</span><br></pre></td></tr></table></figure>\n\n<p>此时，我们修改styles.xml文件即可，将默认的继承值改掉，如下所示：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>2. 在Activity布局中添加ToolBar，操作对象：layout布局文件  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;android.support.v7.widget.Toolbar</span><br><span class=\"line\">    android:id=&quot;@+id/activity_main_tb&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;?attr/actionBarSize&quot;</span><br><span class=\"line\">    android:background=&quot;?attr/colorPrimary&quot;</span><br><span class=\"line\">    android:elevation=&quot;4dp&quot;</span><br><span class=\"line\">    android:theme=&quot;@style/ThemeOverlay.AppCompat.ActionBar&quot;</span><br><span class=\"line\">    app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>对高度掌握不好火候的同学，直接如上使用ActionBar的高度就可以了。<br>android:evevation指“仰角”，这部分知识请参考：<br><a href=\"https://developer.android.com/training/material/shadows-clipping\" target=\"_blank\" rel=\"noopener\">https://developer.android.com/training/material/shadows-clipping</a><br>这里就不再赘述了。<br>如果你的项目已经迁移到Android X，你的布局文件代码片应该是：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;androidx.appcompat.widget.Toolbar</span><br><span class=\"line\">    android:id=&quot;@+id/activity_main_tb&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;?attr/actionBarSize&quot;</span><br><span class=\"line\">    android:background=&quot;?attr/colorPrimary&quot;</span><br><span class=\"line\">    android:elevation=&quot;4dp&quot;</span><br><span class=\"line\">    android:theme=&quot;@style/ThemeOverlay.AppCompat.ActionBar&quot;</span><br><span class=\"line\">    app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>3. 在Activity类中找到ToolBar，并应用它，操作对象：Activity类<br>这一步并不复杂，参考普通的Android控件。类似地，我们通过findViewById()找到ToolBar，并做执行一些设定，即可完成该步骤，示例如下：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private Toolbar topTb;</span><br><span class=\"line\">topTb = findViewById(R.id.activity_main_tb);        </span><br><span class=\"line\">setSupportActionBar(topTb);</span><br></pre></td></tr></table></figure>\n\n<p>一旦我们setSupportActionBar()后，日后我们就可以通过getSupportActionBar()方法来获取ToolBar实例，也可以使用兼容包提供的ActionBar的各种API方法了。<br>到此，我们就完成了ToolBar的添加，还算简单吧？  </p>\n<p><strong>二、ToolBar外观的自定义</strong><br>不出意外的话，我们运行的结果将会和下图类似：  </p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0MDY5MC0zNTI2ZGYxNjMzZDcwMmExLnBuZw\" alt=\"默认的配色方案\">   </p>\n<p>大绿底，大黑字，实在不怎么好看。<br>那么，如果我们想要自定义配色方案，该如何做呢？参考下图：  </p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0MDY5MC01NDJjZmEwNzM4MmVjMzgxLmpwZw\" alt=\"配色方案指导\">  </p>\n<p>这些值我们都可以在color.xml中定义，并在styles.xml中引用。下图是一个重新定义配色方案后的截图：  </p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0MDY5MC1jYjMxN2Y4YzA1ZGE5ZWY4LnBuZw\" alt=\"自定义的配色方案\">  </p>\n<p>相关的代码片：  </p>\n<p><strong>color.xml</strong>  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;resources&gt;</span><br><span class=\"line\">    &lt;color name=&quot;colorPrimary&quot;&gt;#002FA7&lt;/color&gt;</span><br><span class=\"line\">    &lt;color name=&quot;colorPrimaryDark&quot;&gt;#001F67&lt;/color&gt;</span><br><span class=\"line\">    &lt;color name=&quot;colorAccent&quot;&gt;#003FB7&lt;/color&gt;</span><br><span class=\"line\">    &lt;color name=&quot;textColorPrimary&quot;&gt;#FFFFFF&lt;/color&gt;</span><br><span class=\"line\">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>styles.xml</strong>  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;</span><br><span class=\"line\">    &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;</span><br><span class=\"line\">    &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;</span><br><span class=\"line\">    &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;</span><br><span class=\"line\">    &lt;item name=&quot;android:textColorPrimary&quot;&gt;@color/textColorPrimary&lt;/item&gt;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n<p>细心的读者会发现，后面的截图中，右上角多了菜单项，这又是如何实现的呢？我们继续往后看。  </p>\n<p><strong>三、给ToolBar增加动作</strong><br>首先我们来看看如何给ToolBar增加菜单，我们依然分为3步完成。<br>1.  编写菜单xml文件，操作对象：menu文件夹下的菜单xml文件<br>这里我添加了两个菜单，如上图所示，一个隐藏在“更多”里，另一个是搜索。如下代码片所示：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;item</span><br><span class=\"line\">        android:id=&quot;@+id/menu_main_info&quot;</span><br><span class=\"line\">        android:title=&quot;@string/menu_main_activity_info&quot;</span><br><span class=\"line\">        app:showAsAction=&quot;never&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;item</span><br><span class=\"line\">        android:id=&quot;@+id/menu_main_search&quot;</span><br><span class=\"line\">        android:title=&quot;@string/menu_main_activity_search&quot;</span><br><span class=\"line\">        app:actionViewClass=&quot;android.support.v7.widget.SearchView&quot;</span><br><span class=\"line\">        app:showAsAction=&quot;always&quot; /&gt;</span><br><span class=\"line\">&lt;/menu&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如上，我们可以看到有两个item，分别对应Info和搜索，我们使用”app:showAsAction”的值来控制这个菜单是否显示，常见的值有always，ifRoom，never。从字面上也很好理解，这里就不多解释了。   </p>\n<p>2. 接下来是Java代码片段：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private SearchView tbSearchSv;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onCreateOptionsMenu(Menu menu) &#123;</span><br><span class=\"line\">    getMenuInflater().inflate(R.menu.main_activity_menu, menu);</span><br><span class=\"line\">    MenuItem searchItem = menu.findItem(R.id.menu_main_search);</span><br><span class=\"line\">    tbSearchSv = (SearchView) searchItem.getActionView();</span><br><span class=\"line\">    return super.onCreateOptionsMenu(menu);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>细心的朋友会发现有这一行：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app:actionViewClass=&quot;android.support.v7.widget.SearchView&quot;</span><br><span class=\"line\">```   </span><br><span class=\"line\"></span><br><span class=\"line\">它是做什么的呢？  </span><br><span class=\"line\"></span><br><span class=\"line\">![搜索栏效果](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0MDY5MC1kNjNiMDRjYjcyYWNiNDBmLnBuZw)   </span><br><span class=\"line\"></span><br><span class=\"line\">对了！它就是搜索栏，是原生的搜索栏。所以某些情况下，这个搜索栏是不用自己去实现的，系统已经给我们提供了SearchView！  </span><br><span class=\"line\">典型的APP：网易云音乐、知乎上方的搜索都是这样的。   </span><br><span class=\"line\"></span><br><span class=\"line\">3\\. 为菜单设置监听器，我们先来看最普通的Info按钮，我们只需在Java代码中Override指定的方法就可以了，如下所示：</span><br></pre></td></tr></table></figure>\n\n<p>@Override<br>public boolean onOptionsItemSelected(MenuItem item) {<br>    switch (item.getItemId()) {<br>        case R.id.menu_main_info:<br>            Toast.makeText(MainActivity.this, R.string.menu_main_activity_info, Toast.LENGTH_LONG).show();<br>            break;<br>    }<br>    return super.onOptionsItemSelected(item);<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">对于搜索栏，首先我们想到的是，如何获取用户输入的内容呢？  </span><br><span class=\"line\">其实很简单，玄机在于SearchView，只需对SearchView添加监听器就可以了。</span><br></pre></td></tr></table></figure>\n\n<p>tbSearchSv.setOnQueryTextListener(new SearchView.OnQueryTextListener() {<br>    @Override<br>    public boolean onQueryTextSubmit(String s) {</p>\n<pre><code>    return false;\n}\n\n@Override\npublic boolean onQueryTextChange(String s) {\n\n    return false;\n}</code></pre><p>});</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这里要注意，设置监听器前，要确保SearchView（这里的tbSearchSv）已经被实例化，否则，会出现空指针异常崩溃。   </span><br><span class=\"line\">关于SearchView，还有一写额外的设置，比如：</span><br></pre></td></tr></table></figure>\n\n<p>// 设置提交按钮是否可见（默认不可见）<br>tbSearchSv.setSubmitButtonEnabled(true);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">![提交按钮是否可见](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0MDY5MC1jYWQyNDA4MThlZGZkOTMwLnBuZw)</span><br></pre></td></tr></table></figure>\n\n<p>// 设置左侧是否显示搜索图标（默认不可见）<br>tbSearchSv.setIconifiedByDefault(false);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">![左侧是否显示搜索图标](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0MDY5MC0yMTAzODEyMzQzMWE5OGU4LnBuZw)    </span><br><span class=\"line\">更多可使用的API请参考官方文档：</span><br><span class=\"line\">https://developer.android.google.cn/reference/android/widget/SearchView  </span><br><span class=\"line\"></span><br><span class=\"line\">不过，我们这里还需要做最后一点善后。如果你是一路下来照着本篇文章敲代码的话，在搜索框打开的情况下按一下返回键，你期待的是什么？是不是取消搜索操作，停留在当前界面？然而实际上是……退出了APP。   </span><br><span class=\"line\">所以我们这里要对返回键的默认动作做一个“拦截”，具体可参考如下代码片：</span><br></pre></td></tr></table></figure>\n\n<p>@Override<br>public boolean onKeyUp(int keyCode, KeyEvent event) {<br>    switch (keyCode) {<br>        case KeyEvent.KEYCODE_BACK:<br>            if (!tbSearchSv.isIconified()) {<br>                tbSearchSv.setIconified(true);<br>                return true;<br>            }<br>            break;<br>    }<br>    return super.onKeyUp(keyCode, event);<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这里SearchView的isIconfied()方法可以返回当前的SearchView展开状态。  </span><br><span class=\"line\"></span><br><span class=\"line\">**四、返回上一层**   </span><br><span class=\"line\"></span><br><span class=\"line\">ToolBar还有一个比较常见的功能就是左上角的返回按钮，提供返回上一层操作，很多的APP开发者都习惯于自定义一个ImageButton或类似的空间，然后使用美工提供的图像素材，设置监听器，写Selector……一套下来，费时费力。  </span><br><span class=\"line\">其实Google已经为开发者提供了现成的非常易用的返回逻辑处理。要实现这些处理，两步就搞定了。  </span><br><span class=\"line\"></span><br><span class=\"line\">1\\. 在ToolBar对象上启用返回钮</span><br></pre></td></tr></table></figure>\n\n<p>getSupportActionBar().setDisplayHomeAsUpEnabled(true);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这里注意，虽然之前将ToolBar通过setSupportActionBar()方式当做参数被set了一次，但是ToolBar类本身并不提供setDisplayHomeAsUpEnabled()方法，因此，我们还需要getSupportActionBar()，先获取ActionBar对象，然后使用该对象，而不是直接使用ToolBar对象。  </span><br><span class=\"line\"></span><br><span class=\"line\">2\\. 在AndroidManifest.xml中定义要跳转的Activity  </span><br><span class=\"line\">如题，我们在AndroidManifest.xml中，对子Activity做处理，这里不要忘记兼容低版本的系统。</span><br></pre></td></tr></table></figure>\n\n<p><activity android:name=\".MainActivity\" android:parentactivityname=\".SecondActivity\"><br>    <!-- 兼容 Android4.0 及以下版本--><br>    <meta-data android:name=\"android.support.PARENT_ACTIVITY\" android:value=\".SecondActivity\"><br></meta-data></activity><br>```</p>\n<p>将SecondActivity改为入口Activity，然后重新运行程序，将实现如下效果：  </p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NDA2OTAtMWJmZDM2NDg0NTczMzg1Zi5naWY\" alt=\"返回键视频演示\">   </p>\n<p>到此，关于ToolBar常见用法的梳理告一段落。源码请自取：<br><a href=\"https://github.com/wh1990xiao2005/JetpackDemo\" target=\"_blank\" rel=\"noopener\">https://github.com/wh1990xiao2005/JetpackDemo</a>    </p>\n<p>我会在接下来的文章中，和大家分享关于ToolBar的剩余内容，以及AppCompat兼容包中的其他知识，希望对你我都有帮助。<br>共勉！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天我们来聊一聊有关AppCompat，作为Android Jetpack系列文章的开篇。说到Android Jetpack，我们先看一下这张图：   </p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0MDY5MC0zNTRjODMxNGIzMzZkZjU3LnBuZw\" alt=\"Jetpack一览\">   </p>\n<p>从图中我们可以看到，整个Android Jetpack分为了四大部分，而我们今天要讲述的就是Foundation中的AppCompat小节，官方将该部分翻译为“基础”。<br>Google官方网站：<br><a href=\"https://developer.android.com/jetpack\" target=\"_blank\" rel=\"noopener\">https://developer.android.com/jetpack</a><br>按照Google官方的描述，AppCompat就是指v7 appcompat库。   </p>\n<blockquote>\n<p>“This library adds support for the Action Bar user interface design pattern. This library includes support for material design user interface implementations.”   </p>\n</blockquote>\n<p>意思是：此库添加了对操作栏用户界面设计模式的支持。这个库包括对Material Design用户界面实现的支持。也就是说，我们可以借助该库，对Material Design有更便捷和兼容性更好的实现。<br>进入AppCompat章节后，我们发现它又被分为了4个部分，这4个部分被称为“key class”，也就是重点类，它们分别是：   </p>\n<ul>\n<li>ActionBar：提供Actionbar用户界面模式的实现；  </li>\n<li>AppCompatActivity：添加可用作使用支持库操作栏实现的Activity的基类；  </li>\n<li>AppCompatDialog：添加一个可用作AppCompat主题的Dialog的基类;  </li>\n<li>ShareActionProvider：添加对可包含在ActionBar中的标准化共享操作（如电子邮件或发布到社交应用程序）的支持。  </li>\n</ul>\n<p>想要使用这些类，我们需要添加v7支持库。<br>到现在为止，支持库的最新版本是28，添加的库名称和版本如下：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.android.support:appcompat-v7:28.0.0</span><br></pre></td></tr></table></figure>\n\n<p>今天我们就先来聊一聊ActionBar，也是这里面最为复杂的一个部分。<br>依稀记得，伴随着Google I/O 2014的召开，早在Android 5.0的时代，Google 官方推出了ToolBar组件，在那之后，ToolBar就登上了历史舞台，扮演着重要的角色。之前我在CSDN上面也发表过相关主题的文章，因为发布的时机刚好是ToolBar登场之际，所以获得了很多的阅读量。快5年过去了，回头再看那几篇连载，感觉文笔很是稚嫩。今天借着讲述Jetpack，再次聊聊ToolBar那些事，相信你我都会有新的收获。  </p>\n<p><strong>首先解决疑问：</strong></p>\n<ol>\n<li><p>问：既然有了ActionBar，为何还要用ToolBar？ 答：使用AppCompat Toolbar能兼容更广泛的设备（ActionBar要求最低Android 3.0，ToolBar要求最低Android 2.1，但只有Android 5.0及以上才能在不使用AppCompat兼容包的前提下支持Material Design），以及各式各样的自定义需求。</p>\n</li>\n<li><p>问：ToolBar上面都应该包含哪些内容？ 答：根据Google的指导，应用栏区域应具备以下要素：1）一个专用区域，可以标识您的应用并指示用户在应用中的位置；2）以可预测的方式访问搜索等重要操作；3）支持导航和视图切换（通过标签页或下拉列表）。</p>\n</li>\n</ol>\n<p><strong>一、添加ToolBar</strong><br>想要添加一个ToolBar，总共3步走：<br>1.  更改application主题样式，操作对象：styles.xml。<br>对于新建的Android项目，AndroidManifest.xml中已经定义了所使用的theme，即：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">android:theme=&quot;@style/AppTheme&quot;</span><br></pre></td></tr></table></figure>\n\n<p>此时，我们修改styles.xml文件即可，将默认的继承值改掉，如下所示：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>2. 在Activity布局中添加ToolBar，操作对象：layout布局文件  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;android.support.v7.widget.Toolbar</span><br><span class=\"line\">    android:id=&quot;@+id/activity_main_tb&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;?attr/actionBarSize&quot;</span><br><span class=\"line\">    android:background=&quot;?attr/colorPrimary&quot;</span><br><span class=\"line\">    android:elevation=&quot;4dp&quot;</span><br><span class=\"line\">    android:theme=&quot;@style/ThemeOverlay.AppCompat.ActionBar&quot;</span><br><span class=\"line\">    app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>对高度掌握不好火候的同学，直接如上使用ActionBar的高度就可以了。<br>android:evevation指“仰角”，这部分知识请参考：<br><a href=\"https://developer.android.com/training/material/shadows-clipping\" target=\"_blank\" rel=\"noopener\">https://developer.android.com/training/material/shadows-clipping</a><br>这里就不再赘述了。<br>如果你的项目已经迁移到Android X，你的布局文件代码片应该是：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;androidx.appcompat.widget.Toolbar</span><br><span class=\"line\">    android:id=&quot;@+id/activity_main_tb&quot;</span><br><span class=\"line\">    android:layout_width=&quot;match_parent&quot;</span><br><span class=\"line\">    android:layout_height=&quot;?attr/actionBarSize&quot;</span><br><span class=\"line\">    android:background=&quot;?attr/colorPrimary&quot;</span><br><span class=\"line\">    android:elevation=&quot;4dp&quot;</span><br><span class=\"line\">    android:theme=&quot;@style/ThemeOverlay.AppCompat.ActionBar&quot;</span><br><span class=\"line\">    app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>3. 在Activity类中找到ToolBar，并应用它，操作对象：Activity类<br>这一步并不复杂，参考普通的Android控件。类似地，我们通过findViewById()找到ToolBar，并做执行一些设定，即可完成该步骤，示例如下：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private Toolbar topTb;</span><br><span class=\"line\">topTb = findViewById(R.id.activity_main_tb);        </span><br><span class=\"line\">setSupportActionBar(topTb);</span><br></pre></td></tr></table></figure>\n\n<p>一旦我们setSupportActionBar()后，日后我们就可以通过getSupportActionBar()方法来获取ToolBar实例，也可以使用兼容包提供的ActionBar的各种API方法了。<br>到此，我们就完成了ToolBar的添加，还算简单吧？  </p>\n<p><strong>二、ToolBar外观的自定义</strong><br>不出意外的话，我们运行的结果将会和下图类似：  </p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0MDY5MC0zNTI2ZGYxNjMzZDcwMmExLnBuZw\" alt=\"默认的配色方案\">   </p>\n<p>大绿底，大黑字，实在不怎么好看。<br>那么，如果我们想要自定义配色方案，该如何做呢？参考下图：  </p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0MDY5MC01NDJjZmEwNzM4MmVjMzgxLmpwZw\" alt=\"配色方案指导\">  </p>\n<p>这些值我们都可以在color.xml中定义，并在styles.xml中引用。下图是一个重新定义配色方案后的截图：  </p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0MDY5MC1jYjMxN2Y4YzA1ZGE5ZWY4LnBuZw\" alt=\"自定义的配色方案\">  </p>\n<p>相关的代码片：  </p>\n<p><strong>color.xml</strong>  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;resources&gt;</span><br><span class=\"line\">    &lt;color name=&quot;colorPrimary&quot;&gt;#002FA7&lt;/color&gt;</span><br><span class=\"line\">    &lt;color name=&quot;colorPrimaryDark&quot;&gt;#001F67&lt;/color&gt;</span><br><span class=\"line\">    &lt;color name=&quot;colorAccent&quot;&gt;#003FB7&lt;/color&gt;</span><br><span class=\"line\">    &lt;color name=&quot;textColorPrimary&quot;&gt;#FFFFFF&lt;/color&gt;</span><br><span class=\"line\">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>styles.xml</strong>  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;</span><br><span class=\"line\">    &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;</span><br><span class=\"line\">    &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;</span><br><span class=\"line\">    &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;</span><br><span class=\"line\">    &lt;item name=&quot;android:textColorPrimary&quot;&gt;@color/textColorPrimary&lt;/item&gt;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n<p>细心的读者会发现，后面的截图中，右上角多了菜单项，这又是如何实现的呢？我们继续往后看。  </p>\n<p><strong>三、给ToolBar增加动作</strong><br>首先我们来看看如何给ToolBar增加菜单，我们依然分为3步完成。<br>1.  编写菜单xml文件，操作对象：menu文件夹下的菜单xml文件<br>这里我添加了两个菜单，如上图所示，一个隐藏在“更多”里，另一个是搜索。如下代码片所示：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class=\"line\">&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class=\"line\">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;item</span><br><span class=\"line\">        android:id=&quot;@+id/menu_main_info&quot;</span><br><span class=\"line\">        android:title=&quot;@string/menu_main_activity_info&quot;</span><br><span class=\"line\">        app:showAsAction=&quot;never&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;item</span><br><span class=\"line\">        android:id=&quot;@+id/menu_main_search&quot;</span><br><span class=\"line\">        android:title=&quot;@string/menu_main_activity_search&quot;</span><br><span class=\"line\">        app:actionViewClass=&quot;android.support.v7.widget.SearchView&quot;</span><br><span class=\"line\">        app:showAsAction=&quot;always&quot; /&gt;</span><br><span class=\"line\">&lt;/menu&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如上，我们可以看到有两个item，分别对应Info和搜索，我们使用”app:showAsAction”的值来控制这个菜单是否显示，常见的值有always，ifRoom，never。从字面上也很好理解，这里就不多解释了。   </p>\n<p>2. 接下来是Java代码片段：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private SearchView tbSearchSv;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">public boolean onCreateOptionsMenu(Menu menu) &#123;</span><br><span class=\"line\">    getMenuInflater().inflate(R.menu.main_activity_menu, menu);</span><br><span class=\"line\">    MenuItem searchItem = menu.findItem(R.id.menu_main_search);</span><br><span class=\"line\">    tbSearchSv = (SearchView) searchItem.getActionView();</span><br><span class=\"line\">    return super.onCreateOptionsMenu(menu);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>细心的朋友会发现有这一行：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app:actionViewClass=&quot;android.support.v7.widget.SearchView&quot;</span><br><span class=\"line\">```   </span><br><span class=\"line\"></span><br><span class=\"line\">它是做什么的呢？  </span><br><span class=\"line\"></span><br><span class=\"line\">![搜索栏效果](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0MDY5MC1kNjNiMDRjYjcyYWNiNDBmLnBuZw)   </span><br><span class=\"line\"></span><br><span class=\"line\">对了！它就是搜索栏，是原生的搜索栏。所以某些情况下，这个搜索栏是不用自己去实现的，系统已经给我们提供了SearchView！  </span><br><span class=\"line\">典型的APP：网易云音乐、知乎上方的搜索都是这样的。   </span><br><span class=\"line\"></span><br><span class=\"line\">3\\. 为菜单设置监听器，我们先来看最普通的Info按钮，我们只需在Java代码中Override指定的方法就可以了，如下所示：</span><br></pre></td></tr></table></figure>\n\n<p>@Override<br>public boolean onOptionsItemSelected(MenuItem item) {<br>    switch (item.getItemId()) {<br>        case R.id.menu_main_info:<br>            Toast.makeText(MainActivity.this, R.string.menu_main_activity_info, Toast.LENGTH_LONG).show();<br>            break;<br>    }<br>    return super.onOptionsItemSelected(item);<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">对于搜索栏，首先我们想到的是，如何获取用户输入的内容呢？  </span><br><span class=\"line\">其实很简单，玄机在于SearchView，只需对SearchView添加监听器就可以了。</span><br></pre></td></tr></table></figure>\n\n<p>tbSearchSv.setOnQueryTextListener(new SearchView.OnQueryTextListener() {<br>    @Override<br>    public boolean onQueryTextSubmit(String s) {</p>\n<pre><code>    return false;\n}\n\n@Override\npublic boolean onQueryTextChange(String s) {\n\n    return false;\n}</code></pre><p>});</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这里要注意，设置监听器前，要确保SearchView（这里的tbSearchSv）已经被实例化，否则，会出现空指针异常崩溃。   </span><br><span class=\"line\">关于SearchView，还有一写额外的设置，比如：</span><br></pre></td></tr></table></figure>\n\n<p>// 设置提交按钮是否可见（默认不可见）<br>tbSearchSv.setSubmitButtonEnabled(true);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">![提交按钮是否可见](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0MDY5MC1jYWQyNDA4MThlZGZkOTMwLnBuZw)</span><br></pre></td></tr></table></figure>\n\n<p>// 设置左侧是否显示搜索图标（默认不可见）<br>tbSearchSv.setIconifiedByDefault(false);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">![左侧是否显示搜索图标](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0MDY5MC0yMTAzODEyMzQzMWE5OGU4LnBuZw)    </span><br><span class=\"line\">更多可使用的API请参考官方文档：</span><br><span class=\"line\">https://developer.android.google.cn/reference/android/widget/SearchView  </span><br><span class=\"line\"></span><br><span class=\"line\">不过，我们这里还需要做最后一点善后。如果你是一路下来照着本篇文章敲代码的话，在搜索框打开的情况下按一下返回键，你期待的是什么？是不是取消搜索操作，停留在当前界面？然而实际上是……退出了APP。   </span><br><span class=\"line\">所以我们这里要对返回键的默认动作做一个“拦截”，具体可参考如下代码片：</span><br></pre></td></tr></table></figure>\n\n<p>@Override<br>public boolean onKeyUp(int keyCode, KeyEvent event) {<br>    switch (keyCode) {<br>        case KeyEvent.KEYCODE_BACK:<br>            if (!tbSearchSv.isIconified()) {<br>                tbSearchSv.setIconified(true);<br>                return true;<br>            }<br>            break;<br>    }<br>    return super.onKeyUp(keyCode, event);<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这里SearchView的isIconfied()方法可以返回当前的SearchView展开状态。  </span><br><span class=\"line\"></span><br><span class=\"line\">**四、返回上一层**   </span><br><span class=\"line\"></span><br><span class=\"line\">ToolBar还有一个比较常见的功能就是左上角的返回按钮，提供返回上一层操作，很多的APP开发者都习惯于自定义一个ImageButton或类似的空间，然后使用美工提供的图像素材，设置监听器，写Selector……一套下来，费时费力。  </span><br><span class=\"line\">其实Google已经为开发者提供了现成的非常易用的返回逻辑处理。要实现这些处理，两步就搞定了。  </span><br><span class=\"line\"></span><br><span class=\"line\">1\\. 在ToolBar对象上启用返回钮</span><br></pre></td></tr></table></figure>\n\n<p>getSupportActionBar().setDisplayHomeAsUpEnabled(true);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这里注意，虽然之前将ToolBar通过setSupportActionBar()方式当做参数被set了一次，但是ToolBar类本身并不提供setDisplayHomeAsUpEnabled()方法，因此，我们还需要getSupportActionBar()，先获取ActionBar对象，然后使用该对象，而不是直接使用ToolBar对象。  </span><br><span class=\"line\"></span><br><span class=\"line\">2\\. 在AndroidManifest.xml中定义要跳转的Activity  </span><br><span class=\"line\">如题，我们在AndroidManifest.xml中，对子Activity做处理，这里不要忘记兼容低版本的系统。</span><br></pre></td></tr></table></figure>\n\n<p><activity android:name=\".MainActivity\" android:parentactivityname=\".SecondActivity\"><br>    <!-- 兼容 Android4.0 及以下版本--><br>    <meta-data android:name=\"android.support.PARENT_ACTIVITY\" android:value=\".SecondActivity\"><br></meta-data></activity><br>```</p>\n<p>将SecondActivity改为入口Activity，然后重新运行程序，将实现如下效果：  </p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NDA2OTAtMWJmZDM2NDg0NTczMzg1Zi5naWY\" alt=\"返回键视频演示\">   </p>\n<p>到此，关于ToolBar常见用法的梳理告一段落。源码请自取：<br><a href=\"https://github.com/wh1990xiao2005/JetpackDemo\" target=\"_blank\" rel=\"noopener\">https://github.com/wh1990xiao2005/JetpackDemo</a>    </p>\n<p>我会在接下来的文章中，和大家分享关于ToolBar的剩余内容，以及AppCompat兼容包中的其他知识，希望对你我都有帮助。<br>共勉！</p>\n"},{"title":"自定义ImageView系列 － 区域截图（下）","date":"2015-11-06T02:42:26.000Z","_content":"\n## 功能要点：\n - 根据控件自身大小计算合适的透明正方形预览区；\n - 截取预览区图像并按照指定的尺寸缩放，生成Bitmap对象。\n\n本文着重介绍上述第2个要点，涉及两个问题：\n\n - 屏幕指定区域截图；\n - 图片缩放。\n\n由于在前文中，我们知道了指定区域的方位，那么解决起来就轻松很多了。只要先截取整个屏幕，然后利用Matrix将图片进行裁剪即可。  \n截取到指定部分的图像后，再利用Matrix的postScale()方法即可进行缩放。  \n下面放上代码片段：  \n\n```\npublic Bitmap getAdjustedBitmap(Activity activity) {\n    View view = activity.getWindow().getDecorView();\n    view.setDrawingCacheEnabled(true);\n    view.buildDrawingCache();\n    bitmap = view.getDrawingCache();\n    matrix = new Matrix();\n    matrix.postScale((CommonSettings.AVATOR\\_SIZE * 1.0f) / (previewEdge[1] - previewEdge[0]), (CommonSettings.AVATOR\\_SIZE * 1.0f) / (previewEdge[1] - previewEdge[0]));\n    return Bitmap.createBitmap(bitmap, previewEdge[0] - 2, previewEdge[2] + myLocationStart[1] - 2, previewEdge[1] - previewEdge[0], previewEdge[1] - previewEdge[0], matrix, false);\n}\n``` \n\n如上所示，即可完成截图和缩放操作。  \n接下来放上整个重写的ImageView类的代码，这里面还包含了双指缩放和单指移动操作功能。  \n\n```\nimport android.app.Activity;\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Matrix;\nimport android.graphics.Paint;\nimport android.util.AttributeSet;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.widget.ImageView;\n\npublic class PhotoChooseForAvatorImageView extends ImageView {\n    private Bitmap bitmap;\n    private Matrix matrix;\n    private float point1\\_old\\_x, point1\\_old\\_y, point1\\_new_x, point1\\_new\\_y,\n            point2\\_old\\_x, point2\\_old\\_y, point2\\_new\\_x, point2\\_new\\_y,\n            distance\\_old, distance\\_new;\n    private float point\\_old\\_x, point\\_old\\_y, point\\_new\\_x, point\\_new\\_y;\n    private boolean isMultiTouch = false;\n    private int[] myLocationStart;\n    private int[] myLocationEnd;\n    private int[] myLocationMid;\n    private int[] previewEdge;\n    private int bitmapLocXStart, bitmapLocXEnd, bitmapLocYStart, bitmapLocYEnd;\n    private Paint rectPaint;\n    private Paint rectBgPaint;\n    public PhotoChooseForAvatorImageView(Context context) {\n        super(context);\n        if (matrix == null) {\n            matrix = new Matrix();\n        }\n    }\n    public PhotoChooseForAvatorImageView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        if (matrix == null) {\n            matrix = new Matrix();\n        }\n    }\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        canvas.save();\n        if (bitmap != null) {\n            canvas.drawBitmap(bitmap, matrix, null);\n        }\n        if (previewEdge != null) {\n            //上\n            canvas.drawLine(previewEdge[0], previewEdge[2], previewEdge[1], previewEdge[2], rectPaint);\n            //左\n            canvas.drawLine(previewEdge[0], previewEdge[2], previewEdge[0], previewEdge[3], rectPaint);\n            //下\n            canvas.drawLine(previewEdge[0], previewEdge[3], previewEdge[1], previewEdge[3], rectPaint);\n            //右\n            canvas.drawLine(previewEdge[1], previewEdge[2], previewEdge[1], previewEdge[3], rectPaint);\n            //灰色部分\n            canvas.drawRect(0, 0, previewEdge[0], myLocationEnd[1], rectBgPaint);\n            canvas.drawRect(previewEdge[0], 0, previewEdge[1], previewEdge[2], rectBgPaint);\n            canvas.drawRect(previewEdge[1], 0, myLocationEnd[0], myLocationEnd[1], rectBgPaint);\n            canvas.drawRect(previewEdge[0], previewEdge[3], previewEdge[1], myLocationEnd[1], rectBgPaint);\n        }\n        canvas.restore();\n    }\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        switch (event.getAction() & MotionEvent.ACTION\\_MASK) {\n            case MotionEvent.ACTION\\_DOWN:\n                // 单点移动 按下\n                if (event.getPointerCount() == 1) {\n                    isMultiTouch = false;\n                    point\\_old\\_x = event.getX();\n                    point\\_old\\_y = event.getY();\n                }\n                break;\n            case MotionEvent.ACTION\\_UP:\n                // 单点移动 抬起\n                if (event.getPointerCount() == 1) {\n                    isMultiTouch = false;\n                    point\\_old\\_x = point\\_new\\_x;\n                    point\\_old\\_y = point\\_new\\_y;\n                }\n                break;\n            case MotionEvent.ACTION\\_POINTER\\_UP:\n                // 双点操作 抬起\n                if (event.getPointerCount() == 2) {\n                    isMultiTouch = true;\n                    point1\\_old\\_x = point1\\_new\\_x;\n                    point1\\_old\\_y = point1\\_new\\_y;\n                    point2\\_old\\_x = point2\\_new\\_x;\n                    point2\\_old\\_y = point2\\_new\\_y;\n                }\n                break;\n            case MotionEvent.ACTION\\_POINTER\\_DOWN:\n                // 双点操作 按下\n                if (event.getPointerCount() == 2) {\n                    isMultiTouch = true;\n                    point1\\_old\\_x = event.getX(0);\n                    point1\\_old\\_y = event.getY(0);\n                    point2\\_old\\_x = event.getX(1);\n                    point2\\_old\\_y = event.getY(1);\n                    distance_old = (float) Math\n                            .sqrt(((point1\\_old\\_x - point2\\_old\\_x)\n                                    * (point1\\_old\\_x - point2\\_old\\_x) + (point1\\_old\\_y - point2\\_old\\_y)\n                                    * (point1\\_old\\_y - point2\\_old\\_y)));\n                }\n                break;\n            case MotionEvent.ACTION_MOVE:\n                // 双点操作 移动\n                if (event.getPointerCount() == 2) {\n                    isMultiTouch = true;\n                    point1\\_new\\_x = event.getX(0);\n                    point1\\_new\\_y = event.getY(0);\n                    point2\\_new\\_x = event.getX(1);\n                    point2\\_new\\_y = event.getY(1);\n                    pinch();\n                } else {\n                    // 单点移动 移动\n                    if (event.getPointerCount() == 1) {\n                        if (!isMultiTouch) {\n                            point_\\new\\_x = event.getX();\n                            point\\_new\\_y = event.getY();\n                            matrix.postTranslate((point\\_new_x - point\\_old\\_x),\n                                    (point\\_new\\_y - point\\_old\\_y));\n                            point\\_old\\_x = point\\_new\\_x;\n                            point\\_old\\_y = point\\_new\\_y;\n                            invalidate();\n                        }\n                    }\n                }\n                break;\n        }\n        return true;\n    }\n    // 缩放图片方法\n    private void pinch() {\n        distance_new = (float) Math.sqrt(((point1_new_x - point2_new_x)\n                * (point1_new_x - point2_new_x) + (point1_new_y - point2_new_y)\n                * (point1_new_y - point2_new_y)));\n        matrix.postScale((distance_new / distance_old),\n                (distance_new / distance_old), this.getWidth() / 2,\n                this.getTop() / 2);\n        invalidate();\n        distance_old = distance_new;\n    }\n    /**\n     * 设置Bitmap\n     *\n     * @param bitmap\n     */\n    public void setImage(Bitmap bitmap) {\n        this.bitmap = bitmap;\n        //获取控件自身起始点\n        myLocationStart = new int[2];\n        getLocationOnScreen(myLocationStart);\n        //获取控件自身终止点\n        myLocationEnd = new int[2];\n        myLocationEnd[0] = getWidth() + myLocationStart[0];\n        myLocationEnd[1] = getHeight() + myLocationStart[1];\n        //计算控件自身中点\n        myLocationMid = new int[2];\n        myLocationMid[0] = (myLocationStart[0] + myLocationEnd[0]) / 2;\n        myLocationMid[1] = (myLocationStart[1] + myLocationEnd[1]) / 2 - myLocationStart[1];\n        //设置中间预览框边框色\n        rectPaint = new Paint();\n        rectPaint.setColor(Color.WHITE);\n        rectPaint.setStrokeWidth(2);\n        rectBgPaint = new Paint();\n        rectBgPaint.setColor(getResources().getColor(R.color.photo_adjust_for_avator_bg));\n        //计算中间预览边框位置\n        previewEdge = new int[4];\n        previewEdge[0] = (myLocationMid[0] - myLocationStart[0]) / 8;\n        previewEdge[1] = myLocationEnd[0] - previewEdge[0];\n        previewEdge[2] = myLocationMid[1] - ((previewEdge[1] - previewEdge[0]) / 2);\n        previewEdge[3] = myLocationMid[1] + ((previewEdge[1] - previewEdge[0]) / 2);\n        //计算Bitmap起点\n        bitmapLocXStart = myLocationMid[0] - bitmap.getWidth() / 2;\n        bitmapLocYStart = myLocationMid[1] - bitmap.getHeight() / 2;\n        bitmapLocXEnd = bitmapLocXStart + bitmap.getWidth();\n        bitmapLocYEnd = bitmapLocYStart - bitmap.getHeight();\n        //调整Bitmap位置\n        matrix.postTranslate(bitmapLocXStart, bitmapLocYStart);\n        PhotoChooseForAvatorImageView.this.invalidate();\n    }\n    /**\n     * 截图并返回Bitmap对象\n     */\n    public Bitmap getAdjustedBitmap(Activity activity) {\n        View view = activity.getWindow().getDecorView();\n        view.setDrawingCacheEnabled(true);\n        view.buildDrawingCache();\n        bitmap = view.getDrawingCache();\n        matrix = new Matrix();\n        matrix.postScale((CommonSettings.AVATOR_SIZE * 1.0f) / (previewEdge[1] - previewEdge[0]), (CommonSettings.AVATOR_SIZE * 1.0f) / (previewEdge[1] - previewEdge[0]));\n        return Bitmap.createBitmap(bitmap, previewEdge[0] - 2, previewEdge[2] + myLocationStart[1] - 2, previewEdge[1] - previewEdge[0], previewEdge[1] - previewEdge[0], matrix, false);\n    }\n    /**\n     * 重置Bitmap（回收内存）\n     */\n    public void resetBitmap() {\n        bitmap.recycle();\n        bitmap = null;\n    }\n}\n```","source":"_posts/自定义ImageView系列 － 区域截图（下）.md","raw":"---\ntitle: 自定义ImageView系列 － 区域截图（下）\ndate: 2015-11-06 10:42:26\ntags: Android\ncategories: 编程世界\n---\n\n## 功能要点：\n - 根据控件自身大小计算合适的透明正方形预览区；\n - 截取预览区图像并按照指定的尺寸缩放，生成Bitmap对象。\n\n本文着重介绍上述第2个要点，涉及两个问题：\n\n - 屏幕指定区域截图；\n - 图片缩放。\n\n由于在前文中，我们知道了指定区域的方位，那么解决起来就轻松很多了。只要先截取整个屏幕，然后利用Matrix将图片进行裁剪即可。  \n截取到指定部分的图像后，再利用Matrix的postScale()方法即可进行缩放。  \n下面放上代码片段：  \n\n```\npublic Bitmap getAdjustedBitmap(Activity activity) {\n    View view = activity.getWindow().getDecorView();\n    view.setDrawingCacheEnabled(true);\n    view.buildDrawingCache();\n    bitmap = view.getDrawingCache();\n    matrix = new Matrix();\n    matrix.postScale((CommonSettings.AVATOR\\_SIZE * 1.0f) / (previewEdge[1] - previewEdge[0]), (CommonSettings.AVATOR\\_SIZE * 1.0f) / (previewEdge[1] - previewEdge[0]));\n    return Bitmap.createBitmap(bitmap, previewEdge[0] - 2, previewEdge[2] + myLocationStart[1] - 2, previewEdge[1] - previewEdge[0], previewEdge[1] - previewEdge[0], matrix, false);\n}\n``` \n\n如上所示，即可完成截图和缩放操作。  \n接下来放上整个重写的ImageView类的代码，这里面还包含了双指缩放和单指移动操作功能。  \n\n```\nimport android.app.Activity;\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Matrix;\nimport android.graphics.Paint;\nimport android.util.AttributeSet;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.widget.ImageView;\n\npublic class PhotoChooseForAvatorImageView extends ImageView {\n    private Bitmap bitmap;\n    private Matrix matrix;\n    private float point1\\_old\\_x, point1\\_old\\_y, point1\\_new_x, point1\\_new\\_y,\n            point2\\_old\\_x, point2\\_old\\_y, point2\\_new\\_x, point2\\_new\\_y,\n            distance\\_old, distance\\_new;\n    private float point\\_old\\_x, point\\_old\\_y, point\\_new\\_x, point\\_new\\_y;\n    private boolean isMultiTouch = false;\n    private int[] myLocationStart;\n    private int[] myLocationEnd;\n    private int[] myLocationMid;\n    private int[] previewEdge;\n    private int bitmapLocXStart, bitmapLocXEnd, bitmapLocYStart, bitmapLocYEnd;\n    private Paint rectPaint;\n    private Paint rectBgPaint;\n    public PhotoChooseForAvatorImageView(Context context) {\n        super(context);\n        if (matrix == null) {\n            matrix = new Matrix();\n        }\n    }\n    public PhotoChooseForAvatorImageView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        if (matrix == null) {\n            matrix = new Matrix();\n        }\n    }\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        canvas.save();\n        if (bitmap != null) {\n            canvas.drawBitmap(bitmap, matrix, null);\n        }\n        if (previewEdge != null) {\n            //上\n            canvas.drawLine(previewEdge[0], previewEdge[2], previewEdge[1], previewEdge[2], rectPaint);\n            //左\n            canvas.drawLine(previewEdge[0], previewEdge[2], previewEdge[0], previewEdge[3], rectPaint);\n            //下\n            canvas.drawLine(previewEdge[0], previewEdge[3], previewEdge[1], previewEdge[3], rectPaint);\n            //右\n            canvas.drawLine(previewEdge[1], previewEdge[2], previewEdge[1], previewEdge[3], rectPaint);\n            //灰色部分\n            canvas.drawRect(0, 0, previewEdge[0], myLocationEnd[1], rectBgPaint);\n            canvas.drawRect(previewEdge[0], 0, previewEdge[1], previewEdge[2], rectBgPaint);\n            canvas.drawRect(previewEdge[1], 0, myLocationEnd[0], myLocationEnd[1], rectBgPaint);\n            canvas.drawRect(previewEdge[0], previewEdge[3], previewEdge[1], myLocationEnd[1], rectBgPaint);\n        }\n        canvas.restore();\n    }\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        switch (event.getAction() & MotionEvent.ACTION\\_MASK) {\n            case MotionEvent.ACTION\\_DOWN:\n                // 单点移动 按下\n                if (event.getPointerCount() == 1) {\n                    isMultiTouch = false;\n                    point\\_old\\_x = event.getX();\n                    point\\_old\\_y = event.getY();\n                }\n                break;\n            case MotionEvent.ACTION\\_UP:\n                // 单点移动 抬起\n                if (event.getPointerCount() == 1) {\n                    isMultiTouch = false;\n                    point\\_old\\_x = point\\_new\\_x;\n                    point\\_old\\_y = point\\_new\\_y;\n                }\n                break;\n            case MotionEvent.ACTION\\_POINTER\\_UP:\n                // 双点操作 抬起\n                if (event.getPointerCount() == 2) {\n                    isMultiTouch = true;\n                    point1\\_old\\_x = point1\\_new\\_x;\n                    point1\\_old\\_y = point1\\_new\\_y;\n                    point2\\_old\\_x = point2\\_new\\_x;\n                    point2\\_old\\_y = point2\\_new\\_y;\n                }\n                break;\n            case MotionEvent.ACTION\\_POINTER\\_DOWN:\n                // 双点操作 按下\n                if (event.getPointerCount() == 2) {\n                    isMultiTouch = true;\n                    point1\\_old\\_x = event.getX(0);\n                    point1\\_old\\_y = event.getY(0);\n                    point2\\_old\\_x = event.getX(1);\n                    point2\\_old\\_y = event.getY(1);\n                    distance_old = (float) Math\n                            .sqrt(((point1\\_old\\_x - point2\\_old\\_x)\n                                    * (point1\\_old\\_x - point2\\_old\\_x) + (point1\\_old\\_y - point2\\_old\\_y)\n                                    * (point1\\_old\\_y - point2\\_old\\_y)));\n                }\n                break;\n            case MotionEvent.ACTION_MOVE:\n                // 双点操作 移动\n                if (event.getPointerCount() == 2) {\n                    isMultiTouch = true;\n                    point1\\_new\\_x = event.getX(0);\n                    point1\\_new\\_y = event.getY(0);\n                    point2\\_new\\_x = event.getX(1);\n                    point2\\_new\\_y = event.getY(1);\n                    pinch();\n                } else {\n                    // 单点移动 移动\n                    if (event.getPointerCount() == 1) {\n                        if (!isMultiTouch) {\n                            point_\\new\\_x = event.getX();\n                            point\\_new\\_y = event.getY();\n                            matrix.postTranslate((point\\_new_x - point\\_old\\_x),\n                                    (point\\_new\\_y - point\\_old\\_y));\n                            point\\_old\\_x = point\\_new\\_x;\n                            point\\_old\\_y = point\\_new\\_y;\n                            invalidate();\n                        }\n                    }\n                }\n                break;\n        }\n        return true;\n    }\n    // 缩放图片方法\n    private void pinch() {\n        distance_new = (float) Math.sqrt(((point1_new_x - point2_new_x)\n                * (point1_new_x - point2_new_x) + (point1_new_y - point2_new_y)\n                * (point1_new_y - point2_new_y)));\n        matrix.postScale((distance_new / distance_old),\n                (distance_new / distance_old), this.getWidth() / 2,\n                this.getTop() / 2);\n        invalidate();\n        distance_old = distance_new;\n    }\n    /**\n     * 设置Bitmap\n     *\n     * @param bitmap\n     */\n    public void setImage(Bitmap bitmap) {\n        this.bitmap = bitmap;\n        //获取控件自身起始点\n        myLocationStart = new int[2];\n        getLocationOnScreen(myLocationStart);\n        //获取控件自身终止点\n        myLocationEnd = new int[2];\n        myLocationEnd[0] = getWidth() + myLocationStart[0];\n        myLocationEnd[1] = getHeight() + myLocationStart[1];\n        //计算控件自身中点\n        myLocationMid = new int[2];\n        myLocationMid[0] = (myLocationStart[0] + myLocationEnd[0]) / 2;\n        myLocationMid[1] = (myLocationStart[1] + myLocationEnd[1]) / 2 - myLocationStart[1];\n        //设置中间预览框边框色\n        rectPaint = new Paint();\n        rectPaint.setColor(Color.WHITE);\n        rectPaint.setStrokeWidth(2);\n        rectBgPaint = new Paint();\n        rectBgPaint.setColor(getResources().getColor(R.color.photo_adjust_for_avator_bg));\n        //计算中间预览边框位置\n        previewEdge = new int[4];\n        previewEdge[0] = (myLocationMid[0] - myLocationStart[0]) / 8;\n        previewEdge[1] = myLocationEnd[0] - previewEdge[0];\n        previewEdge[2] = myLocationMid[1] - ((previewEdge[1] - previewEdge[0]) / 2);\n        previewEdge[3] = myLocationMid[1] + ((previewEdge[1] - previewEdge[0]) / 2);\n        //计算Bitmap起点\n        bitmapLocXStart = myLocationMid[0] - bitmap.getWidth() / 2;\n        bitmapLocYStart = myLocationMid[1] - bitmap.getHeight() / 2;\n        bitmapLocXEnd = bitmapLocXStart + bitmap.getWidth();\n        bitmapLocYEnd = bitmapLocYStart - bitmap.getHeight();\n        //调整Bitmap位置\n        matrix.postTranslate(bitmapLocXStart, bitmapLocYStart);\n        PhotoChooseForAvatorImageView.this.invalidate();\n    }\n    /**\n     * 截图并返回Bitmap对象\n     */\n    public Bitmap getAdjustedBitmap(Activity activity) {\n        View view = activity.getWindow().getDecorView();\n        view.setDrawingCacheEnabled(true);\n        view.buildDrawingCache();\n        bitmap = view.getDrawingCache();\n        matrix = new Matrix();\n        matrix.postScale((CommonSettings.AVATOR_SIZE * 1.0f) / (previewEdge[1] - previewEdge[0]), (CommonSettings.AVATOR_SIZE * 1.0f) / (previewEdge[1] - previewEdge[0]));\n        return Bitmap.createBitmap(bitmap, previewEdge[0] - 2, previewEdge[2] + myLocationStart[1] - 2, previewEdge[1] - previewEdge[0], previewEdge[1] - previewEdge[0], matrix, false);\n    }\n    /**\n     * 重置Bitmap（回收内存）\n     */\n    public void resetBitmap() {\n        bitmap.recycle();\n        bitmap = null;\n    }\n}\n```","slug":"自定义ImageView系列 － 区域截图（下）","published":1,"updated":"2019-07-31T04:11:59.822Z","_id":"cjyqq3tkt0023fkqdzl924y55","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"功能要点：\"><a href=\"#功能要点：\" class=\"headerlink\" title=\"功能要点：\"></a>功能要点：</h2><ul>\n<li>根据控件自身大小计算合适的透明正方形预览区；</li>\n<li>截取预览区图像并按照指定的尺寸缩放，生成Bitmap对象。</li>\n</ul>\n<p>本文着重介绍上述第2个要点，涉及两个问题：</p>\n<ul>\n<li>屏幕指定区域截图；</li>\n<li>图片缩放。</li>\n</ul>\n<p>由于在前文中，我们知道了指定区域的方位，那么解决起来就轻松很多了。只要先截取整个屏幕，然后利用Matrix将图片进行裁剪即可。<br>截取到指定部分的图像后，再利用Matrix的postScale()方法即可进行缩放。<br>下面放上代码片段：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Bitmap getAdjustedBitmap(Activity activity) &#123;</span><br><span class=\"line\">    View view = activity.getWindow().getDecorView();</span><br><span class=\"line\">    view.setDrawingCacheEnabled(true);</span><br><span class=\"line\">    view.buildDrawingCache();</span><br><span class=\"line\">    bitmap = view.getDrawingCache();</span><br><span class=\"line\">    matrix = new Matrix();</span><br><span class=\"line\">    matrix.postScale((CommonSettings.AVATOR\\_SIZE * 1.0f) / (previewEdge[1] - previewEdge[0]), (CommonSettings.AVATOR\\_SIZE * 1.0f) / (previewEdge[1] - previewEdge[0]));</span><br><span class=\"line\">    return Bitmap.createBitmap(bitmap, previewEdge[0] - 2, previewEdge[2] + myLocationStart[1] - 2, previewEdge[1] - previewEdge[0], previewEdge[1] - previewEdge[0], matrix, false);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">如上所示，即可完成截图和缩放操作。  </span><br><span class=\"line\">接下来放上整个重写的ImageView类的代码，这里面还包含了双指缩放和单指移动操作功能。</span><br></pre></td></tr></table></figure>\n\n<p>import android.app.Activity;<br>import android.content.Context;<br>import android.graphics.Bitmap;<br>import android.graphics.Canvas;<br>import android.graphics.Color;<br>import android.graphics.Matrix;<br>import android.graphics.Paint;<br>import android.util.AttributeSet;<br>import android.view.MotionEvent;<br>import android.view.View;<br>import android.widget.ImageView;</p>\n<p>public class PhotoChooseForAvatorImageView extends ImageView {<br>    private Bitmap bitmap;<br>    private Matrix matrix;<br>    private float point1_old_x, point1_old_y, point1_new_x, point1_new_y,<br>            point2_old_x, point2_old_y, point2_new_x, point2_new_y,<br>            distance_old, distance_new;<br>    private float point_old_x, point_old_y, point_new_x, point_new_y;<br>    private boolean isMultiTouch = false;<br>    private int[] myLocationStart;<br>    private int[] myLocationEnd;<br>    private int[] myLocationMid;<br>    private int[] previewEdge;<br>    private int bitmapLocXStart, bitmapLocXEnd, bitmapLocYStart, bitmapLocYEnd;<br>    private Paint rectPaint;<br>    private Paint rectBgPaint;<br>    public PhotoChooseForAvatorImageView(Context context) {<br>        super(context);<br>        if (matrix == null) {<br>            matrix = new Matrix();<br>        }<br>    }<br>    public PhotoChooseForAvatorImageView(Context context, AttributeSet attrs) {<br>        super(context, attrs);<br>        if (matrix == null) {<br>            matrix = new Matrix();<br>        }<br>    }<br>    @Override<br>    protected void onDraw(Canvas canvas) {<br>        super.onDraw(canvas);<br>        canvas.save();<br>        if (bitmap != null) {<br>            canvas.drawBitmap(bitmap, matrix, null);<br>        }<br>        if (previewEdge != null) {<br>            //上<br>            canvas.drawLine(previewEdge[0], previewEdge[2], previewEdge[1], previewEdge[2], rectPaint);<br>            //左<br>            canvas.drawLine(previewEdge[0], previewEdge[2], previewEdge[0], previewEdge[3], rectPaint);<br>            //下<br>            canvas.drawLine(previewEdge[0], previewEdge[3], previewEdge[1], previewEdge[3], rectPaint);<br>            //右<br>            canvas.drawLine(previewEdge[1], previewEdge[2], previewEdge[1], previewEdge[3], rectPaint);<br>            //灰色部分<br>            canvas.drawRect(0, 0, previewEdge[0], myLocationEnd[1], rectBgPaint);<br>            canvas.drawRect(previewEdge[0], 0, previewEdge[1], previewEdge[2], rectBgPaint);<br>            canvas.drawRect(previewEdge[1], 0, myLocationEnd[0], myLocationEnd[1], rectBgPaint);<br>            canvas.drawRect(previewEdge[0], previewEdge[3], previewEdge[1], myLocationEnd[1], rectBgPaint);<br>        }<br>        canvas.restore();<br>    }<br>    @Override<br>    public boolean onTouchEvent(MotionEvent event) {<br>        switch (event.getAction() &amp; MotionEvent.ACTION_MASK) {<br>            case MotionEvent.ACTION_DOWN:<br>                // 单点移动 按下<br>                if (event.getPointerCount() == 1) {<br>                    isMultiTouch = false;<br>                    point_old_x = event.getX();<br>                    point_old_y = event.getY();<br>                }<br>                break;<br>            case MotionEvent.ACTION_UP:<br>                // 单点移动 抬起<br>                if (event.getPointerCount() == 1) {<br>                    isMultiTouch = false;<br>                    point_old_x = point_new_x;<br>                    point_old_y = point_new_y;<br>                }<br>                break;<br>            case MotionEvent.ACTION_POINTER_UP:<br>                // 双点操作 抬起<br>                if (event.getPointerCount() == 2) {<br>                    isMultiTouch = true;<br>                    point1_old_x = point1_new_x;<br>                    point1_old_y = point1_new_y;<br>                    point2_old_x = point2_new_x;<br>                    point2_old_y = point2_new_y;<br>                }<br>                break;<br>            case MotionEvent.ACTION_POINTER_DOWN:<br>                // 双点操作 按下<br>                if (event.getPointerCount() == 2) {<br>                    isMultiTouch = true;<br>                    point1_old_x = event.getX(0);<br>                    point1_old_y = event.getY(0);<br>                    point2_old_x = event.getX(1);<br>                    point2_old_y = event.getY(1);<br>                    distance_old = (float) Math<br>                            .sqrt(((point1_old_x - point2_old_x)<br>                                    * (point1_old_x - point2_old_x) + (point1_old_y - point2_old_y)<br>                                    * (point1_old_y - point2_old_y)));<br>                }<br>                break;<br>            case MotionEvent.ACTION_MOVE:<br>                // 双点操作 移动<br>                if (event.getPointerCount() == 2) {<br>                    isMultiTouch = true;<br>                    point1_new_x = event.getX(0);<br>                    point1_new_y = event.getY(0);<br>                    point2_new_x = event.getX(1);<br>                    point2_new_y = event.getY(1);<br>                    pinch();<br>                } else {<br>                    // 单点移动 移动<br>                    if (event.getPointerCount() == 1) {<br>                        if (!isMultiTouch) {<br>                            point_\\new_x = event.getX();<br>                            point_new_y = event.getY();<br>                            matrix.postTranslate((point_new_x - point_old_x),<br>                                    (point_new_y - point_old_y));<br>                            point_old_x = point_new_x;<br>                            point_old_y = point_new_y;<br>                            invalidate();<br>                        }<br>                    }<br>                }<br>                break;<br>        }<br>        return true;<br>    }<br>    // 缩放图片方法<br>    private void pinch() {<br>        distance_new = (float) Math.sqrt(((point1_new_x - point2_new_x)<br>                * (point1_new_x - point2_new_x) + (point1_new_y - point2_new_y)<br>                * (point1_new_y - point2_new_y)));<br>        matrix.postScale((distance_new / distance_old),<br>                (distance_new / distance_old), this.getWidth() / 2,<br>                this.getTop() / 2);<br>        invalidate();<br>        distance_old = distance_new;<br>    }<br>    /**<br>     * 设置Bitmap<br>     *<br>     * @param bitmap<br>     <em>/<br>    public void setImage(Bitmap bitmap) {<br>        this.bitmap = bitmap;<br>        //获取控件自身起始点<br>        myLocationStart = new int[2];<br>        getLocationOnScreen(myLocationStart);<br>        //获取控件自身终止点<br>        myLocationEnd = new int[2];<br>        myLocationEnd[0] = getWidth() + myLocationStart[0];<br>        myLocationEnd[1] = getHeight() + myLocationStart[1];<br>        //计算控件自身中点<br>        myLocationMid = new int[2];<br>        myLocationMid[0] = (myLocationStart[0] + myLocationEnd[0]) / 2;<br>        myLocationMid[1] = (myLocationStart[1] + myLocationEnd[1]) / 2 - myLocationStart[1];<br>        //设置中间预览框边框色<br>        rectPaint = new Paint();<br>        rectPaint.setColor(Color.WHITE);<br>        rectPaint.setStrokeWidth(2);<br>        rectBgPaint = new Paint();<br>        rectBgPaint.setColor(getResources().getColor(R.color.photo_adjust_for_avator_bg));<br>        //计算中间预览边框位置<br>        previewEdge = new int[4];<br>        previewEdge[0] = (myLocationMid[0] - myLocationStart[0]) / 8;<br>        previewEdge[1] = myLocationEnd[0] - previewEdge[0];<br>        previewEdge[2] = myLocationMid[1] - ((previewEdge[1] - previewEdge[0]) / 2);<br>        previewEdge[3] = myLocationMid[1] + ((previewEdge[1] - previewEdge[0]) / 2);<br>        //计算Bitmap起点<br>        bitmapLocXStart = myLocationMid[0] - bitmap.getWidth() / 2;<br>        bitmapLocYStart = myLocationMid[1] - bitmap.getHeight() / 2;<br>        bitmapLocXEnd = bitmapLocXStart + bitmap.getWidth();<br>        bitmapLocYEnd = bitmapLocYStart - bitmap.getHeight();<br>        //调整Bitmap位置<br>        matrix.postTranslate(bitmapLocXStart, bitmapLocYStart);<br>        PhotoChooseForAvatorImageView.this.invalidate();<br>    }<br>    /*</em><br>     * 截图并返回Bitmap对象<br>     <em>/<br>    public Bitmap getAdjustedBitmap(Activity activity) {<br>        View view = activity.getWindow().getDecorView();<br>        view.setDrawingCacheEnabled(true);<br>        view.buildDrawingCache();<br>        bitmap = view.getDrawingCache();<br>        matrix = new Matrix();<br>        matrix.postScale((CommonSettings.AVATOR_SIZE * 1.0f) / (previewEdge[1] - previewEdge[0]), (CommonSettings.AVATOR_SIZE * 1.0f) / (previewEdge[1] - previewEdge[0]));<br>        return Bitmap.createBitmap(bitmap, previewEdge[0] - 2, previewEdge[2] + myLocationStart[1] - 2, previewEdge[1] - previewEdge[0], previewEdge[1] - previewEdge[0], matrix, false);<br>    }<br>    /*</em><br>     * 重置Bitmap（回收内存）<br>     */<br>    public void resetBitmap() {<br>        bitmap.recycle();<br>        bitmap = null;<br>    }<br>}<br>```</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"功能要点：\"><a href=\"#功能要点：\" class=\"headerlink\" title=\"功能要点：\"></a>功能要点：</h2><ul>\n<li>根据控件自身大小计算合适的透明正方形预览区；</li>\n<li>截取预览区图像并按照指定的尺寸缩放，生成Bitmap对象。</li>\n</ul>\n<p>本文着重介绍上述第2个要点，涉及两个问题：</p>\n<ul>\n<li>屏幕指定区域截图；</li>\n<li>图片缩放。</li>\n</ul>\n<p>由于在前文中，我们知道了指定区域的方位，那么解决起来就轻松很多了。只要先截取整个屏幕，然后利用Matrix将图片进行裁剪即可。<br>截取到指定部分的图像后，再利用Matrix的postScale()方法即可进行缩放。<br>下面放上代码片段：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Bitmap getAdjustedBitmap(Activity activity) &#123;</span><br><span class=\"line\">    View view = activity.getWindow().getDecorView();</span><br><span class=\"line\">    view.setDrawingCacheEnabled(true);</span><br><span class=\"line\">    view.buildDrawingCache();</span><br><span class=\"line\">    bitmap = view.getDrawingCache();</span><br><span class=\"line\">    matrix = new Matrix();</span><br><span class=\"line\">    matrix.postScale((CommonSettings.AVATOR\\_SIZE * 1.0f) / (previewEdge[1] - previewEdge[0]), (CommonSettings.AVATOR\\_SIZE * 1.0f) / (previewEdge[1] - previewEdge[0]));</span><br><span class=\"line\">    return Bitmap.createBitmap(bitmap, previewEdge[0] - 2, previewEdge[2] + myLocationStart[1] - 2, previewEdge[1] - previewEdge[0], previewEdge[1] - previewEdge[0], matrix, false);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">如上所示，即可完成截图和缩放操作。  </span><br><span class=\"line\">接下来放上整个重写的ImageView类的代码，这里面还包含了双指缩放和单指移动操作功能。</span><br></pre></td></tr></table></figure>\n\n<p>import android.app.Activity;<br>import android.content.Context;<br>import android.graphics.Bitmap;<br>import android.graphics.Canvas;<br>import android.graphics.Color;<br>import android.graphics.Matrix;<br>import android.graphics.Paint;<br>import android.util.AttributeSet;<br>import android.view.MotionEvent;<br>import android.view.View;<br>import android.widget.ImageView;</p>\n<p>public class PhotoChooseForAvatorImageView extends ImageView {<br>    private Bitmap bitmap;<br>    private Matrix matrix;<br>    private float point1_old_x, point1_old_y, point1_new_x, point1_new_y,<br>            point2_old_x, point2_old_y, point2_new_x, point2_new_y,<br>            distance_old, distance_new;<br>    private float point_old_x, point_old_y, point_new_x, point_new_y;<br>    private boolean isMultiTouch = false;<br>    private int[] myLocationStart;<br>    private int[] myLocationEnd;<br>    private int[] myLocationMid;<br>    private int[] previewEdge;<br>    private int bitmapLocXStart, bitmapLocXEnd, bitmapLocYStart, bitmapLocYEnd;<br>    private Paint rectPaint;<br>    private Paint rectBgPaint;<br>    public PhotoChooseForAvatorImageView(Context context) {<br>        super(context);<br>        if (matrix == null) {<br>            matrix = new Matrix();<br>        }<br>    }<br>    public PhotoChooseForAvatorImageView(Context context, AttributeSet attrs) {<br>        super(context, attrs);<br>        if (matrix == null) {<br>            matrix = new Matrix();<br>        }<br>    }<br>    @Override<br>    protected void onDraw(Canvas canvas) {<br>        super.onDraw(canvas);<br>        canvas.save();<br>        if (bitmap != null) {<br>            canvas.drawBitmap(bitmap, matrix, null);<br>        }<br>        if (previewEdge != null) {<br>            //上<br>            canvas.drawLine(previewEdge[0], previewEdge[2], previewEdge[1], previewEdge[2], rectPaint);<br>            //左<br>            canvas.drawLine(previewEdge[0], previewEdge[2], previewEdge[0], previewEdge[3], rectPaint);<br>            //下<br>            canvas.drawLine(previewEdge[0], previewEdge[3], previewEdge[1], previewEdge[3], rectPaint);<br>            //右<br>            canvas.drawLine(previewEdge[1], previewEdge[2], previewEdge[1], previewEdge[3], rectPaint);<br>            //灰色部分<br>            canvas.drawRect(0, 0, previewEdge[0], myLocationEnd[1], rectBgPaint);<br>            canvas.drawRect(previewEdge[0], 0, previewEdge[1], previewEdge[2], rectBgPaint);<br>            canvas.drawRect(previewEdge[1], 0, myLocationEnd[0], myLocationEnd[1], rectBgPaint);<br>            canvas.drawRect(previewEdge[0], previewEdge[3], previewEdge[1], myLocationEnd[1], rectBgPaint);<br>        }<br>        canvas.restore();<br>    }<br>    @Override<br>    public boolean onTouchEvent(MotionEvent event) {<br>        switch (event.getAction() &amp; MotionEvent.ACTION_MASK) {<br>            case MotionEvent.ACTION_DOWN:<br>                // 单点移动 按下<br>                if (event.getPointerCount() == 1) {<br>                    isMultiTouch = false;<br>                    point_old_x = event.getX();<br>                    point_old_y = event.getY();<br>                }<br>                break;<br>            case MotionEvent.ACTION_UP:<br>                // 单点移动 抬起<br>                if (event.getPointerCount() == 1) {<br>                    isMultiTouch = false;<br>                    point_old_x = point_new_x;<br>                    point_old_y = point_new_y;<br>                }<br>                break;<br>            case MotionEvent.ACTION_POINTER_UP:<br>                // 双点操作 抬起<br>                if (event.getPointerCount() == 2) {<br>                    isMultiTouch = true;<br>                    point1_old_x = point1_new_x;<br>                    point1_old_y = point1_new_y;<br>                    point2_old_x = point2_new_x;<br>                    point2_old_y = point2_new_y;<br>                }<br>                break;<br>            case MotionEvent.ACTION_POINTER_DOWN:<br>                // 双点操作 按下<br>                if (event.getPointerCount() == 2) {<br>                    isMultiTouch = true;<br>                    point1_old_x = event.getX(0);<br>                    point1_old_y = event.getY(0);<br>                    point2_old_x = event.getX(1);<br>                    point2_old_y = event.getY(1);<br>                    distance_old = (float) Math<br>                            .sqrt(((point1_old_x - point2_old_x)<br>                                    * (point1_old_x - point2_old_x) + (point1_old_y - point2_old_y)<br>                                    * (point1_old_y - point2_old_y)));<br>                }<br>                break;<br>            case MotionEvent.ACTION_MOVE:<br>                // 双点操作 移动<br>                if (event.getPointerCount() == 2) {<br>                    isMultiTouch = true;<br>                    point1_new_x = event.getX(0);<br>                    point1_new_y = event.getY(0);<br>                    point2_new_x = event.getX(1);<br>                    point2_new_y = event.getY(1);<br>                    pinch();<br>                } else {<br>                    // 单点移动 移动<br>                    if (event.getPointerCount() == 1) {<br>                        if (!isMultiTouch) {<br>                            point_\\new_x = event.getX();<br>                            point_new_y = event.getY();<br>                            matrix.postTranslate((point_new_x - point_old_x),<br>                                    (point_new_y - point_old_y));<br>                            point_old_x = point_new_x;<br>                            point_old_y = point_new_y;<br>                            invalidate();<br>                        }<br>                    }<br>                }<br>                break;<br>        }<br>        return true;<br>    }<br>    // 缩放图片方法<br>    private void pinch() {<br>        distance_new = (float) Math.sqrt(((point1_new_x - point2_new_x)<br>                * (point1_new_x - point2_new_x) + (point1_new_y - point2_new_y)<br>                * (point1_new_y - point2_new_y)));<br>        matrix.postScale((distance_new / distance_old),<br>                (distance_new / distance_old), this.getWidth() / 2,<br>                this.getTop() / 2);<br>        invalidate();<br>        distance_old = distance_new;<br>    }<br>    /**<br>     * 设置Bitmap<br>     *<br>     * @param bitmap<br>     <em>/<br>    public void setImage(Bitmap bitmap) {<br>        this.bitmap = bitmap;<br>        //获取控件自身起始点<br>        myLocationStart = new int[2];<br>        getLocationOnScreen(myLocationStart);<br>        //获取控件自身终止点<br>        myLocationEnd = new int[2];<br>        myLocationEnd[0] = getWidth() + myLocationStart[0];<br>        myLocationEnd[1] = getHeight() + myLocationStart[1];<br>        //计算控件自身中点<br>        myLocationMid = new int[2];<br>        myLocationMid[0] = (myLocationStart[0] + myLocationEnd[0]) / 2;<br>        myLocationMid[1] = (myLocationStart[1] + myLocationEnd[1]) / 2 - myLocationStart[1];<br>        //设置中间预览框边框色<br>        rectPaint = new Paint();<br>        rectPaint.setColor(Color.WHITE);<br>        rectPaint.setStrokeWidth(2);<br>        rectBgPaint = new Paint();<br>        rectBgPaint.setColor(getResources().getColor(R.color.photo_adjust_for_avator_bg));<br>        //计算中间预览边框位置<br>        previewEdge = new int[4];<br>        previewEdge[0] = (myLocationMid[0] - myLocationStart[0]) / 8;<br>        previewEdge[1] = myLocationEnd[0] - previewEdge[0];<br>        previewEdge[2] = myLocationMid[1] - ((previewEdge[1] - previewEdge[0]) / 2);<br>        previewEdge[3] = myLocationMid[1] + ((previewEdge[1] - previewEdge[0]) / 2);<br>        //计算Bitmap起点<br>        bitmapLocXStart = myLocationMid[0] - bitmap.getWidth() / 2;<br>        bitmapLocYStart = myLocationMid[1] - bitmap.getHeight() / 2;<br>        bitmapLocXEnd = bitmapLocXStart + bitmap.getWidth();<br>        bitmapLocYEnd = bitmapLocYStart - bitmap.getHeight();<br>        //调整Bitmap位置<br>        matrix.postTranslate(bitmapLocXStart, bitmapLocYStart);<br>        PhotoChooseForAvatorImageView.this.invalidate();<br>    }<br>    /*</em><br>     * 截图并返回Bitmap对象<br>     <em>/<br>    public Bitmap getAdjustedBitmap(Activity activity) {<br>        View view = activity.getWindow().getDecorView();<br>        view.setDrawingCacheEnabled(true);<br>        view.buildDrawingCache();<br>        bitmap = view.getDrawingCache();<br>        matrix = new Matrix();<br>        matrix.postScale((CommonSettings.AVATOR_SIZE * 1.0f) / (previewEdge[1] - previewEdge[0]), (CommonSettings.AVATOR_SIZE * 1.0f) / (previewEdge[1] - previewEdge[0]));<br>        return Bitmap.createBitmap(bitmap, previewEdge[0] - 2, previewEdge[2] + myLocationStart[1] - 2, previewEdge[1] - previewEdge[0], previewEdge[1] - previewEdge[0], matrix, false);<br>    }<br>    /*</em><br>     * 重置Bitmap（回收内存）<br>     */<br>    public void resetBitmap() {<br>        bitmap.recycle();<br>        bitmap = null;<br>    }<br>}<br>```</p>\n"},{"title":"身为程序员，你焦虑吗","date":"2019-07-02T10:56:15.000Z","_content":"2019年已经过了大半，如果要用一个词来形容今年的互联网就业形势，那会是什么呢？  \n没错，是“寒冬”！  \n去知乎上面搜索“**互联网 寒冬**”，看看这些搜索结果吧：  \n\n![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NDc1NDQwMS0yMTAxODkyNzA1LnBuZw)\n\n再来搜搜“**互联网 裁员**”：    \n\n![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NDgyNzY0My00MTM4MzQ4MzAucG5n)\n\n从2018年开始，很多互联网公司纷纷传出裁员的消息，其中不乏一些大公司，比如Oracle、京东、滴滴等等。还有我任职的天津三星研究院，也在2018年底关停了。\n看看百度搜出来的结果，光看标题就足够让人触目惊心：\n\n![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NDkxODc3NC04MjU4NDg1NTIucG5n)\n\n著名的企业家、美团网的创始人王兴说：“2018年是过去十年最差的一年，也是未来十年最好的一年”。\n如果这些内容，让你看过之后更加焦虑，真的很抱歉，但这都是客观事实……\n老实讲，在我得知我所在的公司要关停的消息时，也很想不到。总觉得这些裁员之类的事情不会发生在自己身上，但是它确确实实地发生了。\n难道我不曾焦虑过吗？并不是！\n我也曾陷入过深深的焦虑之中，那种感觉，真的很痛苦。\n但是焦虑有用吗？并没有！\n各位想一想，一味的焦虑，会让我们发生怎样的变化呢？\n可能会抱怨这个社会不公平？抱怨自己的命不好？和自己同病相怜的同事一起吐槽？疯狂地投简历，唯恐经济“断粮”？……\n这些只能让你陷入更糟糕的境地，让你体会不到事业带给你的快乐。\n前几天我在樊登读书会里面听到一本书，里面有这样一个故事，讲的是一对父母，平时要求孩子成绩要好，要做全校第一名，要去争取各种荣誉……\n但是有一天，孩子突然得了重病，这个时候的父母唯一的希望是：“孩子，你只要健健康康、快快乐乐地就好。”\n“只要健健康康、快快乐乐地就好”，那些成绩呢？排名呢？荣誉呢？……\n真正能让孩子变得健康快乐的，是成绩吗？是排名吗？是各种荣誉吗？\n那些外在的东西已经变得不重要了，最核心、最重要的东西显现了出来。\n这其实对于我们每个成年人也是一样的，我们整天奔波于家庭和公司，忙碌于挣钱养家，却往往忽视了一个更为重要的信念：**那就是什么才是真正的幸福，怎样才能得到真正的满足？**\n哈佛大学著名的幸福课讲师：泰勒•本-沙哈尔写过一本书，书名为《幸福的方法》。\n\n![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NDkwOTk0MS0xNzQ2Nzc4MjgyLnBuZw)\n\n作者在16岁的时候夺得了以色列壁球冠军。为了得到这个冠军，他经历了五年的艰苦训练。在最终夺冠后，他突然觉得很空虚，感到迷茫和恐惧。\n显然，**冠军并没有带给他想象中的幸福感。**\n这是不是和上面所说的父母的做法如出一辙？是不是和今天的一些不妥当的教育方式如出一辙？\n“等你考上大学，你就成功了”、“等你考上大学，我就放心了”……\n好像学习、升学，从来都是为了满足他人的期待……\n请问：有多少家长、老师还在给下一代灌输这样的思想；\n再请问：有多少参加高考的学生，是真真正正体会到学习的乐趣，明白学习的意义；\n再请问：有多少大学生，在大学期间是不迷茫的？\n\n![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NDkyODQ4Ny0xNDAyMDI2NzAyLnBuZw)\n\n你看，一样地放手一搜，照样一大把关于大学迷茫的搜索结果，而且居然还有人将这个话题写成了书，评分居然还是10……\n\n![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NDk0Njk2My0xNjYzMzc4MjQ3LnBuZw)\n\n看看目录，是不是感到全书都在透露着迷茫和焦虑……\n想要平稳地度过“寒冬期”，首先要做的就是不迷茫，不焦虑！\n好难啊，我被裁员、经济断粮，怎么养家，你让我不焦虑，怎么可能？\n\n![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NDk1OTQwNS0xMDQzNTQ5NTAyLnBuZw)\n\n我们来看看苹果教父乔布斯的经历：\n受禅宗与瑜伽思想的影响，乔布斯不断地练习冥想，将他的心灵和专注力不断洗涤，抵达一种空镜，从而训练自己的思考和洞察力，并日益敏锐。\n乔布斯在做重要抉择前，譬如产品的取舍。决策前，他会先闭目静坐，然后叫属下将相关产品的设计一并放到禅垫的周围，他来决定选择哪个放弃哪个。\n这样做抉择时，乔布斯用的是“直觉”。透过这些常人看起来匪夷所思的事情，乔布斯保持了高度敏锐的头脑。任何东西，他一看，就知道问题所在。那种一针见血的能力，来自于高度发达的智能。而这种智能，并不是分析性逻辑性的演算，而是极度清晰明澈的头脑中，大量信息瞬间聚合运算的结果，我们称之为“直觉”。\n正是这种由冥想带来的直觉，帮助乔布斯获取大量的灵感。\n没错！当我们在处理难题、克服阻碍、面对困境时，也可以尝试这种叫做“冥想”的方法来帮我们跨过重重艰难。\n实际上，不仅是乔布斯，还有比尔盖茨、科比……他们都是冥想的忠实粉丝。\n为什么他们都如此钟爱“冥想”呢？\n美国冥想协会定义冥想为：一种能够充分感受自己内心平静、祥和的简易形式。\n**真正的冥想可以帮助你建立良好的注意力，并把注意力集中在当下此刻，从一个更高的角度观察自己的想法和感觉，从而平静地接受现实。**\n大家都看过功夫熊猫吧？\n第一部里面，从一开始，师傅就不认可蠢笨的熊猫能够打败太郎，一直为即将被太郎血洗的村子的安危担忧和焦虑。此时，乌龟大师告诉他：\n\n> Yesterday is history.Tomorrow is a mystery.But today is a gift.That is why it’s called the present (the gift).\n\n意思是：过去的,已经过去了，未来的,还未可知。现在,却是上苍的礼赠，那就是为什么称今天是“Present(现在/礼物)”。\n\n> Your mind is like this water. When it is agitated, it becomes difficult to see, but if you allow it to settle, the answer becomes clear.\n\n意思是：心如此水，乱则不明。但若心如止水，答案便尽现眼前。\n\n**如何才能在焦虑面前做到专注当下、心如止水呢？**\n答案是——冥想。\n冥想让心静下来，倾听内在灵魂的声音。哈佛研究指出，每天进行冥想将大大有助于您内心的平静，缓解工作生活中的压力和焦虑，改善抑郁和失眠，减轻慢性疾病所带来的疼痛。\n\n**如何科学地进行冥想呢？**\n先选择一个舒服的地方坐下来，你可以坐在家里的沙发上，或是办公室的椅子上。接下来，慢慢地闭上眼睛，把注意力尝试放在自己的呼吸上。就这样，安静地坐3分钟。\n三分钟过后，感觉怎么样？\n是不是脑袋里总有想法冒出来？\n工作报告怎么写，今天晚饭吃什么，车子又要加油了。哦，对了，昨天部门里的赵老弟还让我帮他处理点事情……\n是不是觉得自己比总统还忙……\n我们经常被这些东西挡住视线，以至于忽略了比它们更重要的东西。前文中的考生家长如此，失业时的焦虑亦会如此。\n在收拾行囊上路前，我们首先要做的，就是拨开这些“迷雾”，不要被一片树叶挡住眼睛，而忽视了后面的高山。\n有些时候，当我们陷入思维的迷宫，很难自己走出来。就好像陷入沼泽地的猛兽，虽然力气很大，但最终无法自救（想想著名的软件管理类书籍《人月神话》中的“焦油坑”，如果盲目地增加人手，对软件项目而言，反而起到负面的作用）。\n这个时候，就要求我们做一个“**静观者**”，以一个旁观者的心态去看我们正在经历的事情。\n正所谓“当局者迷，旁观者清”，说的是一样的道理。\n当我们进入冥想的状态，即真正的无思虑的状态时，慢慢地，一切都会变得清澈可见，答案也会慢慢地浮出水面。\n苏格拉底说：**要认识你自己**。\n但事实上，很少有人真正的了解自己。\n冥想可以让我们专注，从纷乱的世界中抽离出来，从而更多地关注自己，听见并看见自己的内心，重新发现自己人生的方向。进而帮我们想清楚一些平时完全没有头绪的事情，做出在日后觉得，这是正确的事的决定。\n要做到这一点并不难，每天清晨和临睡前各冥想10分钟，就可以有效地改善自己的注意力，缓解压力，舒缓心情。\n坚持冥想一段时间后，你还会发现更多的有利变化，比如：\n在工作时，更专注，更有效率；睡眠质量改善，每天精神倍增；坏情绪、负面力量几乎无法再来伤害你……\n当然，正如前文所说，在一开始的时候，脑子里会有各种想法冒出来。\n要知道，我们最终要达到的效果是：“完全放空”，只有这样，称得上是真正的冥想；只有这样，冥想才能真正帮到我们。\n\n**怎样达到这样的效果呢？**\n要牢记的一点是：**不要强迫你的想法离开，更不要用另一个念头来压制这个念头。**\n当想法来的时候，我们只需静观它，不要对它起反应。当我们能站在更高的位置去审视它的时候，会发现这些想法是多么渺小，多么不值一提。慢慢地，它自己就会从我们的脑子里消失了。\n\n ![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NTAxNTExNC0xNjczNDE4ODA3LnBuZw)\n\n怎么样？要不要去试试？\n欢迎留言，写下你的冥想感受，前三位留言的朋友还会获得下一场GitChat的免费入场券。\n赶快行动吧！","source":"_posts/身为程序员，你焦虑吗.md","raw":"---\ntitle: 身为程序员，你焦虑吗\ndate: 2019-07-02 18:56:15\ntags: 人生杂谈\ncategories: 聊聊人生\n---\n2019年已经过了大半，如果要用一个词来形容今年的互联网就业形势，那会是什么呢？  \n没错，是“寒冬”！  \n去知乎上面搜索“**互联网 寒冬**”，看看这些搜索结果吧：  \n\n![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NDc1NDQwMS0yMTAxODkyNzA1LnBuZw)\n\n再来搜搜“**互联网 裁员**”：    \n\n![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NDgyNzY0My00MTM4MzQ4MzAucG5n)\n\n从2018年开始，很多互联网公司纷纷传出裁员的消息，其中不乏一些大公司，比如Oracle、京东、滴滴等等。还有我任职的天津三星研究院，也在2018年底关停了。\n看看百度搜出来的结果，光看标题就足够让人触目惊心：\n\n![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NDkxODc3NC04MjU4NDg1NTIucG5n)\n\n著名的企业家、美团网的创始人王兴说：“2018年是过去十年最差的一年，也是未来十年最好的一年”。\n如果这些内容，让你看过之后更加焦虑，真的很抱歉，但这都是客观事实……\n老实讲，在我得知我所在的公司要关停的消息时，也很想不到。总觉得这些裁员之类的事情不会发生在自己身上，但是它确确实实地发生了。\n难道我不曾焦虑过吗？并不是！\n我也曾陷入过深深的焦虑之中，那种感觉，真的很痛苦。\n但是焦虑有用吗？并没有！\n各位想一想，一味的焦虑，会让我们发生怎样的变化呢？\n可能会抱怨这个社会不公平？抱怨自己的命不好？和自己同病相怜的同事一起吐槽？疯狂地投简历，唯恐经济“断粮”？……\n这些只能让你陷入更糟糕的境地，让你体会不到事业带给你的快乐。\n前几天我在樊登读书会里面听到一本书，里面有这样一个故事，讲的是一对父母，平时要求孩子成绩要好，要做全校第一名，要去争取各种荣誉……\n但是有一天，孩子突然得了重病，这个时候的父母唯一的希望是：“孩子，你只要健健康康、快快乐乐地就好。”\n“只要健健康康、快快乐乐地就好”，那些成绩呢？排名呢？荣誉呢？……\n真正能让孩子变得健康快乐的，是成绩吗？是排名吗？是各种荣誉吗？\n那些外在的东西已经变得不重要了，最核心、最重要的东西显现了出来。\n这其实对于我们每个成年人也是一样的，我们整天奔波于家庭和公司，忙碌于挣钱养家，却往往忽视了一个更为重要的信念：**那就是什么才是真正的幸福，怎样才能得到真正的满足？**\n哈佛大学著名的幸福课讲师：泰勒•本-沙哈尔写过一本书，书名为《幸福的方法》。\n\n![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NDkwOTk0MS0xNzQ2Nzc4MjgyLnBuZw)\n\n作者在16岁的时候夺得了以色列壁球冠军。为了得到这个冠军，他经历了五年的艰苦训练。在最终夺冠后，他突然觉得很空虚，感到迷茫和恐惧。\n显然，**冠军并没有带给他想象中的幸福感。**\n这是不是和上面所说的父母的做法如出一辙？是不是和今天的一些不妥当的教育方式如出一辙？\n“等你考上大学，你就成功了”、“等你考上大学，我就放心了”……\n好像学习、升学，从来都是为了满足他人的期待……\n请问：有多少家长、老师还在给下一代灌输这样的思想；\n再请问：有多少参加高考的学生，是真真正正体会到学习的乐趣，明白学习的意义；\n再请问：有多少大学生，在大学期间是不迷茫的？\n\n![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NDkyODQ4Ny0xNDAyMDI2NzAyLnBuZw)\n\n你看，一样地放手一搜，照样一大把关于大学迷茫的搜索结果，而且居然还有人将这个话题写成了书，评分居然还是10……\n\n![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NDk0Njk2My0xNjYzMzc4MjQ3LnBuZw)\n\n看看目录，是不是感到全书都在透露着迷茫和焦虑……\n想要平稳地度过“寒冬期”，首先要做的就是不迷茫，不焦虑！\n好难啊，我被裁员、经济断粮，怎么养家，你让我不焦虑，怎么可能？\n\n![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NDk1OTQwNS0xMDQzNTQ5NTAyLnBuZw)\n\n我们来看看苹果教父乔布斯的经历：\n受禅宗与瑜伽思想的影响，乔布斯不断地练习冥想，将他的心灵和专注力不断洗涤，抵达一种空镜，从而训练自己的思考和洞察力，并日益敏锐。\n乔布斯在做重要抉择前，譬如产品的取舍。决策前，他会先闭目静坐，然后叫属下将相关产品的设计一并放到禅垫的周围，他来决定选择哪个放弃哪个。\n这样做抉择时，乔布斯用的是“直觉”。透过这些常人看起来匪夷所思的事情，乔布斯保持了高度敏锐的头脑。任何东西，他一看，就知道问题所在。那种一针见血的能力，来自于高度发达的智能。而这种智能，并不是分析性逻辑性的演算，而是极度清晰明澈的头脑中，大量信息瞬间聚合运算的结果，我们称之为“直觉”。\n正是这种由冥想带来的直觉，帮助乔布斯获取大量的灵感。\n没错！当我们在处理难题、克服阻碍、面对困境时，也可以尝试这种叫做“冥想”的方法来帮我们跨过重重艰难。\n实际上，不仅是乔布斯，还有比尔盖茨、科比……他们都是冥想的忠实粉丝。\n为什么他们都如此钟爱“冥想”呢？\n美国冥想协会定义冥想为：一种能够充分感受自己内心平静、祥和的简易形式。\n**真正的冥想可以帮助你建立良好的注意力，并把注意力集中在当下此刻，从一个更高的角度观察自己的想法和感觉，从而平静地接受现实。**\n大家都看过功夫熊猫吧？\n第一部里面，从一开始，师傅就不认可蠢笨的熊猫能够打败太郎，一直为即将被太郎血洗的村子的安危担忧和焦虑。此时，乌龟大师告诉他：\n\n> Yesterday is history.Tomorrow is a mystery.But today is a gift.That is why it’s called the present (the gift).\n\n意思是：过去的,已经过去了，未来的,还未可知。现在,却是上苍的礼赠，那就是为什么称今天是“Present(现在/礼物)”。\n\n> Your mind is like this water. When it is agitated, it becomes difficult to see, but if you allow it to settle, the answer becomes clear.\n\n意思是：心如此水，乱则不明。但若心如止水，答案便尽现眼前。\n\n**如何才能在焦虑面前做到专注当下、心如止水呢？**\n答案是——冥想。\n冥想让心静下来，倾听内在灵魂的声音。哈佛研究指出，每天进行冥想将大大有助于您内心的平静，缓解工作生活中的压力和焦虑，改善抑郁和失眠，减轻慢性疾病所带来的疼痛。\n\n**如何科学地进行冥想呢？**\n先选择一个舒服的地方坐下来，你可以坐在家里的沙发上，或是办公室的椅子上。接下来，慢慢地闭上眼睛，把注意力尝试放在自己的呼吸上。就这样，安静地坐3分钟。\n三分钟过后，感觉怎么样？\n是不是脑袋里总有想法冒出来？\n工作报告怎么写，今天晚饭吃什么，车子又要加油了。哦，对了，昨天部门里的赵老弟还让我帮他处理点事情……\n是不是觉得自己比总统还忙……\n我们经常被这些东西挡住视线，以至于忽略了比它们更重要的东西。前文中的考生家长如此，失业时的焦虑亦会如此。\n在收拾行囊上路前，我们首先要做的，就是拨开这些“迷雾”，不要被一片树叶挡住眼睛，而忽视了后面的高山。\n有些时候，当我们陷入思维的迷宫，很难自己走出来。就好像陷入沼泽地的猛兽，虽然力气很大，但最终无法自救（想想著名的软件管理类书籍《人月神话》中的“焦油坑”，如果盲目地增加人手，对软件项目而言，反而起到负面的作用）。\n这个时候，就要求我们做一个“**静观者**”，以一个旁观者的心态去看我们正在经历的事情。\n正所谓“当局者迷，旁观者清”，说的是一样的道理。\n当我们进入冥想的状态，即真正的无思虑的状态时，慢慢地，一切都会变得清澈可见，答案也会慢慢地浮出水面。\n苏格拉底说：**要认识你自己**。\n但事实上，很少有人真正的了解自己。\n冥想可以让我们专注，从纷乱的世界中抽离出来，从而更多地关注自己，听见并看见自己的内心，重新发现自己人生的方向。进而帮我们想清楚一些平时完全没有头绪的事情，做出在日后觉得，这是正确的事的决定。\n要做到这一点并不难，每天清晨和临睡前各冥想10分钟，就可以有效地改善自己的注意力，缓解压力，舒缓心情。\n坚持冥想一段时间后，你还会发现更多的有利变化，比如：\n在工作时，更专注，更有效率；睡眠质量改善，每天精神倍增；坏情绪、负面力量几乎无法再来伤害你……\n当然，正如前文所说，在一开始的时候，脑子里会有各种想法冒出来。\n要知道，我们最终要达到的效果是：“完全放空”，只有这样，称得上是真正的冥想；只有这样，冥想才能真正帮到我们。\n\n**怎样达到这样的效果呢？**\n要牢记的一点是：**不要强迫你的想法离开，更不要用另一个念头来压制这个念头。**\n当想法来的时候，我们只需静观它，不要对它起反应。当我们能站在更高的位置去审视它的时候，会发现这些想法是多么渺小，多么不值一提。慢慢地，它自己就会从我们的脑子里消失了。\n\n ![image.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NTAxNTExNC0xNjczNDE4ODA3LnBuZw)\n\n怎么样？要不要去试试？\n欢迎留言，写下你的冥想感受，前三位留言的朋友还会获得下一场GitChat的免费入场券。\n赶快行动吧！","slug":"身为程序员，你焦虑吗","published":1,"updated":"2019-07-31T04:12:25.767Z","_id":"cjyqq3tkv0025fkqdqi9zqbf7","comments":1,"layout":"post","photos":[],"link":"","content":"<p>2019年已经过了大半，如果要用一个词来形容今年的互联网就业形势，那会是什么呢？<br>没错，是“寒冬”！<br>去知乎上面搜索“<strong>互联网 寒冬</strong>”，看看这些搜索结果吧：  </p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NDc1NDQwMS0yMTAxODkyNzA1LnBuZw\" alt=\"image.png\"></p>\n<p>再来搜搜“<strong>互联网 裁员</strong>”：    </p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NDgyNzY0My00MTM4MzQ4MzAucG5n\" alt=\"image.png\"></p>\n<p>从2018年开始，很多互联网公司纷纷传出裁员的消息，其中不乏一些大公司，比如Oracle、京东、滴滴等等。还有我任职的天津三星研究院，也在2018年底关停了。<br>看看百度搜出来的结果，光看标题就足够让人触目惊心：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NDkxODc3NC04MjU4NDg1NTIucG5n\" alt=\"image.png\"></p>\n<p>著名的企业家、美团网的创始人王兴说：“2018年是过去十年最差的一年，也是未来十年最好的一年”。<br>如果这些内容，让你看过之后更加焦虑，真的很抱歉，但这都是客观事实……<br>老实讲，在我得知我所在的公司要关停的消息时，也很想不到。总觉得这些裁员之类的事情不会发生在自己身上，但是它确确实实地发生了。<br>难道我不曾焦虑过吗？并不是！<br>我也曾陷入过深深的焦虑之中，那种感觉，真的很痛苦。<br>但是焦虑有用吗？并没有！<br>各位想一想，一味的焦虑，会让我们发生怎样的变化呢？<br>可能会抱怨这个社会不公平？抱怨自己的命不好？和自己同病相怜的同事一起吐槽？疯狂地投简历，唯恐经济“断粮”？……<br>这些只能让你陷入更糟糕的境地，让你体会不到事业带给你的快乐。<br>前几天我在樊登读书会里面听到一本书，里面有这样一个故事，讲的是一对父母，平时要求孩子成绩要好，要做全校第一名，要去争取各种荣誉……<br>但是有一天，孩子突然得了重病，这个时候的父母唯一的希望是：“孩子，你只要健健康康、快快乐乐地就好。”<br>“只要健健康康、快快乐乐地就好”，那些成绩呢？排名呢？荣誉呢？……<br>真正能让孩子变得健康快乐的，是成绩吗？是排名吗？是各种荣誉吗？<br>那些外在的东西已经变得不重要了，最核心、最重要的东西显现了出来。<br>这其实对于我们每个成年人也是一样的，我们整天奔波于家庭和公司，忙碌于挣钱养家，却往往忽视了一个更为重要的信念：<strong>那就是什么才是真正的幸福，怎样才能得到真正的满足？</strong><br>哈佛大学著名的幸福课讲师：泰勒•本-沙哈尔写过一本书，书名为《幸福的方法》。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NDkwOTk0MS0xNzQ2Nzc4MjgyLnBuZw\" alt=\"image.png\"></p>\n<p>作者在16岁的时候夺得了以色列壁球冠军。为了得到这个冠军，他经历了五年的艰苦训练。在最终夺冠后，他突然觉得很空虚，感到迷茫和恐惧。<br>显然，<strong>冠军并没有带给他想象中的幸福感。</strong><br>这是不是和上面所说的父母的做法如出一辙？是不是和今天的一些不妥当的教育方式如出一辙？<br>“等你考上大学，你就成功了”、“等你考上大学，我就放心了”……<br>好像学习、升学，从来都是为了满足他人的期待……<br>请问：有多少家长、老师还在给下一代灌输这样的思想；<br>再请问：有多少参加高考的学生，是真真正正体会到学习的乐趣，明白学习的意义；<br>再请问：有多少大学生，在大学期间是不迷茫的？</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NDkyODQ4Ny0xNDAyMDI2NzAyLnBuZw\" alt=\"image.png\"></p>\n<p>你看，一样地放手一搜，照样一大把关于大学迷茫的搜索结果，而且居然还有人将这个话题写成了书，评分居然还是10……</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NDk0Njk2My0xNjYzMzc4MjQ3LnBuZw\" alt=\"image.png\"></p>\n<p>看看目录，是不是感到全书都在透露着迷茫和焦虑……<br>想要平稳地度过“寒冬期”，首先要做的就是不迷茫，不焦虑！<br>好难啊，我被裁员、经济断粮，怎么养家，你让我不焦虑，怎么可能？</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NDk1OTQwNS0xMDQzNTQ5NTAyLnBuZw\" alt=\"image.png\"></p>\n<p>我们来看看苹果教父乔布斯的经历：<br>受禅宗与瑜伽思想的影响，乔布斯不断地练习冥想，将他的心灵和专注力不断洗涤，抵达一种空镜，从而训练自己的思考和洞察力，并日益敏锐。<br>乔布斯在做重要抉择前，譬如产品的取舍。决策前，他会先闭目静坐，然后叫属下将相关产品的设计一并放到禅垫的周围，他来决定选择哪个放弃哪个。<br>这样做抉择时，乔布斯用的是“直觉”。透过这些常人看起来匪夷所思的事情，乔布斯保持了高度敏锐的头脑。任何东西，他一看，就知道问题所在。那种一针见血的能力，来自于高度发达的智能。而这种智能，并不是分析性逻辑性的演算，而是极度清晰明澈的头脑中，大量信息瞬间聚合运算的结果，我们称之为“直觉”。<br>正是这种由冥想带来的直觉，帮助乔布斯获取大量的灵感。<br>没错！当我们在处理难题、克服阻碍、面对困境时，也可以尝试这种叫做“冥想”的方法来帮我们跨过重重艰难。<br>实际上，不仅是乔布斯，还有比尔盖茨、科比……他们都是冥想的忠实粉丝。<br>为什么他们都如此钟爱“冥想”呢？<br>美国冥想协会定义冥想为：一种能够充分感受自己内心平静、祥和的简易形式。<br><strong>真正的冥想可以帮助你建立良好的注意力，并把注意力集中在当下此刻，从一个更高的角度观察自己的想法和感觉，从而平静地接受现实。</strong><br>大家都看过功夫熊猫吧？<br>第一部里面，从一开始，师傅就不认可蠢笨的熊猫能够打败太郎，一直为即将被太郎血洗的村子的安危担忧和焦虑。此时，乌龟大师告诉他：</p>\n<blockquote>\n<p>Yesterday is history.Tomorrow is a mystery.But today is a gift.That is why it’s called the present (the gift).</p>\n</blockquote>\n<p>意思是：过去的,已经过去了，未来的,还未可知。现在,却是上苍的礼赠，那就是为什么称今天是“Present(现在/礼物)”。</p>\n<blockquote>\n<p>Your mind is like this water. When it is agitated, it becomes difficult to see, but if you allow it to settle, the answer becomes clear.</p>\n</blockquote>\n<p>意思是：心如此水，乱则不明。但若心如止水，答案便尽现眼前。</p>\n<p><strong>如何才能在焦虑面前做到专注当下、心如止水呢？</strong><br>答案是——冥想。<br>冥想让心静下来，倾听内在灵魂的声音。哈佛研究指出，每天进行冥想将大大有助于您内心的平静，缓解工作生活中的压力和焦虑，改善抑郁和失眠，减轻慢性疾病所带来的疼痛。</p>\n<p><strong>如何科学地进行冥想呢？</strong><br>先选择一个舒服的地方坐下来，你可以坐在家里的沙发上，或是办公室的椅子上。接下来，慢慢地闭上眼睛，把注意力尝试放在自己的呼吸上。就这样，安静地坐3分钟。<br>三分钟过后，感觉怎么样？<br>是不是脑袋里总有想法冒出来？<br>工作报告怎么写，今天晚饭吃什么，车子又要加油了。哦，对了，昨天部门里的赵老弟还让我帮他处理点事情……<br>是不是觉得自己比总统还忙……<br>我们经常被这些东西挡住视线，以至于忽略了比它们更重要的东西。前文中的考生家长如此，失业时的焦虑亦会如此。<br>在收拾行囊上路前，我们首先要做的，就是拨开这些“迷雾”，不要被一片树叶挡住眼睛，而忽视了后面的高山。<br>有些时候，当我们陷入思维的迷宫，很难自己走出来。就好像陷入沼泽地的猛兽，虽然力气很大，但最终无法自救（想想著名的软件管理类书籍《人月神话》中的“焦油坑”，如果盲目地增加人手，对软件项目而言，反而起到负面的作用）。<br>这个时候，就要求我们做一个“<strong>静观者</strong>”，以一个旁观者的心态去看我们正在经历的事情。<br>正所谓“当局者迷，旁观者清”，说的是一样的道理。<br>当我们进入冥想的状态，即真正的无思虑的状态时，慢慢地，一切都会变得清澈可见，答案也会慢慢地浮出水面。<br>苏格拉底说：<strong>要认识你自己</strong>。<br>但事实上，很少有人真正的了解自己。<br>冥想可以让我们专注，从纷乱的世界中抽离出来，从而更多地关注自己，听见并看见自己的内心，重新发现自己人生的方向。进而帮我们想清楚一些平时完全没有头绪的事情，做出在日后觉得，这是正确的事的决定。<br>要做到这一点并不难，每天清晨和临睡前各冥想10分钟，就可以有效地改善自己的注意力，缓解压力，舒缓心情。<br>坚持冥想一段时间后，你还会发现更多的有利变化，比如：<br>在工作时，更专注，更有效率；睡眠质量改善，每天精神倍增；坏情绪、负面力量几乎无法再来伤害你……<br>当然，正如前文所说，在一开始的时候，脑子里会有各种想法冒出来。<br>要知道，我们最终要达到的效果是：“完全放空”，只有这样，称得上是真正的冥想；只有这样，冥想才能真正帮到我们。</p>\n<p><strong>怎样达到这样的效果呢？</strong><br>要牢记的一点是：<strong>不要强迫你的想法离开，更不要用另一个念头来压制这个念头。</strong><br>当想法来的时候，我们只需静观它，不要对它起反应。当我们能站在更高的位置去审视它的时候，会发现这些想法是多么渺小，多么不值一提。慢慢地，它自己就会从我们的脑子里消失了。</p>\n<p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NTAxNTExNC0xNjczNDE4ODA3LnBuZw\" alt=\"image.png\"></p>\n<p>怎么样？要不要去试试？<br>欢迎留言，写下你的冥想感受，前三位留言的朋友还会获得下一场GitChat的免费入场券。<br>赶快行动吧！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>2019年已经过了大半，如果要用一个词来形容今年的互联网就业形势，那会是什么呢？<br>没错，是“寒冬”！<br>去知乎上面搜索“<strong>互联网 寒冬</strong>”，看看这些搜索结果吧：  </p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NDc1NDQwMS0yMTAxODkyNzA1LnBuZw\" alt=\"image.png\"></p>\n<p>再来搜搜“<strong>互联网 裁员</strong>”：    </p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NDgyNzY0My00MTM4MzQ4MzAucG5n\" alt=\"image.png\"></p>\n<p>从2018年开始，很多互联网公司纷纷传出裁员的消息，其中不乏一些大公司，比如Oracle、京东、滴滴等等。还有我任职的天津三星研究院，也在2018年底关停了。<br>看看百度搜出来的结果，光看标题就足够让人触目惊心：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NDkxODc3NC04MjU4NDg1NTIucG5n\" alt=\"image.png\"></p>\n<p>著名的企业家、美团网的创始人王兴说：“2018年是过去十年最差的一年，也是未来十年最好的一年”。<br>如果这些内容，让你看过之后更加焦虑，真的很抱歉，但这都是客观事实……<br>老实讲，在我得知我所在的公司要关停的消息时，也很想不到。总觉得这些裁员之类的事情不会发生在自己身上，但是它确确实实地发生了。<br>难道我不曾焦虑过吗？并不是！<br>我也曾陷入过深深的焦虑之中，那种感觉，真的很痛苦。<br>但是焦虑有用吗？并没有！<br>各位想一想，一味的焦虑，会让我们发生怎样的变化呢？<br>可能会抱怨这个社会不公平？抱怨自己的命不好？和自己同病相怜的同事一起吐槽？疯狂地投简历，唯恐经济“断粮”？……<br>这些只能让你陷入更糟糕的境地，让你体会不到事业带给你的快乐。<br>前几天我在樊登读书会里面听到一本书，里面有这样一个故事，讲的是一对父母，平时要求孩子成绩要好，要做全校第一名，要去争取各种荣誉……<br>但是有一天，孩子突然得了重病，这个时候的父母唯一的希望是：“孩子，你只要健健康康、快快乐乐地就好。”<br>“只要健健康康、快快乐乐地就好”，那些成绩呢？排名呢？荣誉呢？……<br>真正能让孩子变得健康快乐的，是成绩吗？是排名吗？是各种荣誉吗？<br>那些外在的东西已经变得不重要了，最核心、最重要的东西显现了出来。<br>这其实对于我们每个成年人也是一样的，我们整天奔波于家庭和公司，忙碌于挣钱养家，却往往忽视了一个更为重要的信念：<strong>那就是什么才是真正的幸福，怎样才能得到真正的满足？</strong><br>哈佛大学著名的幸福课讲师：泰勒•本-沙哈尔写过一本书，书名为《幸福的方法》。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NDkwOTk0MS0xNzQ2Nzc4MjgyLnBuZw\" alt=\"image.png\"></p>\n<p>作者在16岁的时候夺得了以色列壁球冠军。为了得到这个冠军，他经历了五年的艰苦训练。在最终夺冠后，他突然觉得很空虚，感到迷茫和恐惧。<br>显然，<strong>冠军并没有带给他想象中的幸福感。</strong><br>这是不是和上面所说的父母的做法如出一辙？是不是和今天的一些不妥当的教育方式如出一辙？<br>“等你考上大学，你就成功了”、“等你考上大学，我就放心了”……<br>好像学习、升学，从来都是为了满足他人的期待……<br>请问：有多少家长、老师还在给下一代灌输这样的思想；<br>再请问：有多少参加高考的学生，是真真正正体会到学习的乐趣，明白学习的意义；<br>再请问：有多少大学生，在大学期间是不迷茫的？</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NDkyODQ4Ny0xNDAyMDI2NzAyLnBuZw\" alt=\"image.png\"></p>\n<p>你看，一样地放手一搜，照样一大把关于大学迷茫的搜索结果，而且居然还有人将这个话题写成了书，评分居然还是10……</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NDk0Njk2My0xNjYzMzc4MjQ3LnBuZw\" alt=\"image.png\"></p>\n<p>看看目录，是不是感到全书都在透露着迷茫和焦虑……<br>想要平稳地度过“寒冬期”，首先要做的就是不迷茫，不焦虑！<br>好难啊，我被裁员、经济断粮，怎么养家，你让我不焦虑，怎么可能？</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NDk1OTQwNS0xMDQzNTQ5NTAyLnBuZw\" alt=\"image.png\"></p>\n<p>我们来看看苹果教父乔布斯的经历：<br>受禅宗与瑜伽思想的影响，乔布斯不断地练习冥想，将他的心灵和专注力不断洗涤，抵达一种空镜，从而训练自己的思考和洞察力，并日益敏锐。<br>乔布斯在做重要抉择前，譬如产品的取舍。决策前，他会先闭目静坐，然后叫属下将相关产品的设计一并放到禅垫的周围，他来决定选择哪个放弃哪个。<br>这样做抉择时，乔布斯用的是“直觉”。透过这些常人看起来匪夷所思的事情，乔布斯保持了高度敏锐的头脑。任何东西，他一看，就知道问题所在。那种一针见血的能力，来自于高度发达的智能。而这种智能，并不是分析性逻辑性的演算，而是极度清晰明澈的头脑中，大量信息瞬间聚合运算的结果，我们称之为“直觉”。<br>正是这种由冥想带来的直觉，帮助乔布斯获取大量的灵感。<br>没错！当我们在处理难题、克服阻碍、面对困境时，也可以尝试这种叫做“冥想”的方法来帮我们跨过重重艰难。<br>实际上，不仅是乔布斯，还有比尔盖茨、科比……他们都是冥想的忠实粉丝。<br>为什么他们都如此钟爱“冥想”呢？<br>美国冥想协会定义冥想为：一种能够充分感受自己内心平静、祥和的简易形式。<br><strong>真正的冥想可以帮助你建立良好的注意力，并把注意力集中在当下此刻，从一个更高的角度观察自己的想法和感觉，从而平静地接受现实。</strong><br>大家都看过功夫熊猫吧？<br>第一部里面，从一开始，师傅就不认可蠢笨的熊猫能够打败太郎，一直为即将被太郎血洗的村子的安危担忧和焦虑。此时，乌龟大师告诉他：</p>\n<blockquote>\n<p>Yesterday is history.Tomorrow is a mystery.But today is a gift.That is why it’s called the present (the gift).</p>\n</blockquote>\n<p>意思是：过去的,已经过去了，未来的,还未可知。现在,却是上苍的礼赠，那就是为什么称今天是“Present(现在/礼物)”。</p>\n<blockquote>\n<p>Your mind is like this water. When it is agitated, it becomes difficult to see, but if you allow it to settle, the answer becomes clear.</p>\n</blockquote>\n<p>意思是：心如此水，乱则不明。但若心如止水，答案便尽现眼前。</p>\n<p><strong>如何才能在焦虑面前做到专注当下、心如止水呢？</strong><br>答案是——冥想。<br>冥想让心静下来，倾听内在灵魂的声音。哈佛研究指出，每天进行冥想将大大有助于您内心的平静，缓解工作生活中的压力和焦虑，改善抑郁和失眠，减轻慢性疾病所带来的疼痛。</p>\n<p><strong>如何科学地进行冥想呢？</strong><br>先选择一个舒服的地方坐下来，你可以坐在家里的沙发上，或是办公室的椅子上。接下来，慢慢地闭上眼睛，把注意力尝试放在自己的呼吸上。就这样，安静地坐3分钟。<br>三分钟过后，感觉怎么样？<br>是不是脑袋里总有想法冒出来？<br>工作报告怎么写，今天晚饭吃什么，车子又要加油了。哦，对了，昨天部门里的赵老弟还让我帮他处理点事情……<br>是不是觉得自己比总统还忙……<br>我们经常被这些东西挡住视线，以至于忽略了比它们更重要的东西。前文中的考生家长如此，失业时的焦虑亦会如此。<br>在收拾行囊上路前，我们首先要做的，就是拨开这些“迷雾”，不要被一片树叶挡住眼睛，而忽视了后面的高山。<br>有些时候，当我们陷入思维的迷宫，很难自己走出来。就好像陷入沼泽地的猛兽，虽然力气很大，但最终无法自救（想想著名的软件管理类书籍《人月神话》中的“焦油坑”，如果盲目地增加人手，对软件项目而言，反而起到负面的作用）。<br>这个时候，就要求我们做一个“<strong>静观者</strong>”，以一个旁观者的心态去看我们正在经历的事情。<br>正所谓“当局者迷，旁观者清”，说的是一样的道理。<br>当我们进入冥想的状态，即真正的无思虑的状态时，慢慢地，一切都会变得清澈可见，答案也会慢慢地浮出水面。<br>苏格拉底说：<strong>要认识你自己</strong>。<br>但事实上，很少有人真正的了解自己。<br>冥想可以让我们专注，从纷乱的世界中抽离出来，从而更多地关注自己，听见并看见自己的内心，重新发现自己人生的方向。进而帮我们想清楚一些平时完全没有头绪的事情，做出在日后觉得，这是正确的事的决定。<br>要做到这一点并不难，每天清晨和临睡前各冥想10分钟，就可以有效地改善自己的注意力，缓解压力，舒缓心情。<br>坚持冥想一段时间后，你还会发现更多的有利变化，比如：<br>在工作时，更专注，更有效率；睡眠质量改善，每天精神倍增；坏情绪、负面力量几乎无法再来伤害你……<br>当然，正如前文所说，在一开始的时候，脑子里会有各种想法冒出来。<br>要知道，我们最终要达到的效果是：“完全放空”，只有这样，称得上是真正的冥想；只有这样，冥想才能真正帮到我们。</p>\n<p><strong>怎样达到这样的效果呢？</strong><br>要牢记的一点是：<strong>不要强迫你的想法离开，更不要用另一个念头来压制这个念头。</strong><br>当想法来的时候，我们只需静观它，不要对它起反应。当我们能站在更高的位置去审视它的时候，会发现这些想法是多么渺小，多么不值一提。慢慢地，它自己就会从我们的脑子里消失了。</p>\n<p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTU5NTkyMi8yMDE5MDcvMTU5NTkyMi0yMDE5MDcyMjE4NTAxNTExNC0xNjczNDE4ODA3LnBuZw\" alt=\"image.png\"></p>\n<p>怎么样？要不要去试试？<br>欢迎留言，写下你的冥想感受，前三位留言的朋友还会获得下一场GitChat的免费入场券。<br>赶快行动吧！</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjyqq3tj10002fkqdjkyoawrm","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqefu8000avkqdkxchv9kd"},{"post_id":"cjyqq3tj40004fkqdfds3xb8m","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqexft000bvkqdz5y6fgkb"},{"post_id":"cjyqq3tj60005fkqd5ygslsmk","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqf10r000cvkqdww48bkwy"},{"post_id":"cjyqq3tko0020fkqdydwxf32w","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqf1u2000dvkqdf9szf5aq"},{"post_id":"cjyqq3tjm000nfkqdxf2im5r3","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqg5rr000evkqdfdmkr672"},{"post_id":"cjyqq3tjq000ufkqdjetqu3bh","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqgawr000fvkqdw0ykr81g"},{"post_id":"cjyqq3tjv0011fkqd9moohwge","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqgmfv000gvkqdkw8ttrez"},{"post_id":"cjyqq3tjz0015fkqdcl4wel6n","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqgvq6000hvkqdslvybo07"},{"post_id":"cjyqq3tk6001dfkqdal71ot6h","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqh2by000ivkqdolmyhhio"},{"post_id":"cjyqq3tka001kfkqdtl28s8ww","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqhc15000jvkqd7jisgn1d"},{"post_id":"cjyqq3tkd001qfkqdp2qzppw3","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqhp5w000kvkqd2iyt2agj"},{"post_id":"cjyqq3tkf001ufkqdukx219pz","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqi1dj000lvkqd2071ellm"},{"post_id":"cjyqq3tiv0000fkqd501vwtj3","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqii7y0001a0qd46jsm6rd"},{"post_id":"cjyqq3tj70006fkqdd43o6d6q","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqii810004a0qd217sst07"},{"post_id":"cjyqq3tja0009fkqdg0we9mof","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqii820006a0qdlt6fkk93"},{"post_id":"cjyqq3tjb000bfkqd1tto2sfy","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqii830008a0qdovo7or0t"},{"post_id":"cjyqq3tji000ifkqdmmfzwkev","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqii8i000ba0qdsv09692p"},{"post_id":"cjyqq3tje000efkqd22g1zsbi","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqii8l000ea0qdumu6m4ng"},{"post_id":"cjyqq3tjp000sfkqdbzl33vh3","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqii8n000ga0qd4b7e6plu"},{"post_id":"cjyqq3tjg000gfkqdnbtxg07k","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqii8o000ia0qds1r11fhh"},{"post_id":"cjyqq3tjk000lfkqdirpzt33s","category_id":"cjyqqii840009a0qdhgrd4d09","_id":"cjyqqii8p000ja0qdntarvtla"},{"post_id":"cjyqq3tk30019fkqd9lol6cgf","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqii8r000la0qd0226n77d"},{"post_id":"cjyqq3tjn000pfkqd56yjy9y6","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqii8s000ma0qdxojsnbx9"},{"post_id":"cjyqq3tjs000xfkqdpmv0lk4v","category_id":"cjyqqii840009a0qdhgrd4d09","_id":"cjyqqii8w000oa0qdo2pn7vk3"},{"post_id":"cjyqq3tk10017fkqd9vqf65r5","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqii8z000ra0qdqv39rv47"},{"post_id":"cjyqq3tjw0013fkqdq678rht9","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqii90000sa0qdg8odruem"},{"post_id":"cjyqq3tjt000zfkqd6yxf9mp2","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqii92000ua0qdk6iw5bmj"},{"post_id":"cjyqq3tk4001bfkqdu7kthr6w","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqii95000xa0qd7dpb0vef"},{"post_id":"cjyqq3tk8001ifkqd3sisrf7b","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqii97000za0qdnt4pvdv5"},{"post_id":"cjyqq3tk7001gfkqdjwcvimd0","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqii980011a0qdkh9fzvjd"},{"post_id":"cjyqq3tkb001mfkqddni17oqc","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqii990012a0qdz1eapgdn"},{"post_id":"cjyqq3tkc001ofkqdpfp66hhf","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqii9b0014a0qd5vo5tj82"},{"post_id":"cjyqq3tke001sfkqd3nglj09s","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqii9b0016a0qdbgji3t2q"},{"post_id":"cjyqq3tkr0021fkqdfvuio1y5","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqii9p0019a0qdmu55ruqg"},{"post_id":"cjyqq3tkt0023fkqdzl924y55","category_id":"cjyqqcq7p0007vkqd0ppu4nv6","_id":"cjyqqii9q001ba0qdpbd06nf6"},{"post_id":"cjyqq3tkv0025fkqdqi9zqbf7","category_id":"cjyqqii840009a0qdhgrd4d09","_id":"cjyqqii9r001ca0qdsjogl9o2"}],"PostTag":[{"post_id":"cjyqq3tj60005fkqd5ygslsmk","tag_id":"cjyqq3tj30003fkqd7iramp0e","_id":"cjyqq3tja0008fkqdpnya7z2k"},{"post_id":"cjyqq3tj10002fkqdjkyoawrm","tag_id":"cjyqq3tj30003fkqd7iramp0e","_id":"cjyqq3tji000hfkqdifzqycv7"},{"post_id":"cjyqq3tj40004fkqdfds3xb8m","tag_id":"cjyqq3tj30003fkqd7iramp0e","_id":"cjyqq3tjn000ofkqdhdsmhncp"},{"post_id":"cjyqq3tjq000ufkqdjetqu3bh","tag_id":"cjyqq3tj30003fkqd7iramp0e","_id":"cjyqq3tjw0012fkqdsgj1tweo"},{"post_id":"cjyqq3tjm000nfkqdxf2im5r3","tag_id":"cjyqq3tjr000vfkqd3pijxrpy","_id":"cjyqq3tk00016fkqdbhv5519v"},{"post_id":"cjyqq3tjv0011fkqd9moohwge","tag_id":"cjyqq3tj30003fkqd7iramp0e","_id":"cjyqq3tk4001afkqdpsmvj95v"},{"post_id":"cjyqq3tjz0015fkqdcl4wel6n","tag_id":"cjyqq3tj30003fkqd7iramp0e","_id":"cjyqq3tk7001ffkqdxnv9p003"},{"post_id":"cjyqq3tk6001dfkqdal71ot6h","tag_id":"cjyqq3tj30003fkqd7iramp0e","_id":"cjyqq3tkb001lfkqdhc625810"},{"post_id":"cjyqq3tka001kfkqdtl28s8ww","tag_id":"cjyqq3tj30003fkqd7iramp0e","_id":"cjyqq3tkf001tfkqdx0wdiw20"},{"post_id":"cjyqq3tkd001qfkqdp2qzppw3","tag_id":"cjyqq3tj30003fkqd7iramp0e","_id":"cjyqq3tkh001xfkqd392u6om2"},{"post_id":"cjyqq3tkf001ufkqdukx219pz","tag_id":"cjyqq3tjr000vfkqd3pijxrpy","_id":"cjyqq3tkh001zfkqdkhajdizs"},{"post_id":"cjyqq3tko0020fkqdydwxf32w","tag_id":"cjyqq3tj30003fkqd7iramp0e","_id":"cjyqq3tkt0022fkqdth1nyl2v"},{"post_id":"cjyqq3tiv0000fkqd501vwtj3","tag_id":"cjyqq3tj30003fkqd7iramp0e","_id":"cjyqqii7v0000a0qd61oi2oro"},{"post_id":"cjyqq3tj70006fkqdd43o6d6q","tag_id":"cjyqq3tj30003fkqd7iramp0e","_id":"cjyqqii7z0002a0qdsjpfgz6x"},{"post_id":"cjyqq3tja0009fkqdg0we9mof","tag_id":"cjyqq3tj30003fkqd7iramp0e","_id":"cjyqqii800003a0qd2qztcnje"},{"post_id":"cjyqq3tjb000bfkqd1tto2sfy","tag_id":"cjyqq3tj30003fkqd7iramp0e","_id":"cjyqqii810005a0qdrepcbjw6"},{"post_id":"cjyqq3tji000ifkqdmmfzwkev","tag_id":"cjyqq3tj30003fkqd7iramp0e","_id":"cjyqqii830007a0qd3zr5jyex"},{"post_id":"cjyqq3tjk000lfkqdirpzt33s","tag_id":"cjyqq3tjo000qfkqdbdci77if","_id":"cjyqqii8h000aa0qdrz28k29w"},{"post_id":"cjyqq3tje000efkqd22g1zsbi","tag_id":"cjyqq3tj30003fkqd7iramp0e","_id":"cjyqqii8j000ca0qd036jfp9n"},{"post_id":"cjyqq3tjp000sfkqdbzl33vh3","tag_id":"cjyqq3tjj000jfkqd8gzhe5uk","_id":"cjyqqii8k000da0qdme4t8ohg"},{"post_id":"cjyqq3tjg000gfkqdnbtxg07k","tag_id":"cjyqq3tjj000jfkqd8gzhe5uk","_id":"cjyqqii8m000fa0qd3eo0o208"},{"post_id":"cjyqq3tk30019fkqd9lol6cgf","tag_id":"cjyqq3tj30003fkqd7iramp0e","_id":"cjyqqii8n000ha0qdf3o6lgkl"},{"post_id":"cjyqq3tjn000pfkqd56yjy9y6","tag_id":"cjyqq3tj30003fkqd7iramp0e","_id":"cjyqqii8q000ka0qdx6ln1rno"},{"post_id":"cjyqq3tjs000xfkqdpmv0lk4v","tag_id":"cjyqq3tjo000qfkqdbdci77if","_id":"cjyqqii8t000na0qdtk68n8lh"},{"post_id":"cjyqq3tk10017fkqd9vqf65r5","tag_id":"cjyqq3tj30003fkqd7iramp0e","_id":"cjyqqii8w000pa0qd5k2we8ba"},{"post_id":"cjyqq3tjw0013fkqdq678rht9","tag_id":"cjyqq3tj30003fkqd7iramp0e","_id":"cjyqqii8y000qa0qd16r5eq1o"},{"post_id":"cjyqq3tjt000zfkqd6yxf9mp2","tag_id":"cjyqq3tj30003fkqd7iramp0e","_id":"cjyqqii90000ta0qdqtdadyqx"},{"post_id":"cjyqq3tk4001bfkqdu7kthr6w","tag_id":"cjyqq3tk6001efkqduomy7bl1","_id":"cjyqqii92000va0qda6h90omh"},{"post_id":"cjyqq3tk8001ifkqd3sisrf7b","tag_id":"cjyqq3tj30003fkqd7iramp0e","_id":"cjyqqii94000wa0qdbwrro8yo"},{"post_id":"cjyqq3tk7001gfkqdjwcvimd0","tag_id":"cjyqq3tj30003fkqd7iramp0e","_id":"cjyqqii96000ya0qdq6p2epe6"},{"post_id":"cjyqq3tkb001mfkqddni17oqc","tag_id":"cjyqq3tj30003fkqd7iramp0e","_id":"cjyqqii970010a0qdc6b2uw18"},{"post_id":"cjyqq3tkc001ofkqdpfp66hhf","tag_id":"cjyqq3tj30003fkqd7iramp0e","_id":"cjyqqii990013a0qdb9op3mij"},{"post_id":"cjyqq3tke001sfkqd3nglj09s","tag_id":"cjyqq3tj30003fkqd7iramp0e","_id":"cjyqqii9b0015a0qdhxr89usb"},{"post_id":"cjyqq3tkr0021fkqdfvuio1y5","tag_id":"cjyqq3tj30003fkqd7iramp0e","_id":"cjyqqii9o0017a0qdhlkr1j2y"},{"post_id":"cjyqq3tkt0023fkqdzl924y55","tag_id":"cjyqq3tj30003fkqd7iramp0e","_id":"cjyqqii9p0018a0qd58iim3mj"},{"post_id":"cjyqq3tkv0025fkqdqi9zqbf7","tag_id":"cjyqq3tkx0027fkqdd9r7jng5","_id":"cjyqqii9q001aa0qdba5e47bw"}],"Tag":[{"name":"Android","_id":"cjyqq3tj30003fkqd7iramp0e"},{"name":"Java","_id":"cjyqq3tjj000jfkqd8gzhe5uk"},{"name":"其他","_id":"cjyqq3tjo000qfkqdbdci77if"},{"name":"Web","_id":"cjyqq3tjr000vfkqd3pijxrpy"},{"name":"React Native","_id":"cjyqq3tk6001efkqduomy7bl1"},{"name":"人生杂谈","_id":"cjyqq3tkx0027fkqdd9r7jng5"}]}}